<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TIC TAC TOE_READY - VR Multiplayer Game</title>
  <script src="/vr/https-redirect.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a1a;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      user-select: none;
    }

    /* ===== BACKGROUND EFFECTS ===== */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse at 20% 50%, rgba(168,85,247,0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 20%, rgba(0,212,255,0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 80%, rgba(255,107,107,0.08) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    /* ===== STARFIELD ===== */
    #starfield {
      position: fixed;
      inset: 0;
      z-index: 0;
      overflow: hidden;
      pointer-events: none;
    }
    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #fff;
      border-radius: 50%;
      animation: twinkle var(--dur) ease-in-out infinite alternate;
    }
    @keyframes twinkle {
      from { opacity: 0.2; transform: scale(0.8); }
      to   { opacity: 1; transform: scale(1.2); }
    }

    /* ===== TOP BAR ===== */
    #top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: rgba(10,10,26,0.85);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(0,212,255,0.15);
    }
    #top-bar .back-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #94a3b8;
      padding: 8px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      text-decoration: none;
    }
    #top-bar .back-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    #top-bar .title {
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 2px;
    }
    #top-bar .title span.neon-x { color: #ff6b6b; text-shadow: 0 0 15px rgba(255,107,107,0.5); }
    #top-bar .title span.neon-o { color: #00d4ff; text-shadow: 0 0 15px rgba(0,212,255,0.5); }
    #top-bar .title span.ready-tag {
      font-size: 11px;
      background: linear-gradient(135deg, #a855f7, #ff6b6b);
      padding: 3px 10px;
      border-radius: 6px;
      margin-left: 8px;
      vertical-align: middle;
      letter-spacing: 1px;
    }

    /* ===== SCORE BAR ===== */
    #score-bar {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      z-index: 99;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 30px;
      padding: 10px 20px;
      background: rgba(10,10,26,0.7);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .score-item {
      text-align: center;
    }
    .score-item .label {
      font-size: 11px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .score-item .value {
      font-size: 28px;
      font-weight: 800;
    }
    .score-item .value.wins { color: #22c55e; text-shadow: 0 0 10px rgba(34,197,94,0.3); }
    .score-item .value.losses { color: #ef4444; text-shadow: 0 0 10px rgba(239,68,68,0.3); }
    .score-item .value.draws { color: #f59e0b; text-shadow: 0 0 10px rgba(245,158,11,0.3); }
    .score-divider {
      width: 1px;
      height: 40px;
      background: rgba(255,255,255,0.1);
    }

    /* ===== MAIN CONTAINER ===== */
    #game-area {
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-top: 40px;
    }

    /* ===== STATUS ===== */
    #status {
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      min-height: 30px;
      transition: all 0.3s;
    }
    #status.searching {
      color: #f59e0b;
      animation: pulse-text 1.5s ease-in-out infinite;
    }
    #status.your-turn { color: #22c55e; }
    #status.opponent-turn { color: #ff6b6b; }
    #status.win { color: #22c55e; font-size: 24px; text-shadow: 0 0 20px rgba(34,197,94,0.5); }
    #status.lose { color: #ef4444; font-size: 24px; text-shadow: 0 0 20px rgba(239,68,68,0.5); }
    #status.draw { color: #f59e0b; font-size: 24px; text-shadow: 0 0 20px rgba(245,158,11,0.5); }
    @keyframes pulse-text {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* ===== OPPONENT INFO ===== */
    #opponent-info {
      font-size: 13px;
      color: #64748b;
      text-align: center;
    }
    #opponent-info .human { color: #a855f7; }
    #opponent-info .ai { color: #06b6d4; }

    /* ===== BOARD ===== */
    #board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      width: min(80vw, 360px);
      height: min(80vw, 360px);
      perspective: 800px;
    }
    .cell {
      background: rgba(255,255,255,0.04);
      border: 2px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: min(15vw, 72px);
      font-weight: 800;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }
    .cell:hover:not(.taken) {
      background: rgba(255,255,255,0.08);
      border-color: rgba(0,212,255,0.3);
      transform: scale(1.03);
    }
    .cell.taken { cursor: default; }
    .cell .mark {
      animation: pop-in 0.3s cubic-bezier(0.175,0.885,0.32,1.275);
    }
    .cell .mark.x {
      color: #ff6b6b;
      text-shadow: 0 0 20px rgba(255,107,107,0.6), 0 0 40px rgba(255,107,107,0.2);
    }
    .cell .mark.o {
      color: #00d4ff;
      text-shadow: 0 0 20px rgba(0,212,255,0.6), 0 0 40px rgba(0,212,255,0.2);
    }
    @keyframes pop-in {
      from { transform: scale(0) rotate(-20deg); opacity: 0; }
      to   { transform: scale(1) rotate(0); opacity: 1; }
    }
    .cell.win-cell {
      animation: win-glow 0.6s ease-in-out infinite alternate;
      border-color: #22c55e !important;
    }
    @keyframes win-glow {
      from { box-shadow: inset 0 0 20px rgba(34,197,94,0.2); }
      to   { box-shadow: inset 0 0 30px rgba(34,197,94,0.5); }
    }

    /* ===== BUTTONS ===== */
    .btn-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .btn {
      padding: 12px 28px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 0.5px;
    }
    .btn:active { transform: scale(0.96); }
    .btn-primary {
      background: linear-gradient(135deg, #a855f7, #6366f1);
      color: #fff;
      border-color: rgba(168,85,247,0.5);
      box-shadow: 0 4px 20px rgba(168,85,247,0.3);
    }
    .btn-primary:hover { box-shadow: 0 6px 30px rgba(168,85,247,0.5); transform: translateY(-1px); }
    .btn-secondary {
      background: rgba(255,255,255,0.06);
      color: #94a3b8;
    }
    .btn-secondary:hover { background: rgba(255,255,255,0.12); color: #fff; }
    .btn-join {
      background: linear-gradient(135deg, #22c55e, #10b981);
      color: #fff;
      border-color: rgba(34,197,94,0.5);
      box-shadow: 0 4px 20px rgba(34,197,94,0.3);
      font-size: 18px;
      padding: 14px 40px;
    }
    .btn-join:hover { box-shadow: 0 6px 30px rgba(34,197,94,0.5); transform: translateY(-2px); }
    .btn-join.pulsing {
      animation: join-pulse 2s ease-in-out infinite;
    }
    @keyframes join-pulse {
      0%, 100% { box-shadow: 0 4px 20px rgba(34,197,94,0.3); }
      50% { box-shadow: 0 8px 40px rgba(34,197,94,0.6); }
    }

    /* ===== QUEUE INDICATOR ===== */
    #queue-indicator {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(168,85,247,0.15);
      border: 1px solid rgba(168,85,247,0.3);
      border-radius: 10px;
      font-size: 13px;
      color: #d8b4fe;
    }
    #queue-indicator .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #a855f7;
      animation: pulse-dot 1s ease-in-out infinite;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.4; transform: scale(0.7); }
    }

    /* ===== LOBBY ===== */
    #lobby {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #lobby h2 {
      font-size: 32px;
      font-weight: 900;
      background: linear-gradient(135deg, #ff6b6b, #a855f7, #00d4ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #lobby .subtitle {
      color: #64748b;
      font-size: 15px;
      text-align: center;
      max-width: 340px;
      line-height: 1.6;
    }

    /* ===== GAME OVER OVERLAY ===== */
    #game-over {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 200;
      background: rgba(10,10,26,0.9);
      backdrop-filter: blur(12px);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 20px;
    }
    #game-over.visible { display: flex; }
    #game-over .result-text {
      font-size: 48px;
      font-weight: 900;
      letter-spacing: 3px;
    }
    #game-over .result-text.win { color: #22c55e; text-shadow: 0 0 40px rgba(34,197,94,0.5); }
    #game-over .result-text.lose { color: #ef4444; text-shadow: 0 0 40px rgba(239,68,68,0.5); }
    #game-over .result-text.draw { color: #f59e0b; text-shadow: 0 0 40px rgba(245,158,11,0.5); }
    #game-over .result-sub { color: #64748b; font-size: 16px; }

    /* ===== DIFFICULTY SELECTOR ===== */
    #difficulty-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #difficulty-row .diff-label {
      font-size: 12px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .diff-btn {
      padding: 6px 14px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.04);
      color: #94a3b8;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .diff-btn:hover { background: rgba(255,255,255,0.1); }
    .diff-btn.active {
      background: rgba(168,85,247,0.2);
      border-color: #a855f7;
      color: #d8b4fe;
    }

    /* ===== CHALLENGER ALERT ===== */
    #challenger-alert {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 250;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 24px 20px 28px;
      background: linear-gradient(180deg, rgba(10,10,26,0.0) 0%, rgba(168,85,247,0.25) 30%, rgba(10,10,26,0.97) 100%);
      backdrop-filter: blur(16px);
      border-top: 2px solid #ec4899;
      animation: challenger-slide-up 0.5s cubic-bezier(0.16,1,0.3,1);
      pointer-events: auto;
    }
    #challenger-alert.visible { display: flex; }
    @keyframes challenger-slide-up {
      from { transform: translateY(100%); opacity: 0; }
      to   { transform: translateY(0); opacity: 1; }
    }
    #challenger-alert .challenger-icon {
      font-size: 48px;
      animation: challenger-bounce 0.6s ease-in-out infinite alternate;
    }
    @keyframes challenger-bounce {
      from { transform: scale(1) rotate(-5deg); }
      to   { transform: scale(1.15) rotate(5deg); }
    }
    #challenger-alert .challenger-title {
      font-size: 22px;
      font-weight: 900;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ec4899, #f59e0b, #ff6b6b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: challenger-text-glow 1s ease-in-out infinite alternate;
      text-align: center;
    }
    @keyframes challenger-text-glow {
      from { filter: brightness(1); }
      to   { filter: brightness(1.4); }
    }
    #challenger-alert .challenger-sub {
      color: #d8b4fe;
      font-size: 14px;
      text-align: center;
    }
    #challenger-alert .challenger-btns {
      display: flex;
      gap: 12px;
      margin-top: 4px;
    }
    .btn-challenger-accept {
      padding: 14px 36px;
      border-radius: 14px;
      border: 2px solid #ec4899;
      background: linear-gradient(135deg, #ec4899, #f43f5e);
      color: #fff;
      font-size: 16px;
      font-weight: 800;
      cursor: pointer;
      letter-spacing: 1px;
      text-transform: uppercase;
      transition: all 0.2s;
      box-shadow: 0 4px 24px rgba(236,72,153,0.4);
      animation: accept-pulse 1.5s ease-in-out infinite;
    }
    @keyframes accept-pulse {
      0%, 100% { box-shadow: 0 4px 24px rgba(236,72,153,0.4); }
      50% { box-shadow: 0 8px 40px rgba(236,72,153,0.7); }
    }
    .btn-challenger-accept:hover { transform: translateY(-2px) scale(1.03); }
    .btn-challenger-accept:active { transform: scale(0.97); }
    .btn-challenger-dismiss {
      padding: 14px 24px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: #94a3b8;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-challenger-dismiss:hover { background: rgba(255,255,255,0.12); color: #fff; }

    /* Screen flash effect for challenger */
    #challenger-flash {
      position: fixed;
      inset: 0;
      z-index: 240;
      background: radial-gradient(ellipse at center, rgba(236,72,153,0.3), transparent 70%);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
    }
    #challenger-flash.active {
      animation: flash-burst 0.8s ease-out forwards;
    }
    @keyframes flash-burst {
      0% { opacity: 1; }
      30% { opacity: 0.6; }
      60% { opacity: 0.3; }
      100% { opacity: 0; }
    }

    /* ===== CONFETTI ===== */
    .confetti-piece {
      position: fixed;
      z-index: 300;
      width: 8px;
      height: 8px;
      border-radius: 2px;
      pointer-events: none;
      animation: confetti-fall var(--fall-dur) ease-in forwards;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-20vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 500px) {
      #board { width: 88vw; height: 88vw; }
      #top-bar .title { font-size: 14px; }
      .score-item .value { font-size: 22px; }
    }
  </style>
</head>
<body>
  <!-- Starfield -->
  <div id="starfield"></div>

  <!-- Top Bar -->
  <div id="top-bar">
    <a href="/vr/" class="back-btn">&#x2190; VR Hub</a>
    <div class="title">
      TIC TAC <span class="neon-x">T</span><span class="neon-o">O</span>E
      <span class="ready-tag">_READY</span>
    </div>
    <div style="width: 80px;"></div>
  </div>

  <!-- Score Bar -->
  <div id="score-bar">
    <div class="score-item">
      <div class="label">Wins</div>
      <div class="value wins" id="wins-val">0</div>
    </div>
    <div class="score-divider"></div>
    <div class="score-item">
      <div class="label">Losses</div>
      <div class="value losses" id="losses-val">0</div>
    </div>
    <div class="score-divider"></div>
    <div class="score-item">
      <div class="label">Draws</div>
      <div class="value draws" id="draws-val">0</div>
    </div>
    <div class="score-divider"></div>
    <div class="score-item">
      <div class="label">Streak</div>
      <div class="value" id="streak-val" style="color: #a855f7;">0</div>
    </div>
  </div>

  <!-- Game Area -->
  <div id="game-area">
    <!-- Lobby (initial state) -->
    <div id="lobby">
      <h2>TIC TAC TOE_READY</h2>
      <p class="subtitle">
        Join the queue to play against another player. If no one's around, you'll battle an AI opponent.
      </p>
      <div id="queue-indicator">
        <div class="dot"></div>
        <span id="queue-text">Checking for players...</span>
      </div>
      <div id="difficulty-row">
        <span class="diff-label">AI Level:</span>
        <button class="diff-btn" data-diff="easy" onclick="setDifficulty('easy')">Easy</button>
        <button class="diff-btn active" data-diff="medium" onclick="setDifficulty('medium')">Medium</button>
        <button class="diff-btn" data-diff="hard" onclick="setDifficulty('hard')">Unbeatable</button>
      </div>
      <button class="btn btn-join pulsing" id="join-btn" onclick="joinGame()">
        JOIN &amp; PLAY
      </button>
    </div>

    <!-- Game Board (hidden initially) -->
    <div id="game-board" style="display:none;">
      <div id="opponent-info"></div>
      <div id="status">Your turn</div>
      <div id="board">
        <div class="cell" data-idx="0" onclick="cellClick(0)"></div>
        <div class="cell" data-idx="1" onclick="cellClick(1)"></div>
        <div class="cell" data-idx="2" onclick="cellClick(2)"></div>
        <div class="cell" data-idx="3" onclick="cellClick(3)"></div>
        <div class="cell" data-idx="4" onclick="cellClick(4)"></div>
        <div class="cell" data-idx="5" onclick="cellClick(5)"></div>
        <div class="cell" data-idx="6" onclick="cellClick(6)"></div>
        <div class="cell" data-idx="7" onclick="cellClick(7)"></div>
        <div class="cell" data-idx="8" onclick="cellClick(8)"></div>
      </div>
      <div class="btn-row" style="margin-top: 16px;">
        <button class="btn btn-secondary" onclick="quitToLobby()">Quit</button>
      </div>
    </div>
  </div>

  <!-- Challenger Flash -->
  <div id="challenger-flash"></div>

  <!-- Challenger Alert Banner -->
  <div id="challenger-alert">
    <div class="challenger-icon">&#x1F525;</div>
    <div class="challenger-title">A NEW CHALLENGER!</div>
    <div class="challenger-sub">A human player wants to battle you 1v1.<br>Abandon the bot match and face them?</div>
    <div class="challenger-btns">
      <button class="btn-challenger-accept" onclick="acceptChallenger()">FIGHT HUMAN</button>
      <button class="btn-challenger-dismiss" onclick="dismissChallenger()">Stay vs AI</button>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="game-over">
    <div class="result-text" id="result-text"></div>
    <div class="result-sub" id="result-sub"></div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="playAgain()">Play Again</button>
      <button class="btn btn-secondary" onclick="quitToLobby()">Back to Lobby</button>
    </div>
  </div>

  <script>
  (function () {
    'use strict';

    // ===== STARFIELD =====
    var sf = document.getElementById('starfield');
    for (var i = 0; i < 80; i++) {
      var s = document.createElement('div');
      s.className = 'star';
      s.style.left = Math.random() * 100 + '%';
      s.style.top = Math.random() * 100 + '%';
      s.style.setProperty('--dur', (2 + Math.random() * 4) + 's');
      s.style.animationDelay = (Math.random() * 3) + 's';
      sf.appendChild(s);
    }

    // ===== GAME STATE =====
    var board = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // 0=empty, 1=X(player), 2=O(opponent)
    var myMark = 1;   // 1=X, 2=O
    var gameActive = false;
    var isMyTurn = true;
    var isMultiplayer = false;
    var aiDifficulty = 'medium'; // easy, medium, hard
    var myId = 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);

    // Stats (session + localStorage)
    var STATS_KEY = 'ttt_ready_stats';
    var stats = loadStats();

    function loadStats() {
      try {
        var s = JSON.parse(localStorage.getItem(STATS_KEY));
        if (s && typeof s.wins === 'number') return s;
      } catch (e) { /* ignore */ }
      return { wins: 0, losses: 0, draws: 0, streak: 0, bestStreak: 0, gamesPlayed: 0 };
    }
    function saveStats() {
      try { localStorage.setItem(STATS_KEY, JSON.stringify(stats)); } catch (e) { /* ignore */ }
    }
    function updateStatsUI() {
      document.getElementById('wins-val').textContent = stats.wins;
      document.getElementById('losses-val').textContent = stats.losses;
      document.getElementById('draws-val').textContent = stats.draws;
      var streakEl = document.getElementById('streak-val');
      streakEl.textContent = stats.streak;
      streakEl.style.color = stats.streak > 0 ? '#22c55e' : stats.streak < 0 ? '#ef4444' : '#a855f7';
    }
    updateStatsUI();

    // ===== DIFFICULTY =====
    window.setDifficulty = function (diff) {
      aiDifficulty = diff;
      document.querySelectorAll('.diff-btn').forEach(function (b) {
        b.classList.toggle('active', b.dataset.diff === diff);
      });
    };

    // ===== SERVER-SIDE MATCHMAKING API =====
    var API_URL = '/api/ttt_match.php';
    var serverMatchId = null;
    var serverMyMark  = null;  // 'X' or 'O' from server
    var serverPollInterval = null;
    var lastServerBoard = '---------';
    var usingServer = false;  // true when playing via server API

    function apiPost(action, params, cb) {
      var body = 'action=' + encodeURIComponent(action);
      for (var k in params) {
        if (params.hasOwnProperty(k)) body += '&' + encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }
      var xhr = new XMLHttpRequest();
      xhr.open('POST', API_URL, true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      xhr.onload = function() { try { cb(null, JSON.parse(xhr.responseText)); } catch(e) { cb(e, null); } };
      xhr.onerror = function() { cb(new Error('Network'), null); };
      xhr.send(body);
    }

    function apiGet(action, params, cb) {
      var qs = '?action=' + encodeURIComponent(action);
      for (var k in params) { if (params.hasOwnProperty(k)) qs += '&' + encodeURIComponent(k) + '=' + encodeURIComponent(params[k]); }
      var xhr = new XMLHttpRequest();
      xhr.open('GET', API_URL + qs, true);
      xhr.onload = function() { try { cb(null, JSON.parse(xhr.responseText)); } catch(e) { cb(e, null); } };
      xhr.onerror = function() { cb(new Error('Network'), null); };
      xhr.send();
    }

    // ===== MULTIPLAYER VIA BROADCASTCHANNEL + SERVER =====
    var channel = null;
    var peerFound = false;
    var peerReady = false;
    var waitingForPeer = false;
    var matchId = null;
    var pendingChallengerId = null;
    var challengerAlertShown = false;

    function setupChannel() {
      if (typeof BroadcastChannel === 'undefined') return;
      channel = new BroadcastChannel('ttt_ready_lobby');
      channel.onmessage = function (evt) {
        var d = evt.data;
        if (!d || d.senderId === myId) return;

        switch (d.type) {
          case 'looking':
            if (waitingForPeer && !peerFound) {
              peerFound = true;
              matchId = myId + '_' + d.senderId;
              channel.postMessage({ type: 'match_accept', senderId: myId, matchId: matchId, targetId: d.senderId });
              // Cancel server queue if we were also waiting there
              if (serverMatchId) {
                apiPost('leave', { player_id: myId, match_id: serverMatchId }, function(){});
                serverMatchId = null;
              }
              startMultiplayerGame(false);
              return;
            }
            if (gameActive && !isMultiplayer && !challengerAlertShown) {
              pendingChallengerId = d.senderId;
              showChallengerAlert();
              channel.postMessage({ type: 'challenger_hold', senderId: myId, targetId: d.senderId });
            }
            break;

          case 'challenger_hold':
            if (d.targetId === myId && waitingForPeer) {
              document.getElementById('queue-text').textContent = 'Player found! Waiting for them to accept...';
            }
            break;

          case 'match_accept':
            if (d.targetId === myId && waitingForPeer && !peerFound) {
              peerFound = true;
              matchId = d.matchId;
              if (serverMatchId) {
                apiPost('leave', { player_id: myId, match_id: serverMatchId }, function(){});
                serverMatchId = null;
              }
              startMultiplayerGame(true);
            }
            break;

          case 'move':
            if (d.matchId === matchId && gameActive && !isMyTurn && !usingServer) {
              placeMarkOnBoard(d.cell, myMark === 1 ? 2 : 1);
              isMyTurn = true;
              updateStatus();
              checkGameEnd();
            }
            break;

          case 'rematch_request':
            if (d.matchId === matchId) {
              peerReady = true;
              if (gameActive === false) {
                startMultiplayerGame(myMark === 2);
              }
            }
            break;

          case 'challenger_left':
            if (d.senderId === pendingChallengerId) {
              hideChallengerAlert();
            }
            break;

          case 'quit':
            if (d.matchId === matchId && gameActive) {
              gameActive = false;
              isMultiplayer = false;
              showStatus('Opponent left!', 'win');
              recordResult('win');
            }
            break;
        }
      };
    }
    setupChannel();

    // ===== SERVER MULTIPLAYER FUNCTIONS =====
    function joinServerQueue() {
      apiPost('join', { player_id: myId, player_name: 'Player' }, function(err, data) {
        if (err || !data || !data.success) return;
        serverMatchId = data.match_id;
        serverMyMark  = data.mark;

        if (data.matched) {
          // Instant server match!
          if (!peerFound) {
            peerFound = true;
            usingServer = true;
            startServerMultiplayerGame(data);
          }
        } else {
          // Waiting — poll for match
          var elapsed = 0;
          serverPollInterval = setInterval(function() {
            if (peerFound) { clearInterval(serverPollInterval); return; }
            elapsed += 1500;
            if (elapsed > 45000) {
              clearInterval(serverPollInterval);
              serverPollInterval = null;
              if (!peerFound) {
                apiPost('leave', { player_id: myId, match_id: serverMatchId }, function(){});
                serverMatchId = null;
              }
              return;
            }
            apiGet('poll', { player_id: myId, match_id: serverMatchId }, function(err2, data2) {
              if (err2 || !data2 || !data2.success) return;
              if (data2.status === 'active' && !peerFound) {
                clearInterval(serverPollInterval);
                serverPollInterval = null;
                peerFound = true;
                usingServer = true;
                startServerMultiplayerGame(data2);
              }
            });
          }, 1500);
        }
      });
    }

    function startServerMultiplayerGame(data) {
      isMultiplayer = true;
      myMark = (data.my_mark || serverMyMark) === 'X' ? 1 : 2;
      isMyTurn = (myMark === 1); // X goes first
      waitingForPeer = false;
      peerReady = false;
      resetBoard();
      gameActive = true;
      lastServerBoard = '---------';

      document.getElementById('lobby').style.display = 'none';
      document.getElementById('game-board').style.display = 'flex';
      document.getElementById('game-board').style.flexDirection = 'column';
      document.getElementById('game-board').style.alignItems = 'center';
      document.getElementById('game-board').style.gap = '12px';

      var oppName = data.opponent || 'Human';
      document.getElementById('opponent-info').innerHTML = 'Playing vs <span class="human">' + oppName + '</span> (online)';
      updateStatus();

      // Start polling for opponent moves
      startServerGamePoll();
    }

    function startServerGamePoll() {
      if (serverPollInterval) clearInterval(serverPollInterval);
      serverPollInterval = setInterval(function() {
        if (!serverMatchId || !gameActive) { clearInterval(serverPollInterval); return; }
        apiGet('poll', { player_id: myId, match_id: serverMatchId }, function(err, data) {
          if (err || !data || !data.success) return;
          // Sync board
          if (data.board && data.board !== lastServerBoard) {
            syncServerBoard(data.board);
            lastServerBoard = data.board;
          }
          // Check game end
          if (data.status === 'done') {
            clearInterval(serverPollInterval);
            serverPollInterval = null;
            gameActive = false;
            var result = checkWinner();
            if (result) {
              if (result.line) {
                result.line.forEach(function(idx) {
                  document.querySelector('.cell[data-idx="' + idx + '"]').classList.add('win-cell');
                });
              }
            }
            setTimeout(function() {
              if (data.winner === 'D' || data.winner === 'A') {
                recordResult('draw');
                showGameOver('DRAW!', 'A battle of equals.', 'draw');
              } else {
                var winMark = data.winner === 'X' ? 1 : 2;
                if (winMark === myMark) {
                  recordResult('win');
                  showGameOver('YOU WIN!', 'You defeated the human!', 'win');
                  launchConfetti();
                } else {
                  recordResult('loss');
                  showGameOver('YOU LOSE!', 'The opponent got you!', 'lose');
                }
              }
            }, 600);
            return;
          }
          // Update turn
          var serverTurn = data.current_turn === 'X' ? 1 : 2;
          isMyTurn = (serverTurn === myMark);
          updateStatus();
        });
      }, 1200);
    }

    function syncServerBoard(serverBoard) {
      for (var i = 0; i < 9; i++) {
        var sMark = serverBoard[i];
        var localMark = board[i];
        if (sMark !== '-' && localMark === 0) {
          var markVal = sMark === 'X' ? 1 : 2;
          placeMarkOnBoard(i, markVal);
        }
      }
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (serverMatchId && usingServer && gameActive) {
        navigator.sendBeacon(API_URL + '?action=leave', 'player_id=' + encodeURIComponent(myId) + '&match_id=' + serverMatchId);
      }
    });

    // ===== CHALLENGER ALERT SYSTEM =====
    function showChallengerAlert() {
      challengerAlertShown = true;
      document.getElementById('challenger-alert').classList.add('visible');

      // Screen flash
      var flash = document.getElementById('challenger-flash');
      flash.classList.remove('active');
      void flash.offsetWidth; // reflow
      flash.classList.add('active');

      // TTS announcement
      speakChallenger('A new challenger! Do you want to join?');
    }

    function hideChallengerAlert() {
      challengerAlertShown = false;
      pendingChallengerId = null;
      document.getElementById('challenger-alert').classList.remove('visible');
    }

    function speakChallenger(text) {
      try {
        if ('speechSynthesis' in window) {
          window.speechSynthesis.cancel();
          var utter = new SpeechSynthesisUtterance(text);
          utter.rate = 1.1;
          utter.pitch = 1.2;
          utter.volume = 1;
          // Try to pick a dramatic voice
          var voices = window.speechSynthesis.getVoices();
          if (voices.length) {
            // Prefer English voices
            var eng = voices.filter(function (v) { return v.lang.indexOf('en') === 0; });
            if (eng.length) utter.voice = eng[0];
          }
          window.speechSynthesis.speak(utter);
        }
      } catch (e) { /* TTS not available, no-op */ }
    }

    // Ensure voices are loaded (some browsers load async)
    if ('speechSynthesis' in window) {
      window.speechSynthesis.onvoiceschanged = function () { /* voices now ready */ };
    }

    window.acceptChallenger = function () {
      if (!pendingChallengerId) return;

      // Abandon current AI game (no stat penalty — it's a forfeit to fight a human)
      gameActive = false;
      isMultiplayer = false;
      hideChallengerAlert();

      // Accept the human match
      peerFound = true;
      matchId = myId + '_' + pendingChallengerId;
      channel.postMessage({ type: 'match_accept', senderId: myId, matchId: matchId, targetId: pendingChallengerId });
      pendingChallengerId = null;

      // Start as O (the challenger was waiting first, they get X)
      startMultiplayerGame(false);
    };

    window.dismissChallenger = function () {
      // Stay in AI game, tell the challenger we declined
      if (pendingChallengerId && channel) {
        channel.postMessage({ type: 'challenger_declined', senderId: myId, targetId: pendingChallengerId });
      }
      hideChallengerAlert();
    };

    // ===== JOIN GAME =====
    window.joinGame = function () {
      var queueInd = document.getElementById('queue-indicator');

      // Show searching state
      queueInd.style.display = 'flex';
      document.getElementById('queue-text').textContent = 'Searching for opponent...';
      document.getElementById('join-btn').textContent = 'SEARCHING...';
      document.getElementById('join-btn').classList.remove('pulsing');
      document.getElementById('join-btn').disabled = true;

      waitingForPeer = true;
      peerFound = false;
      usingServer = false;

      // Broadcast locally (same-browser match)
      if (channel) {
        channel.postMessage({ type: 'looking', senderId: myId });
      }

      // Also join server queue (cross-device match)
      joinServerQueue();

      // Wait 8 seconds for a human opponent (server or local), then fall back to AI
      setTimeout(function () {
        if (!peerFound) {
          waitingForPeer = false;
          // Cancel server queue
          if (serverMatchId && !usingServer) {
            apiPost('leave', { player_id: myId, match_id: serverMatchId }, function(){});
            serverMatchId = null;
          }
          if (serverPollInterval) { clearInterval(serverPollInterval); serverPollInterval = null; }
          startAIGame();
        }
      }, 8000);
    };

    // ===== START AI GAME =====
    var aiPresenceInterval = null;

    function startAIGame() {
      isMultiplayer = false;
      myMark = 1; // Player is always X vs AI
      resetBoard();
      isMyTurn = true;
      gameActive = true;

      document.getElementById('lobby').style.display = 'none';
      document.getElementById('game-board').style.display = 'flex';
      document.getElementById('game-board').style.flexDirection = 'column';
      document.getElementById('game-board').style.alignItems = 'center';
      document.getElementById('game-board').style.gap = '12px';

      var diffLabel = aiDifficulty === 'easy' ? 'Easy' : aiDifficulty === 'medium' ? 'Medium' : 'Unbeatable';
      document.getElementById('opponent-info').innerHTML = 'Playing vs <span class="ai">AI (' + diffLabel + ')</span>';
      showStatus('Your turn - place your X!', 'your-turn');

      // Broadcast presence so new players know someone is here (playing AI)
      // They can send 'looking' and we'll show the challenger alert
      if (channel) {
        channel.postMessage({ type: 'in_ai_game', senderId: myId });
      }
      // Periodic heartbeat while in AI game
      clearInterval(aiPresenceInterval);
      aiPresenceInterval = setInterval(function () {
        if (!gameActive || isMultiplayer) { clearInterval(aiPresenceInterval); return; }
        if (channel) {
          channel.postMessage({ type: 'in_ai_game', senderId: myId });
        }
      }, 5000);
    }

    // ===== START MULTIPLAYER GAME =====
    function startMultiplayerGame(iAmX) {
      isMultiplayer = true;
      myMark = iAmX ? 1 : 2;
      isMyTurn = iAmX;
      waitingForPeer = false;
      peerReady = false;
      resetBoard();
      gameActive = true;

      document.getElementById('lobby').style.display = 'none';
      document.getElementById('game-board').style.display = 'flex';
      document.getElementById('game-board').style.flexDirection = 'column';
      document.getElementById('game-board').style.alignItems = 'center';
      document.getElementById('game-board').style.gap = '12px';

      document.getElementById('opponent-info').innerHTML = 'Playing vs <span class="human">Human Player</span>';
      updateStatus();
    }

    // ===== BOARD LOGIC =====
    function resetBoard() {
      board = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      var cells = document.querySelectorAll('.cell');
      cells.forEach(function (c) {
        c.innerHTML = '';
        c.classList.remove('taken', 'win-cell');
      });
    }

    function placeMarkOnBoard(idx, mark) {
      if (board[idx] !== 0) return false;
      board[idx] = mark;
      var cell = document.querySelector('.cell[data-idx="' + idx + '"]');
      var span = document.createElement('span');
      span.className = 'mark ' + (mark === 1 ? 'x' : 'o');
      span.textContent = mark === 1 ? 'X' : 'O';
      cell.innerHTML = '';
      cell.appendChild(span);
      cell.classList.add('taken');
      return true;
    }

    window.cellClick = function (idx) {
      if (!gameActive || !isMyTurn || board[idx] !== 0) return;

      placeMarkOnBoard(idx, myMark);

      if (isMultiplayer && usingServer && serverMatchId) {
        // Server multiplayer — send move via API
        var cellMark = myMark === 1 ? 'X' : 'O';
        isMyTurn = false;
        updateStatus();
        apiPost('move', { player_id: myId, match_id: serverMatchId, cell: idx }, function(err, data) {
          if (err || !data || !data.success) {
            // Move failed — will sync on next poll
            return;
          }
          if (data.board) lastServerBoard = data.board;
        });
      } else if (isMultiplayer && channel) {
        // BroadcastChannel multiplayer
        channel.postMessage({ type: 'move', senderId: myId, matchId: matchId, cell: idx });
        isMyTurn = false;
        updateStatus();
        if (checkGameEnd()) return;
      } else {
        // AI mode
        isMyTurn = false;
        updateStatus();
        if (checkGameEnd()) return;

        setTimeout(function () {
          if (!gameActive) return;
          var aiCell = getAIMove();
          if (aiCell !== -1) {
            placeMarkOnBoard(aiCell, myMark === 1 ? 2 : 1);
            isMyTurn = true;
            updateStatus();
            checkGameEnd();
          }
        }, 400 + Math.random() * 400);
      }
    };

    function updateStatus() {
      if (!gameActive) return;
      if (isMyTurn) {
        showStatus('Your turn - place your ' + (myMark === 1 ? 'X' : 'O') + '!', 'your-turn');
      } else {
        if (isMultiplayer) {
          showStatus('Waiting for opponent...', 'opponent-turn');
        } else {
          showStatus('AI is thinking...', 'opponent-turn');
        }
      }
    }

    function showStatus(text, cls) {
      var el = document.getElementById('status');
      el.textContent = text;
      el.className = cls || '';
    }

    // ===== WIN DETECTION =====
    var WIN_LINES = [
      [0,1,2], [3,4,5], [6,7,8], // rows
      [0,3,6], [1,4,7], [2,5,8], // cols
      [0,4,8], [2,4,6]           // diags
    ];

    function checkWinner() {
      for (var i = 0; i < WIN_LINES.length; i++) {
        var a = WIN_LINES[i][0], b = WIN_LINES[i][1], c = WIN_LINES[i][2];
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
          return { winner: board[a], line: WIN_LINES[i] };
        }
      }
      if (board.indexOf(0) === -1) return { winner: 0, line: null }; // draw
      return null; // game ongoing
    }

    function checkGameEnd() {
      var result = checkWinner();
      if (!result) return false;

      gameActive = false;

      if (result.line) {
        result.line.forEach(function (idx) {
          document.querySelector('.cell[data-idx="' + idx + '"]').classList.add('win-cell');
        });
      }

      setTimeout(function () {
        if (result.winner === 0) {
          recordResult('draw');
          showGameOver('DRAW!', 'A battle of equals.', 'draw');
        } else if (result.winner === myMark) {
          recordResult('win');
          showGameOver('YOU WIN!', isMultiplayer ? 'You defeated the human!' : 'You outsmarted the AI!', 'win');
          launchConfetti();
        } else {
          recordResult('loss');
          showGameOver('YOU LOSE!', isMultiplayer ? 'The opponent got you!' : 'The AI wins this round.', 'lose');
        }
      }, 600);

      return true;
    }

    function recordResult(result) {
      stats.gamesPlayed++;
      if (result === 'win') {
        stats.wins++;
        stats.streak = Math.max(0, stats.streak) + 1;
        stats.bestStreak = Math.max(stats.bestStreak, stats.streak);
      } else if (result === 'loss') {
        stats.losses++;
        stats.streak = Math.min(0, stats.streak) - 1;
      } else {
        stats.draws++;
        stats.streak = 0;
      }
      saveStats();
      updateStatsUI();
    }

    // ===== GAME OVER =====
    function showGameOver(text, sub, cls) {
      var overlay = document.getElementById('game-over');
      document.getElementById('result-text').textContent = text;
      document.getElementById('result-text').className = 'result-text ' + cls;
      document.getElementById('result-sub').textContent = sub;
      overlay.classList.add('visible');
    }

    window.playAgain = function () {
      document.getElementById('game-over').classList.remove('visible');

      if (isMultiplayer) {
        // Request rematch
        if (channel) {
          channel.postMessage({ type: 'rematch_request', senderId: myId, matchId: matchId });
        }
        if (peerReady) {
          startMultiplayerGame(myMark === 2); // swap who goes first
        } else {
          resetBoard();
          showStatus('Waiting for opponent to rematch...', 'searching');
          gameActive = false;
        }
      } else {
        startAIGame();
      }
    };

    window.quitToLobby = function () {
      document.getElementById('game-over').classList.remove('visible');
      hideChallengerAlert();

      if (isMultiplayer && channel) {
        channel.postMessage({ type: 'quit', senderId: myId, matchId: matchId });
      }

      gameActive = false;
      isMultiplayer = false;
      waitingForPeer = false;
      peerFound = false;
      pendingChallengerId = null;

      document.getElementById('game-board').style.display = 'none';
      document.getElementById('lobby').style.display = 'flex';
      document.getElementById('queue-indicator').style.display = 'none';
      document.getElementById('join-btn').textContent = 'JOIN & PLAY';
      document.getElementById('join-btn').classList.add('pulsing');
      document.getElementById('join-btn').disabled = false;
    };

    // ===== AI ENGINE =====
    function getAIMove() {
      var empty = [];
      for (var i = 0; i < 9; i++) {
        if (board[i] === 0) empty.push(i);
      }
      if (empty.length === 0) return -1;

      var aiMark = myMark === 1 ? 2 : 1;

      if (aiDifficulty === 'easy') {
        // 70% random, 30% smart
        if (Math.random() < 0.7) return empty[Math.floor(Math.random() * empty.length)];
        return getBestMove(aiMark);
      } else if (aiDifficulty === 'medium') {
        // 30% random, 70% smart
        if (Math.random() < 0.3) return empty[Math.floor(Math.random() * empty.length)];
        return getBestMove(aiMark);
      } else {
        // Unbeatable: always minimax
        return getBestMove(aiMark);
      }
    }

    function getBestMove(aiMark) {
      var bestScore = -Infinity;
      var bestCell = -1;
      var playerMark = aiMark === 1 ? 2 : 1;

      for (var i = 0; i < 9; i++) {
        if (board[i] !== 0) continue;
        board[i] = aiMark;
        var score = minimax(board, 0, false, aiMark, playerMark, -Infinity, Infinity);
        board[i] = 0;
        if (score > bestScore) {
          bestScore = score;
          bestCell = i;
        }
      }
      return bestCell;
    }

    function minimax(b, depth, isMaximizing, aiMark, playerMark, alpha, beta) {
      var result = evaluateBoard(b, aiMark, playerMark);
      if (result !== null) return result - depth * (result > 0 ? 1 : -1);

      if (isMaximizing) {
        var best = -Infinity;
        for (var i = 0; i < 9; i++) {
          if (b[i] !== 0) continue;
          b[i] = aiMark;
          var val = minimax(b, depth + 1, false, aiMark, playerMark, alpha, beta);
          b[i] = 0;
          best = Math.max(best, val);
          alpha = Math.max(alpha, val);
          if (beta <= alpha) break;
        }
        return best;
      } else {
        var best2 = Infinity;
        for (var j = 0; j < 9; j++) {
          if (b[j] !== 0) continue;
          b[j] = playerMark;
          var val2 = minimax(b, depth + 1, true, aiMark, playerMark, alpha, beta);
          b[j] = 0;
          best2 = Math.min(best2, val2);
          beta = Math.min(beta, val2);
          if (beta <= alpha) break;
        }
        return best2;
      }
    }

    function evaluateBoard(b, aiMark, playerMark) {
      for (var i = 0; i < WIN_LINES.length; i++) {
        var a = WIN_LINES[i][0], bb = WIN_LINES[i][1], c = WIN_LINES[i][2];
        if (b[a] && b[a] === b[bb] && b[a] === b[c]) {
          return b[a] === aiMark ? 10 : -10;
        }
      }
      if (b.indexOf(0) === -1) return 0; // draw
      return null; // not over
    }

    // ===== CONFETTI =====
    function launchConfetti() {
      var colors = ['#ff6b6b', '#00d4ff', '#22c55e', '#a855f7', '#f59e0b', '#ec4899'];
      for (var i = 0; i < 50; i++) {
        (function (idx) {
          setTimeout(function () {
            var piece = document.createElement('div');
            piece.className = 'confetti-piece';
            piece.style.left = Math.random() * 100 + 'vw';
            piece.style.background = colors[Math.floor(Math.random() * colors.length)];
            piece.style.setProperty('--fall-dur', (1.5 + Math.random() * 2) + 's');
            piece.style.width = (6 + Math.random() * 6) + 'px';
            piece.style.height = (6 + Math.random() * 6) + 'px';
            document.body.appendChild(piece);
            setTimeout(function () { piece.remove(); }, 4000);
          }, idx * 40);
        })(i);
      }
    }

    // ===== KEYBOARD SUPPORT =====
    document.addEventListener('keydown', function (e) {
      // Numpad / number keys 1-9 map to cells
      var keyMap = { '7': 0, '8': 1, '9': 2, '4': 3, '5': 4, '6': 5, '1': 6, '2': 7, '3': 8 };
      if (gameActive && isMyTurn && keyMap[e.key] !== undefined) {
        window.cellClick(keyMap[e.key]);
        return;
      }
      // Enter to play again
      if (e.key === 'Enter' && document.getElementById('game-over').classList.contains('visible')) {
        window.playAgain();
        return;
      }
      // Escape to quit
      if (e.key === 'Escape') {
        if (document.getElementById('game-over').classList.contains('visible')) {
          window.quitToLobby();
        } else if (gameActive) {
          window.quitToLobby();
        }
      }
    });

  })();
  </script>

  <!-- Nav Menu (shared across all VR zones) -->
  <script src="/vr/nav-menu.js"></script>
</body>
</html>
