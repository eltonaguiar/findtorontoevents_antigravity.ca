<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FPS Arena - 18+ | Game Arena | Toronto Events</title>
  <meta name="description" content="First-person shooter arena with customizable weapons, AI bots, high scores and ranks. 18+ only.">
  <script src="/vr/https-redirect.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a1a; color: #fff; font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; }

    /* ========== AGE GATE ========== */
    #age-gate {
      position: fixed; inset: 0; z-index: 100000;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a0020 50%, #0a0a1a 100%);
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
    }
    #age-gate.hidden { display: none; }
    .age-gate-card {
      background: rgba(15, 15, 35, 0.95);
      border: 1.5px solid rgba(239, 68, 68, 0.4);
      border-radius: 20px; padding: 40px; max-width: 480px; width: 90%;
      text-align: center; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.15);
    }
    .age-gate-card .warning-icon { font-size: 3rem; margin-bottom: 16px; }
    .age-gate-card h1 {
      font-size: 1.8rem; margin-bottom: 8px;
      background: linear-gradient(90deg, #ef4444, #f97316);
      background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .age-gate-card .subtitle { color: #94a3b8; font-size: 0.95rem; margin-bottom: 24px; line-height: 1.5; }
    .age-gate-card .login-status {
      background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px; padding: 16px; margin-bottom: 20px; font-size: 0.9rem;
    }
    .age-gate-card .login-status.logged-in { border-color: rgba(34,197,94,0.3); }
    .age-gate-card .login-status.not-logged-in { border-color: rgba(239,68,68,0.3); }
    .age-btn {
      padding: 14px 32px; border-radius: 12px; font-size: 1rem; font-weight: 600;
      cursor: pointer; border: none; transition: all 0.2s; margin: 6px;
    }
    .age-btn.confirm {
      background: linear-gradient(135deg, #ef4444, #dc2626); color: #fff;
    }
    .age-btn.confirm:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(239,68,68,0.3); }
    .age-btn.confirm:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }
    .age-btn.cancel {
      background: rgba(255,255,255,0.08); color: #94a3b8; border: 1px solid rgba(255,255,255,0.1);
    }
    .age-btn.cancel:hover { background: rgba(255,255,255,0.12); color: #fff; }
    .age-btn.login-btn {
      background: linear-gradient(135deg, #6366f1, #a855f7); color: #fff;
    }
    .age-btn.login-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99,102,241,0.3); }
    .age-gate-footer { color: #475569; font-size: 0.75rem; margin-top: 16px; line-height: 1.4; }

    /* ========== LOADING ========== */
    #loading-screen {
      position: fixed; inset: 0; z-index: 9999;
      background: linear-gradient(135deg, #0a0a1a, #1a0a2e);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      transition: opacity 0.5s;
    }
    #loading-screen.hidden { display: none; }
    #loading-screen h1 {
      font-size: 2.5rem; margin-bottom: 8px;
      background: linear-gradient(90deg, #ef4444, #f97316);
      background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    #loading-screen p { color: #666; font-size: 1rem; margin-bottom: 24px; }
    .load-bar { width: 200px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
    .load-bar-fill { height: 100%; background: linear-gradient(90deg, #ef4444, #f97316); width: 0%; transition: width 0.3s; }

    /* ========== GAME CANVAS ========== */
    #game-canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }

    /* ========== HUD ========== */
    #hud { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
    #hud > * { pointer-events: auto; }

    /* Crosshair */
    #crosshair {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      pointer-events: none;
    }
    .crosshair-dot { width: 4px; height: 4px; background: rgba(255,255,255,0.9); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .crosshair-line { position: absolute; background: rgba(255,255,255,0.7); }
    .crosshair-line.top { width: 2px; height: 12px; top: -18px; left: 50%; transform: translateX(-50%); }
    .crosshair-line.bottom { width: 2px; height: 12px; bottom: -18px; left: 50%; transform: translateX(-50%); }
    .crosshair-line.left { width: 12px; height: 2px; left: -18px; top: 50%; transform: translateY(-50%); }
    .crosshair-line.right { width: 12px; height: 2px; right: -18px; top: 50%; transform: translateY(-50%); }

    /* Health / Armor / Ammo bar */
    #hud-bottom {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 24px; align-items: flex-end;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 16px;
      padding: 12px 24px; pointer-events: none;
    }
    .hud-stat-group { text-align: center; }
    .hud-stat-group .label { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 4px; }
    .hud-stat-group .value { font-size: 28px; font-weight: 800; font-variant-numeric: tabular-nums; }
    .hud-stat-group .bar { width: 100px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 4px; }
    .hud-stat-group .bar-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }
    .health-val { color: #22c55e; }
    .armor-val { color: #3b82f6; }
    .ammo-val { color: #f59e0b; }
    .health-fill { background: #22c55e; }
    .armor-fill { background: #3b82f6; }

    /* Weapon info */
    #weapon-info {
      position: absolute; bottom: 20px; right: 20px;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 12px;
      padding: 10px 16px; text-align: right;
    }
    #weapon-info .weapon-name { font-size: 14px; font-weight: 700; color: #f97316; }
    #weapon-info .weapon-detail { font-size: 11px; color: #666; }

    /* Kill feed */
    #kill-feed {
      position: absolute; top: 16px; right: 16px;
      display: flex; flex-direction: column; gap: 4px; max-width: 300px;
    }
    .kill-entry {
      background: rgba(0,0,0,0.6); padding: 6px 12px; border-radius: 8px;
      font-size: 12px; color: #94a3b8; animation: killFadeIn 0.3s ease;
      border-left: 3px solid #ef4444;
    }
    .kill-entry .killer { color: #ef4444; font-weight: 600; }
    .kill-entry .victim { color: #3b82f6; font-weight: 600; }
    @keyframes killFadeIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }

    /* Score / Rank display */
    #hud-top-left {
      position: absolute; top: 16px; left: 16px;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 12px;
      padding: 10px 16px;
    }
    #hud-top-left .player-rank { font-size: 11px; color: #a855f7; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
    #hud-top-left .player-name { font-size: 15px; font-weight: 700; color: #fff; }
    .score-row { display: flex; gap: 16px; margin-top: 6px; }
    .score-item { text-align: center; }
    .score-item .s-val { font-size: 18px; font-weight: 800; }
    .score-item .s-lbl { font-size: 9px; text-transform: uppercase; color: #666; letter-spacing: 0.5px; }
    .kills-val { color: #ef4444; }
    .deaths-val { color: #64748b; }
    .streak-val { color: #f59e0b; }
    .xp-val { color: #a855f7; }

    /* Timer */
    #match-timer {
      position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 10px;
      padding: 8px 20px; text-align: center;
    }
    #match-timer .time { font-size: 22px; font-weight: 800; color: #fff; font-variant-numeric: tabular-nums; }
    #match-timer .mode { font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 1px; }

    /* Weapon wheel */
    #weapon-wheel {
      position: fixed; inset: 0; z-index: 200; display: none;
      background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
      align-items: center; justify-content: center;
    }
    #weapon-wheel.active { display: flex; }
    .weapon-wheel-ring {
      width: 400px; height: 400px; position: relative;
    }
    .weapon-slot {
      position: absolute; width: 90px; height: 90px;
      background: rgba(20,20,40,0.9); border: 2px solid rgba(255,255,255,0.1);
      border-radius: 14px; display: flex; flex-direction: column;
      align-items: center; justify-content: center; cursor: pointer;
      transition: all 0.2s; text-align: center;
    }
    .weapon-slot:hover, .weapon-slot.selected { border-color: #f97316; background: rgba(249,115,22,0.15); transform: scale(1.1); }
    .weapon-slot .w-icon { font-size: 28px; }
    .weapon-slot .w-name { font-size: 10px; font-weight: 600; color: #ccc; margin-top: 4px; }
    .weapon-slot .w-key { font-size: 9px; color: #666; margin-top: 2px; }

    /* Minimap */
    #minimap {
      position: absolute; bottom: 20px; left: 20px;
      width: 150px; height: 150px;
      background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50%; overflow: hidden;
    }
    #minimap canvas { width: 100%; height: 100%; border-radius: 50%; }

    /* Damage overlay */
    #damage-overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 90;
      border: 4px solid transparent; transition: border-color 0.1s;
    }
    #damage-overlay.hit { border-color: rgba(239, 68, 68, 0.5); }

    /* Pause / Menu */
    #pause-menu {
      position: fixed; inset: 0; z-index: 500;
      background: rgba(0,0,0,0.8); backdrop-filter: blur(12px);
      display: none; align-items: center; justify-content: center;
    }
    #pause-menu.active { display: flex; }
    .pause-card {
      background: rgba(15,15,35,0.95); border: 1.5px solid rgba(168,85,247,0.3);
      border-radius: 20px; padding: 32px; min-width: 360px; text-align: center;
    }
    .pause-card h2 { font-size: 1.8rem; margin-bottom: 20px; color: #a855f7; }
    .pause-btn {
      display: block; width: 100%; padding: 14px; margin-bottom: 10px;
      border-radius: 10px; border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.05); color: #fff; font-size: 15px;
      font-weight: 600; cursor: pointer; transition: all 0.2s;
    }
    .pause-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(168,85,247,0.4); }
    .pause-btn.resume { background: linear-gradient(135deg, #a855f7, #6366f1); border: none; }
    .pause-btn.resume:hover { transform: translateY(-2px); }

    /* Match end screen */
    #match-end {
      position: fixed; inset: 0; z-index: 600;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
      display: none; align-items: center; justify-content: center;
    }
    #match-end.active { display: flex; }
    .end-card {
      background: linear-gradient(135deg, rgba(15,15,35,0.95), rgba(30,10,50,0.95));
      border: 1.5px solid rgba(239,68,68,0.3); border-radius: 24px;
      padding: 40px; min-width: 400px; text-align: center;
      animation: endPop 0.5s ease;
    }
    @keyframes endPop { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
    .end-card h2 { font-size: 2rem; margin-bottom: 8px; }
    .end-card .end-subtitle { color: #94a3b8; margin-bottom: 24px; }
    .end-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px; }
    .end-stat { text-align: center; }
    .end-stat .es-val { font-size: 24px; font-weight: 800; }
    .end-stat .es-lbl { font-size: 10px; color: #666; text-transform: uppercase; }
    .rank-up-badge {
      background: linear-gradient(135deg, #f59e0b, #ef4444);
      color: #000; padding: 8px 24px; border-radius: 20px;
      font-weight: 800; font-size: 14px; display: inline-block; margin-bottom: 16px;
      animation: rankPulse 1s infinite;
    }
    @keyframes rankPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }

    /* High scores panel */
    #highscores-panel {
      position: fixed; inset: 0; z-index: 700;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
      display: none; align-items: center; justify-content: center;
    }
    #highscores-panel.active { display: flex; }
    .hs-card {
      background: rgba(15,15,35,0.95); border: 1.5px solid rgba(249,115,22,0.3);
      border-radius: 20px; padding: 32px; min-width: 500px; max-width: 90vw;
      max-height: 80vh; overflow-y: auto;
    }
    .hs-card h2 { text-align: center; margin-bottom: 20px; color: #f97316; }
    .hs-table { width: 100%; border-collapse: collapse; }
    .hs-table th { text-align: left; padding: 8px 12px; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.06); }
    .hs-table td { padding: 10px 12px; font-size: 14px; border-bottom: 1px solid rgba(255,255,255,0.03); }
    .hs-table tr:hover td { background: rgba(255,255,255,0.02); }
    .hs-rank-col { width: 40px; font-weight: 800; }
    .hs-gold { color: #fbbf24; }
    .hs-silver { color: #94a3b8; }
    .hs-bronze { color: #d97706; }

    /* Customize weapons panel */
    #customize-panel {
      position: fixed; inset: 0; z-index: 700;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
      display: none; align-items: center; justify-content: center;
    }
    #customize-panel.active { display: flex; }
    .cust-card {
      background: rgba(15,15,35,0.95); border: 1.5px solid rgba(34,197,94,0.3);
      border-radius: 20px; padding: 32px; min-width: 600px; max-width: 92vw;
      max-height: 85vh; overflow-y: auto;
    }
    .cust-card h2 { text-align: center; margin-bottom: 20px; color: #22c55e; }
    .cust-weapons { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; }
    .cust-weapon {
      background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px; padding: 16px; cursor: pointer; transition: all 0.2s;
    }
    .cust-weapon:hover { border-color: rgba(34,197,94,0.4); background: rgba(34,197,94,0.05); }
    .cust-weapon.selected { border-color: #22c55e; background: rgba(34,197,94,0.1); }
    .cust-weapon .cw-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .cust-weapon .cw-icon { font-size: 28px; }
    .cust-weapon .cw-name { font-weight: 700; font-size: 15px; }
    .cust-weapon .cw-type { font-size: 11px; color: #666; }
    .cust-stat { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .cust-stat .cs-lbl { font-size: 11px; color: #94a3b8; }
    .cust-stat .cs-bar { flex: 1; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin: 0 8px; }
    .cust-stat .cs-fill { height: 100%; border-radius: 3px; background: #22c55e; }
    .cust-stat .cs-val { font-size: 11px; color: #666; width: 24px; text-align: right; }

    /* Skin select */
    .skin-row { display: flex; gap: 6px; margin-top: 8px; }
    .skin-chip {
      width: 24px; height: 24px; border-radius: 6px; cursor: pointer;
      border: 2px solid transparent; transition: all 0.15s;
    }
    .skin-chip:hover, .skin-chip.active { border-color: #fff; transform: scale(1.15); }

    /* Back button */
    #back-btn {
      position: fixed; top: 16px; right: 16px; z-index: 50;
      background: rgba(10,10,30,0.85); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.15); border-radius: 10px;
      padding: 8px 16px; color: white; font-size: 13px; cursor: pointer;
      text-decoration: none; transition: all 0.2s;
    }
    #back-btn:hover { border-color: rgba(168,85,247,0.5); }

    /* Hit marker */
    #hitmarker {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      pointer-events: none; z-index: 95; opacity: 0; transition: opacity 0.1s;
    }
    #hitmarker.show { opacity: 1; }
    .hm-line {
      position: absolute; background: #fff; width: 2px; height: 14px;
    }
    .hm-line:nth-child(1) { top: -20px; left: -1px; transform: rotate(45deg); }
    .hm-line:nth-child(2) { top: -20px; right: -1px; transform: rotate(-45deg); }
    .hm-line:nth-child(3) { bottom: -20px; left: -1px; transform: rotate(-45deg); }
    .hm-line:nth-child(4) { bottom: -20px; right: -1px; transform: rotate(45deg); }

    /* Notification toast */
    .game-toast {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8); border: 1px solid rgba(249,115,22,0.4);
      border-radius: 12px; padding: 16px 32px; z-index: 800;
      font-size: 18px; font-weight: 700; text-align: center;
      animation: toastAnim 2s ease forwards; pointer-events: none;
    }
    @keyframes toastAnim { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 15% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 85% { opacity: 1; } 100% { opacity: 0; transform: translate(-50%, -70%); } }

    /* Difficulty selector in pause */
    .diff-row { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
    .diff-btn {
      padding: 8px 16px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.05); color: #94a3b8; font-size: 12px;
      font-weight: 600; cursor: pointer; transition: all 0.2s;
    }
    .diff-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
    .diff-btn.active { background: rgba(239,68,68,0.2); border-color: #ef4444; color: #ef4444; }

    /* ========== MULTIPLAYER LOBBY ========== */
    #mp-lobby {
      position: fixed; inset: 0; z-index: 1000;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a0020 50%, #0a0a1a 100%);
      display: none; align-items: center; justify-content: center;
    }
    #mp-lobby.active { display: flex; }
    .lobby-card {
      background: rgba(15,15,35,0.95); border: 1.5px solid rgba(99,102,241,0.4);
      border-radius: 24px; padding: 32px; min-width: 500px; max-width: 92vw;
      max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(99,102,241,0.15);
    }
    .lobby-card h2 {
      text-align: center; font-size: 1.8rem; margin-bottom: 4px;
      background: linear-gradient(90deg, #6366f1, #a855f7);
      background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .lobby-subtitle { text-align: center; color: #64748b; font-size: 0.85rem; margin-bottom: 24px; }
    .lobby-mode-select { display: flex; gap: 12px; margin-bottom: 24px; }
    .lobby-mode-btn {
      flex: 1; padding: 16px; border-radius: 14px; border: 2px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03); cursor: pointer; transition: all 0.2s; text-align: center;
    }
    .lobby-mode-btn:hover { border-color: rgba(99,102,241,0.4); background: rgba(99,102,241,0.05); }
    .lobby-mode-btn.selected { border-color: #6366f1; background: rgba(99,102,241,0.12); }
    .lobby-mode-btn .mode-icon { font-size: 2rem; display: block; margin-bottom: 6px; }
    .lobby-mode-btn .mode-title { font-size: 14px; font-weight: 700; color: #fff; }
    .lobby-mode-btn .mode-desc { font-size: 11px; color: #64748b; margin-top: 4px; }
    .lobby-section-title { font-size: 12px; color: #64748b; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; font-weight: 600; }
    .lobby-rooms { margin-bottom: 20px; max-height: 200px; overflow-y: auto; }
    .lobby-room-item {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px; margin-bottom: 6px; cursor: pointer; transition: all 0.2s;
    }
    .lobby-room-item:hover { border-color: rgba(99,102,241,0.3); background: rgba(99,102,241,0.05); }
    .room-info .room-name { font-size: 14px; font-weight: 600; color: #fff; }
    .room-info .room-meta { font-size: 11px; color: #64748b; }
    .room-players { font-size: 13px; font-weight: 700; color: #6366f1; }
    .room-state { font-size: 10px; padding: 3px 8px; border-radius: 6px; font-weight: 600; }
    .room-state.lobby { background: rgba(34,197,94,0.15); color: #22c55e; }
    .room-state.playing { background: rgba(249,115,22,0.15); color: #f97316; }
    .lobby-actions { display: flex; gap: 10px; margin-top: 20px; }
    .lobby-btn {
      flex: 1; padding: 14px; border-radius: 12px; font-size: 14px; font-weight: 700;
      cursor: pointer; border: none; transition: all 0.2s; text-align: center;
    }
    .lobby-btn.primary { background: linear-gradient(135deg, #6366f1, #a855f7); color: #fff; }
    .lobby-btn.primary:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99,102,241,0.3); }
    .lobby-btn.secondary { background: rgba(255,255,255,0.08); color: #94a3b8; border: 1px solid rgba(255,255,255,0.1); }
    .lobby-btn.secondary:hover { background: rgba(255,255,255,0.12); color: #fff; }
    .lobby-btn.danger { background: rgba(239,68,68,0.15); color: #ef4444; border: 1px solid rgba(239,68,68,0.2); }
    .lobby-btn.danger:hover { background: rgba(239,68,68,0.25); }
    .lobby-player-list { margin-bottom: 16px; }
    .lobby-player-item {
      display: flex; align-items: center; gap: 10px; padding: 8px 12px;
      background: rgba(255,255,255,0.02); border-radius: 8px; margin-bottom: 4px;
    }
    .lobby-player-item .lp-dot { width: 8px; height: 8px; border-radius: 50%; background: #22c55e; }
    .lobby-player-item .lp-name { flex: 1; font-size: 13px; font-weight: 600; color: #fff; }
    .lobby-player-item .lp-rank { font-size: 11px; color: #a855f7; }
    .lobby-player-item.is-you .lp-name { color: #6366f1; }
    .lobby-player-item.is-bot .lp-dot { background: #64748b; }
    .lobby-player-item.is-bot .lp-name { color: #94a3b8; }

    /* Game chat overlay */
    #game-chat {
      position: fixed; bottom: 80px; left: 16px; z-index: 150;
      width: 320px; pointer-events: auto;
    }
    #game-chat-messages {
      max-height: 160px; overflow-y: auto; margin-bottom: 4px;
      display: flex; flex-direction: column; gap: 2px;
    }
    .chat-msg {
      font-size: 12px; padding: 3px 8px; background: rgba(0,0,0,0.5);
      border-radius: 6px; color: #94a3b8; word-wrap: break-word;
    }
    .chat-msg .chat-name { font-weight: 700; color: #6366f1; }
    .chat-msg.system { color: #f59e0b; font-style: italic; }
    #game-chat-input {
      width: 100%; padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
      background: rgba(0,0,0,0.6); color: #fff; font-size: 12px; outline: none;
      display: none;
    }
    #game-chat-input:focus { border-color: rgba(99,102,241,0.4); }

    /* MP connection indicator */
    #mp-status {
      position: fixed; top: 16px; left: 50%; transform: translateX(calc(-50% + 100px));
      z-index: 110; display: none; align-items: center; gap: 6px;
      background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 8px;
      font-size: 11px; color: #64748b; pointer-events: none;
    }
    #mp-status .mp-dot { width: 6px; height: 6px; border-radius: 50%; }
    #mp-status .mp-dot.connected { background: #22c55e; }
    #mp-status .mp-dot.disconnected { background: #ef4444; }
    #mp-status .mp-dot.connecting { background: #f59e0b; animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
    .mp-player-count { color: #6366f1; font-weight: 700; }

    /* ========== DAMAGE DIRECTION INDICATOR ========== */
    #damage-indicators { position: fixed; inset: 0; pointer-events: none; z-index: 91; }
    .dmg-indicator {
      position: absolute; top: 50%; left: 50%;
      width: 80px; height: 80px;
      transform-origin: center center;
      pointer-events: none;
    }
    .dmg-indicator-arrow {
      position: absolute; top: 0; left: 50%; transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 10px solid transparent; border-right: 10px solid transparent;
      border-bottom: 30px solid rgba(239, 68, 68, 0.8);
      filter: blur(1px);
      animation: dmgFlash 0.6s ease-out forwards;
    }
    @keyframes dmgFlash { 0% { opacity: 1; } 100% { opacity: 0; } }

    /* ========== FLOATING DAMAGE NUMBERS ========== */
    .dmg-number {
      position: fixed; pointer-events: none; z-index: 96;
      font-weight: 900; font-size: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      animation: dmgFloat 1s ease-out forwards;
    }
    .dmg-number.headshot { color: #fbbf24; font-size: 28px; }
    .dmg-number.normal { color: #fff; }
    .dmg-number.crit { color: #ef4444; font-size: 24px; }
    @keyframes dmgFloat {
      0% { opacity: 1; transform: translateY(0) scale(1.2); }
      100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
    }

    /* ========== XP POPUP ========== */
    .xp-popup {
      position: fixed; top: 45%; left: 50%; transform: translateX(-50%);
      pointer-events: none; z-index: 97;
      font-weight: 800; font-size: 16px; color: #a855f7;
      text-shadow: 0 0 10px rgba(168,85,247,0.5);
      animation: xpPop 1.5s ease-out forwards;
    }
    @keyframes xpPop {
      0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
      15% { opacity: 1; transform: translateX(-50%) scale(1.1); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-40px); }
    }

    /* ========== TAB SCOREBOARD ========== */
    #tab-scoreboard {
      position: fixed; inset: 0; z-index: 400;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(8px);
      display: none; align-items: center; justify-content: center;
      pointer-events: none;
    }
    #tab-scoreboard.active { display: flex; }
    .sb-card {
      background: rgba(15,15,35,0.95); border: 1.5px solid rgba(168,85,247,0.3);
      border-radius: 20px; padding: 24px 32px; min-width: 500px; max-width: 700px;
    }
    .sb-card h2 {
      text-align: center; font-size: 1.2rem; margin-bottom: 12px; color: #a855f7;
      letter-spacing: 2px; text-transform: uppercase;
    }
    .sb-table { width: 100%; border-collapse: collapse; }
    .sb-table th {
      text-align: left; padding: 6px 10px; font-size: 10px; color: #64748b;
      text-transform: uppercase; letter-spacing: 1px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .sb-table td {
      padding: 8px 10px; font-size: 13px;
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }
    .sb-table tr.is-me td { color: #a855f7; font-weight: 700; }
    .sb-table tr.is-bot td { color: #64748b; }

    /* ========== LOW HEALTH EFFECTS ========== */
    #low-health-overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 89;
      background: radial-gradient(ellipse at center, transparent 50%, rgba(239,68,68,0.3) 100%);
      opacity: 0; transition: opacity 0.3s;
    }
    #low-health-overlay.active { animation: heartbeat 1s ease-in-out infinite; }
    @keyframes heartbeat {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.6; }
    }

    /* ========== FIRST PERSON WEAPON ========== */
    #fp-weapon {
      position: fixed; bottom: -10px; right: 60px; z-index: 85;
      pointer-events: none; transform-origin: bottom right;
    }
    #fp-weapon canvas { display: block; }
    #fp-weapon.firing { animation: weaponKick 0.08s ease-out; }
    #fp-weapon.reloading { animation: weaponReload 1.5s ease-in-out; }
    @keyframes weaponKick {
      0% { transform: translateY(0) rotate(0); }
      50% { transform: translateY(-8px) rotate(-3deg); }
      100% { transform: translateY(0) rotate(0); }
    }
    @keyframes weaponReload {
      0% { transform: translateY(0) rotate(0); }
      30% { transform: translateY(60px) rotate(15deg); }
      60% { transform: translateY(60px) rotate(15deg); }
      100% { transform: translateY(0) rotate(0); }
    }

    /* ========== STREAK BANNER ========== */
    .streak-banner {
      position: fixed; top: 30%; left: 50%; transform: translateX(-50%);
      z-index: 98; pointer-events: none; text-align: center;
      animation: streakBannerAnim 2.5s ease-out forwards;
    }
    .streak-banner .sb-title {
      font-size: 36px; font-weight: 900; letter-spacing: 4px;
      text-shadow: 0 0 20px rgba(239,68,68,0.5), 0 4px 8px rgba(0,0,0,0.5);
    }
    .streak-banner .sb-sub {
      font-size: 14px; color: #94a3b8; margin-top: 4px;
    }
    @keyframes streakBannerAnim {
      0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
      10% { opacity: 1; transform: translateX(-50%) scale(1.1); }
      20% { transform: translateX(-50%) scale(1); }
      80% { opacity: 1; }
      100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
    }

    /* ========== KILLCAM OVERLAY ========== */
    #killcam-overlay {
      display: none;
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 95; pointer-events: none;
    }
    #killcam-overlay.active { display: block; }
    .killcam-border {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      border: 3px solid rgba(255, 0, 0, 0.4);
      box-shadow: inset 0 0 80px rgba(0,0,0,0.5);
    }
    .killcam-vignette {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
    }
    .killcam-scanlines {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: repeating-linear-gradient(
        0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px
      );
    }
    .killcam-label {
      position: absolute; top: 20px; left: 20px;
      font-size: 28px; font-weight: 900; letter-spacing: 6px;
      color: #fff; text-shadow: 0 0 10px rgba(255,0,0,0.8), 0 0 30px rgba(255,0,0,0.4);
      animation: killcamPulse 1s ease-in-out infinite;
    }
    .killcam-sublabel {
      position: absolute; top: 58px; left: 20px;
      font-size: 14px; color: #ef4444; letter-spacing: 2px;
    }
    .killcam-recap {
      position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); border: 1px solid rgba(255,0,0,0.4);
      padding: 12px 30px; border-radius: 4px; text-align: center;
      backdrop-filter: blur(4px);
    }
    .killcam-recap-title {
      font-size: 11px; color: #666; letter-spacing: 3px; text-transform: uppercase;
      margin-bottom: 6px;
    }
    .killcam-recap-name {
      font-size: 22px; font-weight: 900; color: #ef4444; letter-spacing: 2px;
    }
    .killcam-recap-details {
      font-size: 12px; color: #94a3b8; margin-top: 4px; letter-spacing: 1px;
    }
    .killcam-skip {
      position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
      font-size: 12px; color: rgba(255,255,255,0.4); letter-spacing: 1px;
    }
    @keyframes killcamPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* ========== KILL CONFIRMED POPUP ========== */
    .kill-confirmed {
      position: fixed; top: 55%; left: 50%; transform: translate(-50%, -50%);
      z-index: 97; pointer-events: none;
      font-size: 14px; font-weight: 700; color: #ef4444;
      letter-spacing: 2px; text-transform: uppercase;
      animation: killConfAnim 1.2s ease-out forwards;
    }
    @keyframes killConfAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      15% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
      80% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -60%) scale(1); }
    }

    /* ========== SCOPE OVERLAY ========== */
    #scope-overlay {
      position: fixed; inset: 0; z-index: 88; pointer-events: none;
      display: none;
    }
    #scope-overlay.active { display: block; }
    #scope-overlay .scope-vignette {
      position: absolute; inset: 0;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.95) 70%);
    }
    #scope-overlay .scope-crosshair-h {
      position: absolute; top: 50%; left: 0; right: 0; height: 1px;
      background: rgba(255,0,0,0.5); transform: translateY(-50%);
    }
    #scope-overlay .scope-crosshair-v {
      position: absolute; left: 50%; top: 0; bottom: 0; width: 1px;
      background: rgba(255,0,0,0.5); transform: translateX(-50%);
    }

    /* ========== GRENADE INDICATOR ========== */
    #grenade-count {
      position: absolute; bottom: 80px; right: 20px;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 10px;
      padding: 6px 14px; text-align: center; font-size: 12px;
    }
    #grenade-count .g-val { font-size: 18px; font-weight: 800; color: #f59e0b; }
    #grenade-count .g-lbl { font-size: 9px; color: #666; text-transform: uppercase; }

    /* ========== MUZZLE FLASH OVERLAY ========== */
    #muzzle-flash-overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 86;
      background: radial-gradient(circle at 60% 75%, rgba(255,200,50,0.15) 0%, transparent 40%);
      opacity: 0; transition: opacity 0.02s;
    }
    #muzzle-flash-overlay.active { opacity: 1; }

    /* ========== SETTINGS PANEL ========== */
    #settings-panel {
      position: fixed; inset: 0; z-index: 750;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
      display: none; align-items: center; justify-content: center;
    }
    #settings-panel.active { display: flex; }
    .settings-card {
      background: rgba(15,15,35,0.95); border: 1.5px solid rgba(59,130,246,0.3);
      border-radius: 20px; padding: 32px; min-width: 450px; max-width: 90vw;
      max-height: 85vh; overflow-y: auto;
    }
    .settings-card h2 { text-align: center; margin-bottom: 20px; color: #3b82f6; }
    .setting-group { margin-bottom: 20px; }
    .setting-group .sg-title {
      font-size: 12px; color: #64748b; text-transform: uppercase;
      letter-spacing: 1px; margin-bottom: 10px; font-weight: 600;
    }
    .setting-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
    }
    .setting-row .sr-label { font-size: 14px; color: #ccc; }
    .setting-row .sr-value { font-size: 13px; color: #64748b; min-width: 40px; text-align: right; }
    .setting-row input[type="range"] {
      width: 150px; accent-color: #3b82f6; cursor: pointer;
    }
    .setting-row select {
      background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1);
      color: #fff; padding: 4px 8px; border-radius: 6px; font-size: 13px;
    }
    .crosshair-preview {
      width: 60px; height: 60px; background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      position: relative;
    }
    .crosshair-preview .cp-dot { width: 4px; height: 4px; border-radius: 50%; }
    .crosshair-preview .cp-line { position: absolute; }
    .crosshair-preview .cp-line.v { width: 2px; height: 10px; }
    .crosshair-preview .cp-line.h { width: 10px; height: 2px; }
    .crosshair-preview .cp-line.t { top: 10px; left: 50%; transform: translateX(-50%); }
    .crosshair-preview .cp-line.b { bottom: 10px; left: 50%; transform: translateX(-50%); }
    .crosshair-preview .cp-line.l { left: 10px; top: 50%; transform: translateY(-50%); }
    .crosshair-preview .cp-line.r { right: 10px; top: 50%; transform: translateY(-50%); }

    /* ========== CONTROLS HELP ========== */
    #controls-help {
      position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 12px;
      padding: 12px 20px; z-index: 95; pointer-events: none;
      display: flex; gap: 16px; font-size: 11px; color: #64748b;
      transition: opacity 1s;
    }
    .ctrl-item { display: flex; align-items: center; gap: 4px; }
    .ctrl-key {
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15);
      border-radius: 4px; padding: 2px 6px; font-size: 10px; color: #94a3b8;
      font-weight: 600; font-family: monospace;
    }

    /* ========== WEAPON INSPECT ========== */
    #weapon-inspect {
      position: fixed; inset: 0; z-index: 95;
      pointer-events: none; display: none;
      align-items: center; justify-content: center;
    }
    #weapon-inspect.active { display: flex; }
    .inspect-info {
      position: absolute; bottom: 200px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px; padding: 12px 20px; text-align: center;
    }
    .inspect-info .wi-name { font-size: 16px; font-weight: 700; color: #f97316; }
    .inspect-info .wi-type { font-size: 11px; color: #64748b; }
    .inspect-info .wi-skin { font-size: 12px; color: #94a3b8; margin-top: 4px; }

    /* ========== SLIDE INDICATOR ========== */
    #slide-indicator {
      position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.6); border: 1px solid rgba(99,102,241,0.3);
      border-radius: 8px; padding: 4px 12px; z-index: 96;
      font-size: 11px; color: #6366f1; font-weight: 600;
      display: none; pointer-events: none;
    }
  </style>
</head>
<body>

<!-- ========== AGE GATE ========== -->
<div id="age-gate">
  <div class="age-gate-card">
    <div class="warning-icon">&#9888;&#65039;</div>
    <h1>18+ Content - FPS Arena</h1>
    <p class="subtitle">
      This first-person shooter game contains simulated violence and is restricted to users aged 18 and over.
      You must be logged in with a verified FavCreators account to access this content.
    </p>
    <div class="login-status not-logged-in" id="login-status">
      <span id="login-status-text">Checking login status...</span>
    </div>
    <div id="age-gate-actions">
      <button class="age-btn login-btn" id="btn-login" style="display:none" onclick="goToLogin()">Log In to FavCreators</button>
      <button class="age-btn confirm" id="btn-confirm-age" disabled onclick="confirmAge()">I am 18+ &mdash; Enter Arena</button>
      <button class="age-btn cancel" onclick="window.location.href='/vr/game-arena/'">Go Back</button>
    </div>
    <p class="age-gate-footer">
      By entering, you confirm you are at least 18 years old.<br>
      This game uses the FavCreators user database for authentication.
    </p>
  </div>
</div>

<!-- ========== LOADING ========== -->
<div id="loading-screen" class="hidden">
  <h1>FPS ARENA</h1>
  <p>Loading weapons and arena...</p>
  <div class="load-bar"><div class="load-bar-fill" id="load-fill"></div></div>
</div>

<!-- ========== GAME CANVAS ========== -->
<canvas id="game-canvas"></canvas>

<!-- ========== HUD ========== -->
<div id="hud" style="display:none">
  <!-- Crosshair -->
  <div id="crosshair">
    <div class="crosshair-dot"></div>
    <div class="crosshair-line top"></div>
    <div class="crosshair-line bottom"></div>
    <div class="crosshair-line left"></div>
    <div class="crosshair-line right"></div>
  </div>

  <!-- Top left: Player info -->
  <div id="hud-top-left">
    <div class="player-rank" id="hud-rank">RECRUIT</div>
    <div class="player-name" id="hud-player-name">Player</div>
    <div class="score-row">
      <div class="score-item"><div class="s-val kills-val" id="hud-kills">0</div><div class="s-lbl">Kills</div></div>
      <div class="score-item"><div class="s-val deaths-val" id="hud-deaths">0</div><div class="s-lbl">Deaths</div></div>
      <div class="score-item"><div class="s-val streak-val" id="hud-streak">0</div><div class="s-lbl">Streak</div></div>
      <div class="score-item"><div class="s-val xp-val" id="hud-xp">0</div><div class="s-lbl">XP</div></div>
    </div>
    <div style="margin-top:6px;">
      <div style="display:flex;align-items:center;gap:6px;">
        <div style="font-size:9px;color:#666;text-transform:uppercase;">Next rank</div>
        <div style="flex:1;height:3px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;">
          <div id="hud-rank-bar" style="height:100%;background:#a855f7;width:0%;transition:width 0.5s;border-radius:2px;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Timer -->
  <div id="match-timer">
    <div class="mode" id="hud-mode">FREE FOR ALL</div>
    <div class="time" id="hud-timer">5:00</div>
  </div>

  <!-- Bottom: Health / Armor / Ammo -->
  <div id="hud-bottom">
    <div class="hud-stat-group">
      <div class="label">Health</div>
      <div class="value health-val" id="hud-health">100</div>
      <div class="bar"><div class="bar-fill health-fill" id="health-bar" style="width:100%"></div></div>
    </div>
    <div class="hud-stat-group">
      <div class="label">Armor</div>
      <div class="value armor-val" id="hud-armor">50</div>
      <div class="bar"><div class="bar-fill armor-fill" id="armor-bar" style="width:50%"></div></div>
    </div>
    <div class="hud-stat-group">
      <div class="label">Ammo</div>
      <div class="value ammo-val"><span id="hud-ammo-clip">30</span>/<span id="hud-ammo-reserve">120</span></div>
    </div>
  </div>

  <!-- Weapon info -->
  <div id="weapon-info">
    <div class="weapon-name" id="hud-weapon-name">M4 Carbine</div>
    <div class="weapon-detail" id="hud-weapon-detail">Assault Rifle &bull; Auto</div>
  </div>

  <!-- Kill feed -->
  <div id="kill-feed"></div>

  <!-- Minimap -->
  <div id="minimap"><canvas id="minimap-canvas" width="150" height="150"></canvas></div>

  <!-- Damage overlay -->
  <div id="damage-overlay"></div>

  <!-- Hitmarker -->
  <div id="hitmarker">
    <div class="hm-line"></div><div class="hm-line"></div><div class="hm-line"></div><div class="hm-line"></div>
  </div>

  <!-- Grenade count -->
  <div id="grenade-count">
    <div class="g-val" id="hud-grenades">3</div>
    <div class="g-lbl">Grenades [G]</div>
  </div>
</div>

<!-- Damage direction indicators -->
<div id="damage-indicators"></div>

<!-- Low health overlay -->
<div id="low-health-overlay"></div>

<!-- Killcam overlay -->
<div id="killcam-overlay">
  <div class="killcam-border"></div>
  <div class="killcam-vignette"></div>
  <div class="killcam-scanlines"></div>
  <div class="killcam-label">INSTANT REPLAY</div>
  <div class="killcam-sublabel" id="killcam-killer-name"></div>
  <div class="killcam-recap">
    <div class="killcam-recap-title">KILLED BY</div>
    <div class="killcam-recap-name" id="killcam-recap-name"></div>
    <div class="killcam-recap-details" id="killcam-recap-details"></div>
  </div>
  <div class="killcam-skip">Press any key to skip</div>
</div>

<!-- Muzzle flash screen overlay -->
<div id="muzzle-flash-overlay"></div>

<!-- Scope overlay for sniper ADS -->
<div id="scope-overlay">
  <div class="scope-vignette"></div>
  <div class="scope-crosshair-h"></div>
  <div class="scope-crosshair-v"></div>
</div>

<!-- Tab Scoreboard -->
<div id="tab-scoreboard">
  <div class="sb-card">
    <h2>Scoreboard</h2>
    <table class="sb-table">
      <thead><tr><th>#</th><th>Player</th><th>K</th><th>D</th><th>K/D</th><th>Streak</th></tr></thead>
      <tbody id="sb-tbody"></tbody>
    </table>
  </div>
</div>

<!-- First person weapon viewport -->
<div id="fp-weapon"><canvas id="fp-weapon-canvas" width="400" height="300"></canvas></div>

<!-- Settings Panel -->
<div id="settings-panel">
  <div class="settings-card">
    <h2>Settings</h2>
    <div class="setting-group">
      <div class="sg-title">Controls</div>
      <div class="setting-row">
        <span class="sr-label">Mouse Sensitivity</span>
        <input type="range" min="1" max="20" value="10" id="set-sensitivity" oninput="updateSetting('sensitivity', this.value)">
        <span class="sr-value" id="set-sensitivity-val">10</span>
      </div>
      <div class="setting-row">
        <span class="sr-label">ADS Sensitivity Mult</span>
        <input type="range" min="2" max="10" value="5" id="set-ads-sens" oninput="updateSetting('adsSens', this.value)">
        <span class="sr-value" id="set-ads-sens-val">0.5</span>
      </div>
    </div>
    <div class="setting-group">
      <div class="sg-title">Audio</div>
      <div class="setting-row">
        <span class="sr-label">Master Volume</span>
        <input type="range" min="0" max="100" value="40" id="set-volume" oninput="updateSetting('volume', this.value)">
        <span class="sr-value" id="set-volume-val">40%</span>
      </div>
    </div>
    <div class="setting-group">
      <div class="sg-title">Crosshair</div>
      <div class="setting-row">
        <span class="sr-label">Color</span>
        <select id="set-crosshair-color" onchange="updateSetting('crosshairColor', this.value)">
          <option value="rgba(255,255,255,0.7)">White</option>
          <option value="rgba(0,255,0,0.8)">Green</option>
          <option value="rgba(255,0,0,0.8)">Red</option>
          <option value="rgba(0,200,255,0.8)">Cyan</option>
          <option value="rgba(255,255,0,0.8)">Yellow</option>
          <option value="rgba(255,100,200,0.8)">Pink</option>
        </select>
        <div class="crosshair-preview" id="crosshair-preview">
          <div class="cp-dot" style="background:rgba(255,255,255,0.7)"></div>
          <div class="cp-line v t" style="background:rgba(255,255,255,0.7)"></div>
          <div class="cp-line v b" style="background:rgba(255,255,255,0.7)"></div>
          <div class="cp-line h l" style="background:rgba(255,255,255,0.7)"></div>
          <div class="cp-line h r" style="background:rgba(255,255,255,0.7)"></div>
        </div>
      </div>
      <div class="setting-row">
        <span class="sr-label">Crosshair Size</span>
        <input type="range" min="1" max="20" value="10" id="set-crosshair-size" oninput="updateSetting('crosshairSize', this.value)">
        <span class="sr-value" id="set-crosshair-size-val">10</span>
      </div>
    </div>
    <div class="setting-group">
      <div class="sg-title">Display</div>
      <div class="setting-row">
        <span class="sr-label">Field of View</span>
        <input type="range" min="60" max="110" value="75" id="set-fov" oninput="updateSetting('fov', this.value)">
        <span class="sr-value" id="set-fov-val">75</span>
      </div>
      <div class="setting-row">
        <span class="sr-label">Head Bob</span>
        <select id="set-headbob" onchange="updateSetting('headbob', this.value)">
          <option value="1">On</option>
          <option value="0">Off</option>
        </select>
      </div>
    </div>
    <div style="text-align:center;margin-top:20px;">
      <button class="pause-btn resume" onclick="closeSettings()">Save &amp; Close</button>
    </div>
  </div>
</div>

<!-- Controls Help Overlay (shown at match start, fades after 8 seconds) -->
<div id="controls-help">
  <div class="ctrl-item"><span class="ctrl-key">WASD</span> Move</div>
  <div class="ctrl-item"><span class="ctrl-key">MOUSE</span> Aim</div>
  <div class="ctrl-item"><span class="ctrl-key">LMB</span> Shoot</div>
  <div class="ctrl-item"><span class="ctrl-key">RMB</span> ADS</div>
  <div class="ctrl-item"><span class="ctrl-key">R</span> Reload</div>
  <div class="ctrl-item"><span class="ctrl-key">G</span> Grenade</div>
  <div class="ctrl-item"><span class="ctrl-key">SHIFT</span> Sprint</div>
  <div class="ctrl-item"><span class="ctrl-key">CTRL</span> Crouch</div>
  <div class="ctrl-item"><span class="ctrl-key">SPACE</span> Jump</div>
  <div class="ctrl-item"><span class="ctrl-key">TAB</span> Score</div>
  <div class="ctrl-item"><span class="ctrl-key">Q</span> Weapons</div>
  <div class="ctrl-item"><span class="ctrl-key">F</span> Inspect</div>
  <div class="ctrl-item"><span class="ctrl-key">ESC</span> Pause</div>
</div>

<!-- Weapon Inspect Overlay -->
<div id="weapon-inspect">
  <div class="inspect-info">
    <div class="wi-name" id="inspect-name">M4 Carbine</div>
    <div class="wi-type" id="inspect-type">Assault Rifle</div>
    <div class="wi-skin" id="inspect-skin">Skin: Default</div>
  </div>
</div>

<!-- Slide Indicator -->
<div id="slide-indicator">SLIDING</div>

<!-- ========== WEAPON WHEEL ========== -->
<div id="weapon-wheel">
  <div class="weapon-wheel-ring" id="weapon-ring"></div>
</div>

<!-- ========== PAUSE MENU ========== -->
<div id="pause-menu">
  <div class="pause-card">
    <h2>PAUSED</h2>
    <div class="diff-row">
      <button class="diff-btn" data-diff="easy" onclick="setDifficulty('easy')">Easy</button>
      <button class="diff-btn active" data-diff="normal" onclick="setDifficulty('normal')">Normal</button>
      <button class="diff-btn" data-diff="hard" onclick="setDifficulty('hard')">Hard</button>
      <button class="diff-btn" data-diff="insane" onclick="setDifficulty('insane')">Insane</button>
    </div>
    <button class="pause-btn resume" onclick="resumeGame()">Resume</button>
    <button class="pause-btn" onclick="showCustomize()">Customize Weapons</button>
    <button class="pause-btn" onclick="showHighscores()">High Scores &amp; Ranks</button>
    <button class="pause-btn" onclick="showSettings()">Settings</button>
    <button class="pause-btn" onclick="restartMatch()">New Match</button>
    <button class="pause-btn" onclick="window.location.href='/vr/game-arena/'">Exit to Game Arena</button>
  </div>
</div>

<!-- ========== MATCH END SCREEN ========== -->
<div id="match-end">
  <div class="end-card">
    <h2 id="end-title">MATCH OVER</h2>
    <p class="end-subtitle" id="end-subtitle">Great performance!</p>
    <div id="end-rank-up"></div>
    <div class="end-stats">
      <div class="end-stat"><div class="es-val kills-val" id="end-kills">0</div><div class="es-lbl">Kills</div></div>
      <div class="end-stat"><div class="es-val deaths-val" id="end-deaths">0</div><div class="es-lbl">Deaths</div></div>
      <div class="end-stat"><div class="es-val streak-val" id="end-best-streak">0</div><div class="es-lbl">Best Streak</div></div>
      <div class="end-stat"><div class="es-val xp-val" id="end-xp">0</div><div class="es-lbl">XP Earned</div></div>
    </div>
    <button class="pause-btn resume" onclick="restartMatch()">Play Again</button>
    <button class="pause-btn" onclick="showHighscores()">High Scores</button>
    <button class="pause-btn" onclick="window.location.href='/vr/game-arena/'">Exit to Arena</button>
  </div>
</div>

<!-- ========== HIGH SCORES PANEL ========== -->
<div id="highscores-panel">
  <div class="hs-card">
    <h2>&#127942; HIGH SCORES &amp; RANKS</h2>
    <div id="hs-my-rank" style="text-align:center; margin-bottom:20px;"></div>
    <table class="hs-table">
      <thead><tr><th class="hs-rank-col">#</th><th>Player</th><th>Rank</th><th>Score</th><th>Kills</th><th>K/D</th></tr></thead>
      <tbody id="hs-tbody"></tbody>
    </table>
    <div style="text-align:center; margin-top:20px;">
      <button class="pause-btn" onclick="closeHighscores()">Close</button>
    </div>
  </div>
</div>

<!-- ========== CUSTOMIZE WEAPONS PANEL ========== -->
<div id="customize-panel">
  <div class="cust-card">
    <h2>&#128299; Weapon Customization</h2>
    <div class="cust-weapons" id="cust-weapons-grid"></div>
    <div style="text-align:center; margin-top:20px;">
      <button class="pause-btn resume" onclick="closeCustomize()">Save &amp; Close</button>
    </div>
  </div>
</div>

<!-- ========== MULTIPLAYER LOBBY ========== -->
<div id="mp-lobby">
  <div class="lobby-card">
    <h2>FPS ARENA</h2>
    <p class="lobby-subtitle">Choose your mode and fight!</p>

    <!-- Mode selector -->
    <div class="lobby-mode-select">
      <div class="lobby-mode-btn selected" data-mode="solo" onclick="selectGameMode('solo')">
        <span class="mode-icon">&#129302;</span>
        <div class="mode-title">Solo vs AI</div>
        <div class="mode-desc">Fight AI bots offline</div>
      </div>
      <div class="lobby-mode-btn" data-mode="multiplayer" onclick="selectGameMode('multiplayer')">
        <span class="mode-icon">&#9876;&#65039;</span>
        <div class="mode-title">Multiplayer PvP</div>
        <div class="mode-desc">Fight other players + bots</div>
      </div>
      <div class="lobby-mode-btn" data-mode="quickmatch" onclick="selectGameMode('quickmatch')">
        <span class="mode-icon">&#9889;</span>
        <div class="mode-title">Quick Match</div>
        <div class="mode-desc">Auto-join a match</div>
      </div>
    </div>

    <!-- Solo options (shown for solo mode) -->
    <div id="solo-options">
      <div class="lobby-section-title">Difficulty</div>
      <div class="diff-row" style="margin-bottom:16px">
        <button class="diff-btn" data-diff="easy" onclick="setLobbyDiff('easy')">Easy</button>
        <button class="diff-btn active" data-diff="normal" onclick="setLobbyDiff('normal')">Normal</button>
        <button class="diff-btn" data-diff="hard" onclick="setLobbyDiff('hard')">Hard</button>
        <button class="diff-btn" data-diff="insane" onclick="setLobbyDiff('insane')">Insane</button>
      </div>
      <div id="lobby-stats" style="background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:14px;margin-bottom:16px;">
        <div style="display:flex;gap:20px;justify-content:center;text-align:center;">
          <div><div style="font-size:20px;font-weight:800;color:#a855f7;" id="lobby-rank-display">Recruit</div><div style="font-size:10px;color:#666;text-transform:uppercase;">Rank</div></div>
          <div><div style="font-size:20px;font-weight:800;color:#fff;" id="lobby-xp-display">0</div><div style="font-size:10px;color:#666;text-transform:uppercase;">Total XP</div></div>
          <div><div style="font-size:20px;font-weight:800;color:#ef4444;" id="lobby-kills-display">0</div><div style="font-size:10px;color:#666;text-transform:uppercase;">Total Kills</div></div>
          <div><div style="font-size:20px;font-weight:800;color:#64748b;" id="lobby-games-display">0</div><div style="font-size:10px;color:#666;text-transform:uppercase;">Games</div></div>
        </div>
      </div>
      <div style="text-align:center;margin-bottom:12px;">
        <div style="font-size:12px;color:#64748b;">Match: 5 minutes | 7 AI Bots | Arena: Neon Arena</div>
        <div style="font-size:11px;color:#475569;margin-top:4px;">Features: Weapon drops, hazard zones, grenades, pickups</div>
      </div>
      <div class="lobby-actions">
        <button class="lobby-btn primary" onclick="startSoloGame()">Start Solo Match</button>
        <button class="lobby-btn secondary" onclick="showHighscores()">High Scores</button>
        <button class="lobby-btn secondary" onclick="showSettings()">Settings</button>
      </div>
    </div>

    <!-- Multiplayer room browser (shown for multiplayer mode) -->
    <div id="mp-options" style="display:none">
      <div class="lobby-section-title">Available Rooms</div>
      <div class="lobby-rooms" id="mp-room-list">
        <div style="text-align:center;color:#475569;padding:20px;font-size:13px;">
          Connecting to server...
        </div>
      </div>
      <div class="lobby-actions">
        <button class="lobby-btn primary" onclick="createMultiplayerRoom()">Create Room</button>
        <button class="lobby-btn secondary" onclick="refreshRoomList()">&#x21BB; Refresh</button>
      </div>
    </div>

    <!-- Quick match (shown for quickmatch mode) -->
    <div id="qm-options" style="display:none">
      <div style="text-align:center;padding:20px;">
        <div style="font-size:3rem;margin-bottom:12px;">&#9889;</div>
        <div style="font-size:15px;color:#fff;font-weight:700;margin-bottom:8px;">Quick Match</div>
        <div style="font-size:13px;color:#64748b;margin-bottom:20px;">
          Automatically find or create a match with other players
        </div>
        <button class="lobby-btn primary" style="max-width:250px;margin:0 auto;display:block;" onclick="startQuickMatch()">Find Match</button>
      </div>
    </div>

    <!-- Waiting room (shown after joining MP room) -->
    <div id="mp-waiting" style="display:none">
      <div class="lobby-section-title">Room: <span id="mp-room-name">-</span></div>
      <div class="lobby-player-list" id="mp-player-list"></div>
      <div style="text-align:center;color:#64748b;font-size:12px;margin-bottom:12px;" id="mp-waiting-msg">Waiting for players...</div>
      <div class="lobby-actions">
        <button class="lobby-btn primary" id="mp-start-btn" onclick="startMultiplayerMatch()" style="display:none">Start Match</button>
        <button class="lobby-btn danger" onclick="leaveMultiplayerRoom()">Leave Room</button>
      </div>
    </div>

    <div style="text-align:center;margin-top:16px;">
      <a href="/vr/game-arena/" style="color:#475569;font-size:12px;text-decoration:none;">&#8592; Back to Game Arena</a>
    </div>
  </div>
</div>

<!-- ========== MULTIPLAYER HUD ELEMENTS ========== -->
<div id="mp-status">
  <div class="mp-dot connecting" id="mp-dot"></div>
  <span id="mp-status-text">Connecting...</span>
  <span class="mp-player-count" id="mp-player-count"></span>
</div>

<div id="game-chat" style="display:none">
  <div id="game-chat-messages"></div>
  <input type="text" id="game-chat-input" placeholder="Press T to chat, Enter to send..." maxlength="200">
</div>

<!-- Back button -->
<a id="back-btn" href="/vr/game-arena/" style="display:none">&#8592; Game Arena</a>

<!-- ========== THREE.JS + Socket.io CDN ========== -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>

<script>
// =============================================================================
// FPS ARENA - Full Game Engine
// =============================================================================
(function() {
'use strict';

//  CONSTANTS 
var FC_SESSION_URL = '/fc/api/session_check.php';
var FC_LOGIN_URL = '/fc/';

var ARENA_SIZE = 80;
var MATCH_DURATION = 300; // 5 minutes
var BOT_COUNT = 7;
var RESPAWN_TIME = 3;
var GRAVITY = -25;
var JUMP_SPEED = 10;
var PLAYER_HEIGHT = 1.7;
var PLAYER_SPEED = 8;
var SPRINT_MULTIPLIER = 1.6;

//  RANKS 
var RANKS = [
  { name: 'Recruit',           xp: 0,     color: '#94a3b8', icon: '&#9733;' },
  { name: 'Private',           xp: 100,   color: '#22c55e', icon: '&#9733;&#9733;' },
  { name: 'Corporal',          xp: 300,   color: '#3b82f6', icon: '&#9733;&#9733;&#9733;' },
  { name: 'Sergeant',          xp: 600,   color: '#6366f1', icon: '&#9734;' },
  { name: 'Staff Sergeant',    xp: 1000,  color: '#a855f7', icon: '&#9734;&#9734;' },
  { name: 'Lieutenant',        xp: 1500,  color: '#ec4899', icon: '&#9734;&#9734;&#9734;' },
  { name: 'Captain',           xp: 2200,  color: '#f59e0b', icon: '&#9733;&#9734;' },
  { name: 'Major',             xp: 3000,  color: '#ef4444', icon: '&#9733;&#9733;&#9734;' },
  { name: 'Colonel',           xp: 4000,  color: '#f97316', icon: '&#10029;' },
  { name: 'General',           xp: 5500,  color: '#fbbf24', icon: '&#10029;&#10029;' },
  { name: 'Commander',         xp: 7500,  color: '#e11d48', icon: '&#10029;&#10029;&#10029;' },
  { name: 'Legend',             xp: 10000, color: '#ff0000', icon: '&#127775;' }
];

//  WEAPONS DEFINITION 
var WEAPONS = [
  { id: 'pistol',    name: 'M9 Pistol',     type: 'Sidearm',        icon: '\uD83D\uDD2B', key: '1', damage: 22, fireRate: 3.5, clipSize: 12, reserve: 48, range: 40,  accuracy: 85, recoil: 8,  auto: false, spread: 0.02, color: '#94a3b8',
    skins: [{ name: 'Default', color: '#666' }, { name: 'Gold', color: '#fbbf24' }, { name: 'Shadow', color: '#1e293b' }, { name: 'Crimson', color: '#dc2626' }] },
  { id: 'shotgun',   name: 'SPAS-12',       type: 'Shotgun',        icon: '\uD83D\uDD2B', key: '2', damage: 85, fireRate: 1.2, clipSize: 8,  reserve: 24, range: 15,  accuracy: 60, recoil: 35, auto: false, spread: 0.08, color: '#f97316',
    skins: [{ name: 'Default', color: '#8b5e34' }, { name: 'Woodland', color: '#365314' }, { name: 'Arctic', color: '#e2e8f0' }, { name: 'Neon', color: '#22d3ee' }] },
  { id: 'smg',       name: 'MP5K',          type: 'SMG',            icon: '\uD83D\uDD2B', key: '3', damage: 18, fireRate: 12,  clipSize: 30, reserve: 120, range: 25, accuracy: 70, recoil: 12, auto: true,  spread: 0.035, color: '#3b82f6',
    skins: [{ name: 'Default', color: '#555' }, { name: 'Blue Tiger', color: '#1e40af' }, { name: 'Rose', color: '#e11d48' }, { name: 'Digital', color: '#059669' }] },
  { id: 'assault',   name: 'M4 Carbine',    type: 'Assault Rifle',  icon: '\uD83D\uDD2B', key: '4', damage: 28, fireRate: 8,   clipSize: 30, reserve: 120, range: 50, accuracy: 78, recoil: 15, auto: true,  spread: 0.025, color: '#22c55e',
    skins: [{ name: 'Default', color: '#4a4a4a' }, { name: 'Desert', color: '#d4a76a' }, { name: 'Urban', color: '#475569' }, { name: 'Dragon', color: '#dc2626' }] },
  { id: 'sniper',    name: 'AWP',           type: 'Sniper Rifle',   icon: '\uD83C\uDFAF', key: '5', damage: 110, fireRate: 0.8, clipSize: 5,  reserve: 20, range: 100, accuracy: 96, recoil: 45, auto: false, spread: 0.005, color: '#a855f7',
    skins: [{ name: 'Default', color: '#2d3748' }, { name: 'Lightning', color: '#7c3aed' }, { name: 'Emerald', color: '#10b981' }, { name: 'Inferno', color: '#f97316' }] },
  { id: 'rocket',    name: 'RPG-7',         type: 'Rocket Launcher', icon: '\uD83D\uDE80', key: '6', damage: 150, fireRate: 0.5, clipSize: 1, reserve: 6,  range: 60,  accuracy: 50, recoil: 50, auto: false, spread: 0.04, color: '#ef4444',
    skins: [{ name: 'Default', color: '#6b6b6b' }, { name: 'Camo', color: '#365314' }, { name: 'Chrome', color: '#cbd5e1' }, { name: 'Magma', color: '#ea580c' }] }
];

//  BOT NAMES 
var BOT_NAMES = [
  'ShadowStrike', 'NightHawk', 'IronWolf', 'PhantomAce',
  'RapidFire', 'FrostBite', 'BlazeRunner', 'StormBringer',
  'SilentScope', 'ThunderBolt', 'ViperKing', 'DarkReaper',
  'CyberNinja', 'SteelViper', 'GhostRider', 'BulletProof'
];

//  STATE 
var state = {
  authenticated: false,
  userId: null,
  userName: 'Player',
  gameStarted: false,
  paused: false,
  matchActive: false,
  matchTime: MATCH_DURATION,
  difficulty: 'normal',
  // Player state
  health: 100,
  maxHealth: 100,
  armor: 50,
  maxArmor: 100,
  kills: 0,
  deaths: 0,
  streak: 0,
  bestStreak: 0,
  xpThisMatch: 0,
  // Weapon state
  currentWeapon: 3, // M4
  ammoClip: [],
  ammoReserve: [],
  // Weapon skins
  weaponSkins: {},
  // Movement
  velocity: new THREE.Vector3(),
  onGround: true,
  sprinting: false,
  // Input
  keys: {},
  mouseDown: false,
  fireTimer: 0,
  reloading: false,
  reloadTimer: 0,
  // Camera
  pitch: 0,
  yaw: 0,
  mouseSensitivity: 0.002,
  // Bots
  bots: [],
  // Projectiles
  projectiles: [],
  // Pickups
  pickups: [],
  // Effects
  muzzleFlashTimer: 0,
  // Persistent
  totalXP: 0,
  totalKills: 0,
  totalDeaths: 0,
  gamesPlayed: 0,
  highScores: []
};

//  ENHANCED STATE 
state.crouching = false;
state.crouchLerp = 0;
state.ads = false;
state.adsLerp = 0;
state.headBobTimer = 0;
state.headBobAmount = 0;
state.screenShake = 0;
state.screenShakeDecay = 0;
state.viewPunchX = 0;
state.viewPunchY = 0;
state.weaponSwayX = 0;
state.weaponSwayY = 0;
state.lastDamageDir = 0;
state.grenades = 3;
state.grenadeTimer = 0;
state.baseFov = 75;
state.targetFov = 75;
state.crosshairSpread = 0;
state.footstepTimer = 0;

//  KILLCAM REPLAY SYSTEM 
var KILLCAM_DURATION = 8;
var KILLCAM_FREEZE_TIME = 2;
var REPLAY_FPS = 20;
var REPLAY_BUFFER_SECONDS = 6;
var REPLAY_MAX_FRAMES = REPLAY_FPS * REPLAY_BUFFER_SECONDS;

var replayBuffer = [];
var replayRecordAccum = 0;
var replayShots = [];

var killcam = {
  active: false,
  frames: [],
  shots: [],
  killerName: '',
  killerIdx: -1,
  ghostMesh: null,
  killerRing: null,
  killerLabel: null,
  startTime: 0,
  totalDuration: 0,
  savedPitch: 0,
  savedYaw: 0,
  freezing: false,
  freezeStart: 0,
  deathDistance: 0,
  lastShotCount: 0
};

function recordReplayFrame(dt) {
  replayRecordAccum += dt;
  if (replayRecordAccum < 1 / REPLAY_FPS) return;
  replayRecordAccum = 0;

  var frame = {
    t: performance.now(),
    px: camera.position.x,
    py: camera.position.y,
    pz: camera.position.z,
    pp: state.pitch,
    pw: state.yaw,
    bots: []
  };

  for (var i = 0; i < state.bots.length; i++) {
    var b = state.bots[i];
    frame.bots.push({
      x: b.position.x,
      z: b.position.z,
      ry: b.mesh.rotation.y,
      alive: b.alive
    });
  }

  replayBuffer.push(frame);
  if (replayBuffer.length > REPLAY_MAX_FRAMES) replayBuffer.shift();
}

function recordShot(attackerName, fromPos) {
  replayShots.push({
    t: performance.now(),
    name: attackerName,
    fx: fromPos.x,
    fz: fromPos.z,
    tx: camera.position.x,
    tz: camera.position.z
  });
  if (replayShots.length > 60) replayShots.shift();
}

function createGhostPlayer() {
  var group = new THREE.Group();

  // All materials use MeshBasicMaterial  self-lit, always visible regardless of lighting
  // Body (bright white/cyan  maximum contrast)
  var bodyGeo = new THREE.BoxGeometry(0.7, 1.1, 0.45);
  var bodyMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.85 });
  var body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.2;
  group.add(body);

  // Head
  var headGeo = new THREE.SphereGeometry(0.22, 8, 8);
  var headMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.85 });
  var head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.9;
  group.add(head);

  // Legs
  var legGeo = new THREE.BoxGeometry(0.18, 0.7, 0.18);
  var legMat = new THREE.MeshBasicMaterial({ color: 0x00dddd, transparent: true, opacity: 0.85 });
  var leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-0.17, 0.35, 0);
  group.add(leftLeg);
  var rightLeg = new THREE.Mesh(legGeo, legMat.clone());
  rightLeg.position.set(0.17, 0.35, 0);
  group.add(rightLeg);

  // Arms
  var armGeo = new THREE.BoxGeometry(0.14, 0.65, 0.14);
  var armMat = new THREE.MeshBasicMaterial({ color: 0x00dddd, transparent: true, opacity: 0.85 });
  var leftArm = new THREE.Mesh(armGeo, armMat);
  leftArm.position.set(-0.45, 1.1, 0);
  group.add(leftArm);
  var rightArm = new THREE.Mesh(armGeo, armMat.clone());
  rightArm.position.set(0.45, 1.1, 0.15);
  group.add(rightArm);

  // Glowing beacon ring at feet (ground marker)
  var ringGeo = new THREE.RingGeometry(0.6, 0.9, 32);
  var ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  var ring = new THREE.Mesh(ringGeo, ringMat);
  ring.rotation.x = -Math.PI / 2;
  ring.position.y = 0.05;
  group.add(ring);

  // Vertical beacon line above the ghost
  var beaconGeo = new THREE.CylinderGeometry(0.03, 0.03, 6, 4);
  var beaconMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
  var beacon = new THREE.Mesh(beaconGeo, beaconMat);
  beacon.position.y = 4;
  group.add(beacon);

  // Large "YOU" label (billboard sprite)
  var nameCanvas = document.createElement('canvas');
  nameCanvas.width = 256; nameCanvas.height = 64;
  var nCtx = nameCanvas.getContext('2d');
  nCtx.fillStyle = 'rgba(0,200,200,0.6)';
  nCtx.fillRect(0, 0, 256, 64);
  nCtx.strokeStyle = '#00ffff';
  nCtx.lineWidth = 3;
  nCtx.strokeRect(0, 0, 256, 64);
  nCtx.font = 'bold 40px Inter, sans-serif';
  nCtx.textAlign = 'center';
  nCtx.fillStyle = '#ffffff';
  nCtx.fillText('YOU', 128, 46);
  var nameTex = new THREE.CanvasTexture(nameCanvas);
  var nameSpriteMat = new THREE.SpriteMaterial({ map: nameTex, transparent: true, depthWrite: false });
  var nameSprite = new THREE.Sprite(nameSpriteMat);
  nameSprite.position.set(0, 2.8, 0);
  nameSprite.scale.set(2.5, 0.6, 1);
  group.add(nameSprite);

  scene.add(group);
  killcam.ghostMesh = group;
}

function startKillcam(killerName) {
  killcam.savedPitch = state.pitch;
  killcam.savedYaw = state.yaw;
  killcam.freezing = false;
  killcam.freezeStart = 0;
  killcam.ghostMesh = null;

  killcam.frames = replayBuffer.slice();
  killcam.shots = replayShots.slice();
  killcam.lastShotCount = 0;
  for (var s = 0; s < killcam.shots.length; s++) killcam.shots[s].shown = false;
  killcam.killerName = killerName;
  killcam.startTime = performance.now();

  // Find killer bot index
  killcam.killerIdx = -1;
  for (var i = 0; i < state.bots.length; i++) {
    if (state.bots[i].name === killerName) {
      killcam.killerIdx = i;
      break;
    }
  }

  // Calculate death distance
  killcam.deathDistance = 0;
  if (killcam.killerIdx >= 0) {
    var kb = state.bots[killcam.killerIdx];
    var dx = camera.position.x - kb.position.x;
    var dz = camera.position.z - kb.position.z;
    killcam.deathDistance = Math.round(Math.sqrt(dx * dx + dz * dz));
  }

  // Count shots from killer in buffer
  killcam.lastShotCount = 0;
  for (var sc = 0; sc < killcam.shots.length; sc++) {
    if (killcam.shots[sc].name === killerName) killcam.lastShotCount++;
  }

  // Playback duration from buffer
  if (killcam.frames.length >= 2) {
    killcam.totalDuration = (killcam.frames[killcam.frames.length - 1].t - killcam.frames[0].t) / 1000;
  } else {
    killcam.totalDuration = 2;
  }

  // Create ghost player mesh (the "YOU" avatar visible during replay)
  createGhostPlayer();

  // Highlight the killer bot with red glow + KILLER label
  if (killcam.killerIdx >= 0) {
    var killerBot = state.bots[killcam.killerIdx];
    if (killerBot && killerBot.mesh) {
      // Red ring at feet
      var ringGeo = new THREE.RingGeometry(0.8, 1.1, 32);
      var ringMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
      var ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = 0.05;
      killerBot.mesh.add(ring);
      killcam.killerRing = ring;

      // KILLER label
      var labelCanvas = document.createElement('canvas');
      labelCanvas.width = 256; labelCanvas.height = 64;
      var lCtx = labelCanvas.getContext('2d');
      lCtx.fillStyle = 'rgba(200,0,0,0.7)';
      lCtx.fillRect(0, 0, 256, 64);
      lCtx.strokeStyle = '#ff0000';
      lCtx.lineWidth = 3;
      lCtx.strokeRect(0, 0, 256, 64);
      lCtx.font = 'bold 36px Inter, sans-serif';
      lCtx.textAlign = 'center';
      lCtx.fillStyle = '#ffffff';
      lCtx.fillText('KILLER', 128, 44);
      var labelTex = new THREE.CanvasTexture(labelCanvas);
      var labelSpriteMat = new THREE.SpriteMaterial({ map: labelTex, transparent: true, depthWrite: false });
      var labelSprite = new THREE.Sprite(labelSpriteMat);
      labelSprite.position.set(0, 3.2, 0);
      labelSprite.scale.set(2.5, 0.6, 1);
      killerBot.mesh.add(labelSprite);
      killcam.killerLabel = labelSprite;

      // Red glow on killer body
      killerBot.mesh.children.forEach(function(c) {
        if (c.material && c.material.emissive && c !== ring && c !== labelSprite) {
          c.material.emissive.setHex(0x660000);
          c.material.emissiveIntensity = 0.5;
        }
      });
    }
  }

  // Show overlay + death recap
  document.getElementById('killcam-overlay').classList.add('active');
  document.getElementById('killcam-killer-name').textContent = killerName;
  document.getElementById('killcam-recap-name').textContent = killerName;
  var detailParts = [];
  if (killcam.deathDistance > 0) detailParts.push(killcam.deathDistance + 'm distance');
  if (killcam.lastShotCount > 0) detailParts.push(killcam.lastShotCount + ' shots landed');
  document.getElementById('killcam-recap-details').textContent = detailParts.join('  //  ');

  // Hide crosshair + first-person weapon during replay
  document.getElementById('crosshair').style.display = 'none';
  document.getElementById('fp-weapon').style.display = 'none';

  // Subtle film look
  var canvas = document.getElementById('game-canvas');
  canvas.style.filter = 'contrast(1.1) brightness(0.95)';
  canvas.style.transition = 'filter 0.3s';

  killcam.active = true;
}

function updateKillcam(dt) {
  if (!killcam.active) return;

  var elapsed = (performance.now() - killcam.startTime) / 1000;

  // Fallback: not enough recorded data  orbit around death position
  if (killcam.frames.length < 2) {
    if (elapsed >= KILLCAM_DURATION) { endKillcam(); return; }
    // Place ghost at last known position (or camera position at death)
    var dx = killcam.savedPitch !== undefined ? camera.position.x : 0;
    var dz = killcam.savedPitch !== undefined ? camera.position.z : 0;
    if (killcam.ghostMesh) killcam.ghostMesh.position.set(dx, 0, dz);
    var oAngle = elapsed * 0.5;
    camera.position.set(dx + Math.sin(oAngle) * 5, 3, dz + Math.cos(oAngle) * 5);
    camera.lookAt(dx, 1.2, dz);
    return;
  }

  //  FREEZE-FRAME phase: hold the death moment 
  if (killcam.freezing) {
    var freezeElapsed = (performance.now() - killcam.freezeStart) / 1000;
    // Ghost slowly falls over during freeze
    if (killcam.ghostMesh && freezeElapsed < 1.5) {
      killcam.ghostMesh.rotation.z += dt * 1.2;
      killcam.ghostMesh.position.y -= dt * 0.4;
      if (killcam.ghostMesh.position.y < -0.5) killcam.ghostMesh.position.y = -0.5;
    }
    if (freezeElapsed >= KILLCAM_FREEZE_TIME) {
      endKillcam();
    }
    return;
  }

  if (elapsed >= KILLCAM_DURATION) {
    endKillcam();
    return;
  }

  //  Replay playback: 0.5x speed, extreme slow-mo for final 25% 
  var playSpeed = 0.5;
  var replayDuration = killcam.totalDuration / playSpeed;
  var rawProgress = Math.min(elapsed / replayDuration, 1);

  var progress;
  if (rawProgress <= 0.75) {
    progress = rawProgress;
  } else {
    var overrun = (rawProgress - 0.75) / 0.25;
    progress = 0.75 + overrun * 0.25 * 0.15;
    progress = Math.min(progress, 1);
  }

  var firstT = killcam.frames[0].t;
  var lastT = killcam.frames[killcam.frames.length - 1].t;
  var bufferTime = firstT + progress * (lastT - firstT);

  //  Interpolate between recorded frames 
  var frameA = killcam.frames[0];
  var frameB = killcam.frames[1];
  var lerpT = 0;

  for (var i = 0; i < killcam.frames.length - 1; i++) {
    if (killcam.frames[i + 1].t >= bufferTime) {
      frameA = killcam.frames[i];
      frameB = killcam.frames[i + 1];
      var span = frameB.t - frameA.t;
      lerpT = span > 0 ? (bufferTime - frameA.t) / span : 0;
      break;
    }
  }
  if (progress >= 1) {
    frameA = frameB = killcam.frames[killcam.frames.length - 1];
    lerpT = 0;
  }

  //  Ghost player position from recorded data 
  var gx = frameA.px + (frameB.px - frameA.px) * lerpT;
  var gy = frameA.py + (frameB.py - frameA.py) * lerpT;
  var gz = frameA.pz + (frameB.pz - frameA.pz) * lerpT;
  var gYaw = frameA.pw + (frameB.pw - frameA.pw) * lerpT;

  if (killcam.ghostMesh) {
    killcam.ghostMesh.position.set(gx, 0, gz);
    killcam.ghostMesh.rotation.y = gYaw;
  }

  //  Reposition ALL bot meshes from recorded data 
  var kx = gx, kz = gz; // fallback if no killer
  for (var b = 0; b < state.bots.length; b++) {
    if (!frameA.bots[b]) continue;
    var bA = frameA.bots[b];
    var bB = (frameB.bots[b] || bA);

    var bx = bA.x + (bB.x - bA.x) * lerpT;
    var bz = bA.z + (bB.z - bA.z) * lerpT;
    var bry = bA.ry + (bB.ry - bA.ry) * lerpT;

    state.bots[b].mesh.position.set(bx, 0, bz);
    state.bots[b].mesh.rotation.y = bry;
    state.bots[b].mesh.visible = bA.alive;

    if (b === killcam.killerIdx) {
      kx = bx;
      kz = bz;
      // Make killer face the ghost during replay
      state.bots[b].mesh.rotation.y = Math.atan2(gx - bx, gz - bz);
    }
  }

  // Pulse the killer ring
  if (killcam.killerRing) {
    killcam.killerRing.material.opacity = 0.4 + Math.sin(elapsed * 4) * 0.3;
  }

  //  CINEMATIC SIDE-CAMERA: always frames both killer + ghost 
  // Vector from killer  ghost
  var dxKG = gx - kx;
  var dzKG = gz - kz;
  var distKG = Math.sqrt(dxKG * dxKG + dzKG * dzKG);
  if (distKG < 0.1) distKG = 0.1;

  // Midpoint between killer and ghost
  var midX = (kx + gx) / 2;
  var midZ = (kz + gz) / 2;

  // Perpendicular direction (90 to the killerghost line)
  var perpX = -dzKG / distKG;
  var perpZ = dxKG / distKG;

  // Camera distance scales with how far apart they are
  var camSideDist = Math.max(distKG * 0.9, 4);
  // Slow orbit: drift the perpendicular angle slightly over time
  var orbitShift = Math.sin(elapsed * 0.3) * 0.15;

  var camX = midX + perpX * camSideDist + (dxKG / distKG) * orbitShift * camSideDist;
  var camZ = midZ + perpZ * camSideDist + (dzKG / distKG) * orbitShift * camSideDist;
  // Camera height: higher when further apart, lower when close for drama
  var camHeight = 2.0 + distKG * 0.15;
  camHeight = Math.min(camHeight, 5);

  // Zoom in during last 30% of replay for close-up on the kill
  if (progress > 0.7) {
    var zoomFactor = 1 - (progress - 0.7) / 0.3 * 0.4; // zoom to 60%
    camX = midX + (camX - midX) * zoomFactor;
    camZ = midZ + (camZ - midZ) * zoomFactor;
    camHeight *= zoomFactor;
    camHeight = Math.max(camHeight, 1.5);
  }

  camera.position.set(camX, camHeight, camZ);
  camera.lookAt(midX, 1.2, midZ);

  //  Replay shots: tracer lines + muzzle flash + impact burst 
  for (var j = 0; j < killcam.shots.length; j++) {
    var shot = killcam.shots[j];
    if (!shot.shown && Math.abs(shot.t - bufferTime) < 200) {
      shot.shown = true;

      // Bright tracer line from killer to ghost
      var tracerStart = new THREE.Vector3(kx, 1.2, kz);
      var tracerEnd = new THREE.Vector3(gx, 1.4, gz);
      var tGeo = new THREE.BufferGeometry();
      tGeo.setFromPoints([tracerStart, tracerEnd]);
      var tMat = new THREE.LineBasicMaterial({ color: 0xff6633, transparent: true, opacity: 0.9 });
      var tLine = new THREE.Line(tGeo, tMat);
      scene.add(tLine);

      // Thick tracer cylinder
      var tDir = tracerEnd.clone().sub(tracerStart);
      var tLen = tDir.length();
      var cGeo = new THREE.CylinderGeometry(0.04, 0.04, tLen, 4);
      var cMat = new THREE.MeshBasicMaterial({ color: 0xff4422, transparent: true, opacity: 0.7 });
      var cyl = new THREE.Mesh(cGeo, cMat);
      cyl.position.copy(tracerStart.clone().add(tracerEnd).multiplyScalar(0.5));
      cyl.lookAt(tracerEnd);
      cyl.rotateX(Math.PI / 2);
      scene.add(cyl);

      // Impact burst on the ghost
      var impGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var impMat = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.9 });
      var imp = new THREE.Mesh(impGeo, impMat);
      imp.position.set(gx, 1.3, gz);
      scene.add(imp);

      // Muzzle flash at killer
      var mfGeo = new THREE.SphereGeometry(0.2, 6, 6);
      var mfMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
      var mf = new THREE.Mesh(mfGeo, mfMat);
      mf.position.set(kx, 1.3, kz);
      var toGhostDir = new THREE.Vector3(gx - kx, 0, gz - kz).normalize();
      mf.position.x += toGhostDir.x * 0.5;
      mf.position.z += toGhostDir.z * 0.5;
      scene.add(mf);

      // Flash the killer bot orange briefly
      if (killcam.killerIdx >= 0 && state.bots[killcam.killerIdx]) {
        state.bots[killcam.killerIdx].mesh.children.forEach(function(c) {
          if (c.material && c.material.emissive && !c.isSprite) {
            c.material.emissive.setHex(0xff6600);
          }
        });
        (function(idx) {
          setTimeout(function() {
            if (state.bots[idx]) state.bots[idx].mesh.children.forEach(function(c) {
              if (c.material && c.material.emissive && !c.isSprite) {
                c.material.emissive.setHex(0x660000);
              }
            });
          }, 120);
        })(killcam.killerIdx);
      }

      // Flash ghost red on hit (MeshBasicMaterial  change color directly)
      if (killcam.ghostMesh) {
        killcam.ghostMesh.children.forEach(function(c) {
          if (c.material && c.material.color) {
            c.material.color.setHex(0xff3333);
          }
        });
        (function(ghost) {
          setTimeout(function() {
            if (ghost) ghost.children.forEach(function(c) {
              if (c.material && c.material.color && !c.isSprite) {
                c.material.color.setHex(0x00ffff);
              }
            });
          }, 250);
        })(killcam.ghostMesh);
      }

      // Fade out all tracer elements
      (function(tl, tg, tm, cy, cg2, cm2, im, ig, imm, mfl, mfg, mfm) {
        var st = performance.now();
        function fadeAll() {
          var t = (performance.now() - st) / 700;
          if (t >= 1) {
            scene.remove(tl); tg.dispose(); tm.dispose();
            scene.remove(cy); cg2.dispose(); cm2.dispose();
            scene.remove(im); ig.dispose(); imm.dispose();
            scene.remove(mfl); mfg.dispose(); mfm.dispose();
            return;
          }
          tm.opacity = 0.9 * (1 - t);
          cm2.opacity = 0.7 * (1 - t);
          imm.opacity = 0.9 * (1 - t);
          im.scale.setScalar(1 + t * 3);
          mfm.opacity = 0.9 * (1 - t);
          mfl.scale.setScalar(1 + t * 2);
          requestAnimationFrame(fadeAll);
        }
        fadeAll();
      })(tLine, tGeo, tMat, cyl, cGeo, cMat, imp, impGeo, impMat, mf, mfGeo, mfMat);

      // Damage audio
      AudioSys.playDamage();
    }
  }

  //  Death moment: ghost flashes, screen flash, freeze 
  if (progress >= 0.97 && !killcam.freezing) {
    killcam.freezing = true;
    killcam.freezeStart = performance.now();

    // Flash ghost bright red at death
    if (killcam.ghostMesh) {
      killcam.ghostMesh.children.forEach(function(c) {
        if (c.material && c.material.color) {
          c.material.color.setHex(0xff0000);
        }
        if (c.material) c.material.opacity = 1.0;
      });
    }

    // Screen flash white then go dark
    var canvas = document.getElementById('game-canvas');
    canvas.style.filter = 'contrast(1.4) brightness(1.3)';
    canvas.style.transition = 'filter 0.15s';
    setTimeout(function() {
      canvas.style.filter = 'saturate(0.5) contrast(1.1) brightness(0.6)';
      canvas.style.transition = 'filter 0.8s';
    }, 150);

    AudioSys.playDamage();
  }
}

function endKillcam() {
  killcam.active = false;
  killcam.freezing = false;

  // Remove ghost mesh (if ever created)
  if (killcam.ghostMesh) {
    scene.remove(killcam.ghostMesh);
    killcam.ghostMesh.traverse(function(c) {
      if (c.geometry) c.geometry.dispose();
      if (c.material) {
        if (c.material.map) c.material.map.dispose();
        c.material.dispose();
      }
    });
    killcam.ghostMesh = null;
  }

  // Remove killer highlight elements
  if (killcam.killerIdx >= 0) {
    var killerBot = state.bots[killcam.killerIdx];
    if (killerBot && killerBot.mesh) {
      if (killcam.killerRing) {
        killerBot.mesh.remove(killcam.killerRing);
        killcam.killerRing.geometry.dispose();
        killcam.killerRing.material.dispose();
        killcam.killerRing = null;
      }
      if (killcam.killerLabel) {
        killerBot.mesh.remove(killcam.killerLabel);
        killcam.killerLabel.material.map.dispose();
        killcam.killerLabel.material.dispose();
        killcam.killerLabel = null;
      }
      // Reset killer bot emissive glow
      killerBot.mesh.children.forEach(function(c) {
        if (c.material && c.material.emissive) {
          c.material.emissive.setHex(0x000000);
          c.material.emissiveIntensity = 1;
        }
      });
    }
  }

  // Clear any lingering damage indicator arrows
  var dmgContainer = document.getElementById('damage-indicators');
  while (dmgContainer.firstChild) dmgContainer.removeChild(dmgContainer.firstChild);
  document.getElementById('damage-overlay').classList.remove('hit');

  // Hide overlay, restore HUD elements
  document.getElementById('killcam-overlay').classList.remove('active');
  document.getElementById('crosshair').style.display = '';
  document.getElementById('fp-weapon').style.display = 'block';

  // Reset canvas filter
  var canvas = document.getElementById('game-canvas');
  canvas.style.filter = '';
  canvas.style.transition = '';
  camera.rotation.z = 0;

  // Reset camera orientation
  state.pitch = 0;
  state.yaw = Math.random() * Math.PI * 2;

  respawnPlayer();
}

//  PROCEDURAL AUDIO SYSTEM (Web Audio API) 
var AudioSys = {
  ctx: null,
  masterGain: null,
  initialized: false,

  init: function() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.gain.value = 0.4;
      this.masterGain.connect(this.ctx.destination);
      this.initialized = true;
    } catch(e) { console.warn('Audio not available:', e); }
  },

  resume: function() {
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
  },

  // Generate white noise buffer
  noiseBuffer: function(duration) {
    var sr = this.ctx.sampleRate;
    var len = sr * duration;
    var buf = this.ctx.createBuffer(1, len, sr);
    var data = buf.getChannelData(0);
    for (var i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
    return buf;
  },

  // Weapon fire sounds
  playGunshot: function(weaponId) {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx;
    var now = ctx.currentTime;
    var gain = ctx.createGain();
    gain.connect(this.masterGain);

    if (weaponId === 'pistol') {
      // Sharp crack
      var osc = ctx.createOscillator();
      osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(80, now + 0.08);
      var g2 = ctx.createGain();
      g2.gain.setValueAtTime(0.5, now);
      g2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.connect(g2); g2.connect(gain);
      osc.start(now); osc.stop(now + 0.12);
      // Noise burst
      var ns = ctx.createBufferSource();
      ns.buffer = this.noiseBuffer(0.06);
      var nf = ctx.createBiquadFilter(); nf.type = 'highpass'; nf.frequency.value = 2000;
      var ng = ctx.createGain(); ng.gain.setValueAtTime(0.4, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
      ns.connect(nf); nf.connect(ng); ng.connect(gain);
      ns.start(now); ns.stop(now + 0.06);
      gain.gain.setValueAtTime(0.6, now);
    } else if (weaponId === 'shotgun') {
      // Heavy blast
      var ns2 = ctx.createBufferSource();
      ns2.buffer = this.noiseBuffer(0.15);
      var nf2 = ctx.createBiquadFilter(); nf2.type = 'lowpass'; nf2.frequency.value = 3000;
      var ng2 = ctx.createGain(); ng2.gain.setValueAtTime(0.8, now); ng2.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      ns2.connect(nf2); nf2.connect(ng2); ng2.connect(gain);
      ns2.start(now); ns2.stop(now + 0.15);
      var osc2 = ctx.createOscillator();
      osc2.type = 'sawtooth'; osc2.frequency.setValueAtTime(200, now);
      osc2.frequency.exponentialRampToValueAtTime(40, now + 0.1);
      var og2 = ctx.createGain(); og2.gain.setValueAtTime(0.6, now); og2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc2.connect(og2); og2.connect(gain);
      osc2.start(now); osc2.stop(now + 0.12);
      gain.gain.setValueAtTime(0.8, now);
    } else if (weaponId === 'smg') {
      // Light rapid
      var osc3 = ctx.createOscillator();
      osc3.type = 'square'; osc3.frequency.setValueAtTime(600, now);
      osc3.frequency.exponentialRampToValueAtTime(100, now + 0.04);
      var og3 = ctx.createGain(); og3.gain.setValueAtTime(0.35, now); og3.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
      osc3.connect(og3); og3.connect(gain);
      osc3.start(now); osc3.stop(now + 0.05);
      var ns3 = ctx.createBufferSource(); ns3.buffer = this.noiseBuffer(0.04);
      var ng3 = ctx.createGain(); ng3.gain.setValueAtTime(0.3, now); ng3.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
      ns3.connect(ng3); ng3.connect(gain);
      ns3.start(now); ns3.stop(now + 0.04);
      gain.gain.setValueAtTime(0.5, now);
    } else if (weaponId === 'assault') {
      // Medium crack
      var osc4 = ctx.createOscillator();
      osc4.type = 'sawtooth'; osc4.frequency.setValueAtTime(500, now);
      osc4.frequency.exponentialRampToValueAtTime(60, now + 0.07);
      var og4 = ctx.createGain(); og4.gain.setValueAtTime(0.45, now); og4.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      osc4.connect(og4); og4.connect(gain);
      osc4.start(now); osc4.stop(now + 0.08);
      var ns4 = ctx.createBufferSource(); ns4.buffer = this.noiseBuffer(0.05);
      var nf4 = ctx.createBiquadFilter(); nf4.type = 'bandpass'; nf4.frequency.value = 2500; nf4.Q.value = 2;
      var ng4 = ctx.createGain(); ng4.gain.setValueAtTime(0.35, now); ng4.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
      ns4.connect(nf4); nf4.connect(ng4); ng4.connect(gain);
      ns4.start(now); ns4.stop(now + 0.05);
      gain.gain.setValueAtTime(0.6, now);
    } else if (weaponId === 'sniper') {
      // Heavy powerful shot
      var osc5 = ctx.createOscillator();
      osc5.type = 'sawtooth'; osc5.frequency.setValueAtTime(300, now);
      osc5.frequency.exponentialRampToValueAtTime(30, now + 0.2);
      var og5 = ctx.createGain(); og5.gain.setValueAtTime(0.6, now); og5.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      osc5.connect(og5); og5.connect(gain);
      osc5.start(now); osc5.stop(now + 0.25);
      var ns5 = ctx.createBufferSource(); ns5.buffer = this.noiseBuffer(0.12);
      var nf5 = ctx.createBiquadFilter(); nf5.type = 'lowpass'; nf5.frequency.value = 4000;
      var ng5 = ctx.createGain(); ng5.gain.setValueAtTime(0.5, now); ng5.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      ns5.connect(nf5); nf5.connect(ng5); ng5.connect(gain);
      ns5.start(now); ns5.stop(now + 0.12);
      gain.gain.setValueAtTime(0.8, now);
    } else if (weaponId === 'rocket') {
      // Whoosh + blast
      var osc6 = ctx.createOscillator();
      osc6.type = 'sawtooth'; osc6.frequency.setValueAtTime(150, now);
      osc6.frequency.linearRampToValueAtTime(800, now + 0.15);
      osc6.frequency.linearRampToValueAtTime(100, now + 0.3);
      var og6 = ctx.createGain(); og6.gain.setValueAtTime(0.5, now); og6.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      osc6.connect(og6); og6.connect(gain);
      osc6.start(now); osc6.stop(now + 0.35);
      gain.gain.setValueAtTime(0.7, now);
    }
  },

  playExplosion: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.7, now);
    // Low boom
    var osc = ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
    var g1 = ctx.createGain(); g1.gain.setValueAtTime(0.8, now); g1.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    osc.connect(g1); g1.connect(gain); osc.start(now); osc.stop(now + 0.5);
    // Noise
    var ns = ctx.createBufferSource(); ns.buffer = this.noiseBuffer(0.3);
    var nf = ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.setValueAtTime(3000, now);
    nf.frequency.exponentialRampToValueAtTime(200, now + 0.3);
    var ng = ctx.createGain(); ng.gain.setValueAtTime(0.6, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    ns.connect(nf); nf.connect(ng); ng.connect(gain); ns.start(now); ns.stop(now + 0.3);
  },

  playHit: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.3, now);
    var osc = ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now);
    osc.frequency.exponentialRampToValueAtTime(800, now + 0.06);
    var g1 = ctx.createGain(); g1.gain.setValueAtTime(0.3, now); g1.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    osc.connect(g1); g1.connect(gain); osc.start(now); osc.stop(now + 0.08);
  },

  playHeadshot: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.4, now);
    // High ping
    var osc = ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.setValueAtTime(2000, now);
    var g1 = ctx.createGain(); g1.gain.setValueAtTime(0.4, now); g1.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    osc.connect(g1); g1.connect(gain); osc.start(now); osc.stop(now + 0.15);
    // Second harmonic
    var osc2 = ctx.createOscillator();
    osc2.type = 'sine'; osc2.frequency.setValueAtTime(3000, now);
    var g2 = ctx.createGain(); g2.gain.setValueAtTime(0.2, now); g2.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    osc2.connect(g2); g2.connect(gain); osc2.start(now); osc2.stop(now + 0.1);
  },

  playKill: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.35, now);
    // Satisfying kill ding
    [800, 1000, 1200].forEach(function(freq, i) {
      var osc = ctx.createOscillator();
      osc.type = 'sine'; osc.frequency.value = freq;
      var g = ctx.createGain();
      g.gain.setValueAtTime(0, now + i * 0.05);
      g.gain.linearRampToValueAtTime(0.3, now + i * 0.05 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.05 + 0.2);
      osc.connect(g); g.connect(gain);
      osc.start(now + i * 0.05); osc.stop(now + i * 0.05 + 0.2);
    });
  },

  playDamage: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.3, now);
    var ns = ctx.createBufferSource(); ns.buffer = this.noiseBuffer(0.08);
    var nf = ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.value = 1500;
    var ng = ctx.createGain(); ng.gain.setValueAtTime(0.3, now); ng.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    ns.connect(nf); nf.connect(ng); ng.connect(gain); ns.start(now); ns.stop(now + 0.08);
  },

  playFootstep: function(sprinting) {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain);
    gain.gain.setValueAtTime(sprinting ? 0.12 : 0.07, now);
    var ns = ctx.createBufferSource(); ns.buffer = this.noiseBuffer(0.05);
    var nf = ctx.createBiquadFilter(); nf.type = 'lowpass';
    nf.frequency.value = sprinting ? 800 : 500;
    var ng = ctx.createGain(); ng.gain.setValueAtTime(0.15, now);
    ng.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
    ns.connect(nf); nf.connect(ng); ng.connect(gain); ns.start(now); ns.stop(now + 0.05);
  },

  playReload: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.3, now);
    // Clip out
    var o1 = ctx.createOscillator(); o1.type = 'square';
    o1.frequency.setValueAtTime(400, now); o1.frequency.exponentialRampToValueAtTime(200, now + 0.1);
    var g1 = ctx.createGain(); g1.gain.setValueAtTime(0.15, now); g1.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    o1.connect(g1); g1.connect(gain); o1.start(now); o1.stop(now + 0.1);
    // Clip in (delayed)
    var o2 = ctx.createOscillator(); o2.type = 'square';
    o2.frequency.setValueAtTime(600, now + 0.8); o2.frequency.exponentialRampToValueAtTime(300, now + 0.9);
    var g2 = ctx.createGain(); g2.gain.setValueAtTime(0, now);
    g2.gain.setValueAtTime(0.2, now + 0.8); g2.gain.exponentialRampToValueAtTime(0.001, now + 0.95);
    o2.connect(g2); g2.connect(gain); o2.start(now + 0.8); o2.stop(now + 0.95);
    // Bolt/chamber
    var ns = ctx.createBufferSource(); ns.buffer = this.noiseBuffer(0.06);
    var nf = ctx.createBiquadFilter(); nf.type = 'bandpass'; nf.frequency.value = 3000;
    var ng = ctx.createGain(); ng.gain.setValueAtTime(0, now);
    ng.gain.setValueAtTime(0.2, now + 1.2); ng.gain.exponentialRampToValueAtTime(0.001, now + 1.3);
    ns.connect(nf); nf.connect(ng); ng.connect(gain); ns.start(now + 1.2); ns.stop(now + 1.3);
  },

  playGrenade: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.25, now);
    // Pin pull
    var o1 = ctx.createOscillator(); o1.type = 'sine'; o1.frequency.value = 1500;
    var g1 = ctx.createGain(); g1.gain.setValueAtTime(0.2, now); g1.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
    o1.connect(g1); g1.connect(gain); o1.start(now); o1.stop(now + 0.05);
  },

  playPickup: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    var gain = ctx.createGain(); gain.connect(this.masterGain); gain.gain.setValueAtTime(0.25, now);
    var osc = ctx.createOscillator(); osc.type = 'sine';
    osc.frequency.setValueAtTime(500, now);
    osc.frequency.linearRampToValueAtTime(1000, now + 0.12);
    var g1 = ctx.createGain(); g1.gain.setValueAtTime(0.25, now); g1.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    osc.connect(g1); g1.connect(gain); osc.start(now); osc.stop(now + 0.15);
  },

  playAmbient: function() {
    if (!this.initialized) return;
    this.resume();
    var ctx = this.ctx; var now = ctx.currentTime;
    // Low drone
    var osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 55;
    var lfo = ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.1;
    var lfoGain = ctx.createGain(); lfoGain.gain.value = 5;
    lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
    var gain = ctx.createGain(); gain.connect(this.masterGain);
    gain.gain.value = 0.03;
    osc.connect(gain); osc.start(now); lfo.start(now);
    this._ambientOsc = osc; this._ambientLfo = lfo;
  }
};

//  FIRST PERSON WEAPON RENDERER 
var FPWeapon = {
  ctx: null,
  canvas: null,
  bobOffset: 0,
  kickOffset: 0,
  swayX: 0,
  swayY: 0,

  init: function() {
    this.canvas = document.getElementById('fp-weapon-canvas');
    if (this.canvas) this.ctx = this.canvas.getContext('2d');
  },

  render: function(weaponIdx, firing, reloading, ads, dt) {
    if (!this.ctx) return;
    var ctx = this.ctx;
    var w = this.canvas.width;
    var h = this.canvas.height;
    ctx.clearRect(0, 0, w, h);

    var weapon = WEAPONS[weaponIdx];
    if (!weapon) return;

    // Calculate offsets
    if (firing) this.kickOffset = Math.min(this.kickOffset + 15, 20);
    else this.kickOffset *= 0.85;

    var bobX = Math.sin(state.headBobTimer * 2) * state.headBobAmount * 8;
    var bobY = Math.cos(state.headBobTimer * 4) * state.headBobAmount * 4;

    var adsOffset = ads ? -60 : 0;

    // Weapon sway
    this.swayX += (state.weaponSwayX * 30 - this.swayX) * dt * 5;
    this.swayY += (state.weaponSwayY * 30 - this.swayY) * dt * 5;

    ctx.save();
    ctx.translate(w / 2 + bobX + this.swayX + adsOffset, h - 40 + bobY + this.kickOffset + this.swayY);

    // Skin color
    var skinIdx = state.weaponSkins[weapon.id] || 0;
    var skinColor = weapon.skins[skinIdx] ? weapon.skins[skinIdx].color : '#555';

    // Draw weapon based on type
    if (weapon.id === 'pistol') {
      this.drawPistol(ctx, skinColor);
    } else if (weapon.id === 'shotgun') {
      this.drawShotgun(ctx, skinColor);
    } else if (weapon.id === 'smg') {
      this.drawSMG(ctx, skinColor);
    } else if (weapon.id === 'assault') {
      this.drawAssault(ctx, skinColor);
    } else if (weapon.id === 'sniper') {
      this.drawSniper(ctx, skinColor);
    } else if (weapon.id === 'rocket') {
      this.drawRocket(ctx, skinColor);
    }

    // Muzzle flash
    if (firing && this.kickOffset > 5) {
      ctx.fillStyle = 'rgba(255, 200, 50, 0.8)';
      ctx.beginPath();
      ctx.ellipse(-30, -90, 8 + Math.random() * 5, 15 + Math.random() * 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 200, 0.5)';
      ctx.beginPath();
      ctx.ellipse(-30, -95, 4, 8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  },

  drawPistol: function(ctx, color) {
    ctx.fillStyle = color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    // Barrel
    ctx.fillRect(-35, -85, 12, 45);
    ctx.strokeRect(-35, -85, 12, 45);
    // Body
    ctx.fillRect(-40, -40, 22, 25);
    ctx.strokeRect(-40, -40, 22, 25);
    // Grip
    ctx.fillStyle = '#333';
    ctx.fillRect(-36, -15, 14, 30);
    ctx.strokeRect(-36, -15, 14, 30);
    // Trigger guard
    ctx.strokeStyle = '#444';
    ctx.beginPath(); ctx.arc(-22, -10, 8, 0, Math.PI); ctx.stroke();
  },

  drawShotgun: function(ctx, color) {
    ctx.fillStyle = color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    // Barrel (double)
    ctx.fillRect(-38, -110, 8, 70);
    ctx.fillRect(-26, -110, 8, 70);
    ctx.strokeRect(-38, -110, 8, 70);
    ctx.strokeRect(-26, -110, 8, 70);
    // Body
    ctx.fillStyle = '#444';
    ctx.fillRect(-42, -40, 28, 20);
    ctx.strokeRect(-42, -40, 28, 20);
    // Pump
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(-40, -55, 24, 15);
    // Grip
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(-36, -20, 16, 35);
    ctx.strokeRect(-36, -20, 16, 35);
  },

  drawSMG: function(ctx, color) {
    ctx.fillStyle = color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    // Barrel
    ctx.fillRect(-33, -95, 10, 55);
    ctx.strokeRect(-33, -95, 10, 55);
    // Body
    ctx.fillRect(-40, -40, 24, 25);
    ctx.strokeRect(-40, -40, 24, 25);
    // Magazine
    ctx.fillStyle = '#333';
    ctx.fillRect(-34, -15, 12, 25);
    ctx.strokeRect(-34, -15, 12, 25);
    // Grip
    ctx.fillRect(-38, 8, 14, 20);
    // Stock
    ctx.fillStyle = color;
    ctx.fillRect(-12, -38, 30, 8);
  },

  drawAssault: function(ctx, color) {
    ctx.fillStyle = color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    // Barrel
    ctx.fillRect(-34, -110, 10, 70);
    ctx.strokeRect(-34, -110, 10, 70);
    // Barrel tip
    ctx.fillStyle = '#222';
    ctx.fillRect(-36, -115, 14, 8);
    // Body
    ctx.fillStyle = color;
    ctx.fillRect(-42, -40, 28, 22);
    ctx.strokeRect(-42, -40, 28, 22);
    // Handguard
    ctx.fillRect(-38, -65, 18, 25);
    // Scope rail
    ctx.fillStyle = '#555';
    ctx.fillRect(-32, -45, 8, 4);
    // Magazine
    ctx.fillStyle = '#333';
    ctx.fillRect(-36, -18, 14, 28);
    ctx.strokeRect(-36, -18, 14, 28);
    // Grip
    ctx.fillStyle = '#333';
    ctx.fillRect(-38, 8, 14, 22);
    // Stock
    ctx.fillStyle = color;
    ctx.fillRect(-10, -36, 35, 10);
    ctx.fillRect(20, -36, 8, 20);
  },

  drawSniper: function(ctx, color) {
    ctx.fillStyle = color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    // Long barrel
    ctx.fillRect(-33, -130, 8, 90);
    ctx.strokeRect(-33, -130, 8, 90);
    // Suppressor
    ctx.fillStyle = '#222';
    ctx.fillRect(-35, -140, 12, 14);
    // Scope
    ctx.fillStyle = '#111';
    ctx.fillRect(-36, -65, 16, 6);
    ctx.beginPath(); ctx.arc(-36, -62, 5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(-20, -62, 5, 0, Math.PI * 2); ctx.fill();
    // Body
    ctx.fillStyle = color;
    ctx.fillRect(-40, -40, 26, 20);
    ctx.strokeRect(-40, -40, 26, 20);
    // Magazine
    ctx.fillStyle = '#444';
    ctx.fillRect(-34, -20, 12, 18);
    // Grip + Stock
    ctx.fillStyle = '#333';
    ctx.fillRect(-36, -2, 14, 25);
    ctx.fillStyle = color;
    ctx.fillRect(-8, -38, 40, 12);
    ctx.fillRect(28, -38, 8, 25);
  },

  drawRocket: function(ctx, color) {
    ctx.fillStyle = color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    // Wide tube
    ctx.fillRect(-42, -120, 26, 80);
    ctx.strokeRect(-42, -120, 26, 80);
    // Tip
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.moveTo(-29, -130); ctx.lineTo(-42, -120); ctx.lineTo(-16, -120);
    ctx.closePath(); ctx.fill();
    // Grip
    ctx.fillStyle = '#333';
    ctx.fillRect(-36, -40, 16, 30);
    ctx.fillRect(-36, -10, 16, 25);
    // Trigger
    ctx.strokeStyle = '#666';
    ctx.beginPath(); ctx.arc(-22, -20, 6, 0, Math.PI); ctx.stroke();
    // Sight
    ctx.fillStyle = '#444';
    ctx.fillRect(-20, -100, 6, 20);
  }
};

//  THREE.JS SETUP 
var renderer, scene, camera, listener;
var clock = new THREE.Clock();
var raycaster = new THREE.Raycaster();
var playerMesh; // invisible, for position
var arenaObjects = [];
var botMeshes = [];
var pickupMeshes = [];
var projectileMeshes = [];
var minimapCtx;

//  DIFFICULTY SETTINGS 
var DIFF = {
  easy:   { botAccuracy: 0.15, botFireRate: 0.5, botSpeed: 2.5, botHealth: 60,  xpMult: 0.7  },
  normal: { botAccuracy: 0.30, botFireRate: 0.8, botSpeed: 4,   botHealth: 100, xpMult: 1.0  },
  hard:   { botAccuracy: 0.50, botFireRate: 1.2, botSpeed: 5.5, botHealth: 130, xpMult: 1.5  },
  insane: { botAccuracy: 0.70, botFireRate: 1.8, botSpeed: 7,   botHealth: 160, xpMult: 2.0  }
};

//  AUTH: Check FavCreators Session 
function checkAuth() {
  var statusEl = document.getElementById('login-status');
  var statusText = document.getElementById('login-status-text');
  var btnLogin = document.getElementById('btn-login');
  var btnConfirm = document.getElementById('btn-confirm-age');

  // Try session check
  fetch(FC_SESSION_URL, { credentials: 'include' })
    .then(function(r) { return r.json(); })
    .then(function(data) {
      if (data.logged_in && data.user_id > 0) {
        state.authenticated = true;
        state.userId = data.user_id;
        statusEl.className = 'login-status logged-in';
        statusText.innerHTML = '&#10003; Logged in as User #' + data.user_id;
        btnLogin.style.display = 'none';
        btnConfirm.disabled = false;
        // Check if we already confirmed age this session
        if (sessionStorage.getItem('fps_age_confirmed') === 'true') {
          enterGame();
        }
      } else {
        showNotLoggedIn();
      }
    })
    .catch(function() {
      showNotLoggedIn();
    });

  function showNotLoggedIn() {
    statusEl.className = 'login-status not-logged-in';
    statusText.innerHTML = '&#10007; Not logged in. You must log in with a FavCreators account to play.';
    btnLogin.style.display = 'inline-block';
    btnConfirm.disabled = true;
  }
}

window.goToLogin = function() {
  window.location.href = FC_LOGIN_URL;
};

window.confirmAge = function() {
  if (!state.authenticated) return;
  sessionStorage.setItem('fps_age_confirmed', 'true');
  enterGame();
};

function enterGame() {
  document.getElementById('age-gate').classList.add('hidden');
  document.getElementById('loading-screen').classList.remove('hidden');
  loadPersistentState();
  initGame();
}

//  PERSISTENT STATE 
var STORAGE_KEY = 'fps_arena_data';

function loadPersistentState() {
  try {
    var d = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (d) {
      state.totalXP = d.totalXP || 0;
      state.totalKills = d.totalKills || 0;
      state.totalDeaths = d.totalDeaths || 0;
      state.gamesPlayed = d.gamesPlayed || 0;
      state.highScores = d.highScores || [];
      state.weaponSkins = d.weaponSkins || {};
      state.userName = d.userName || 'Player';
      state.difficulty = d.difficulty || 'normal';
    }
  } catch(e) {}
  // Set initial weapon skins
  WEAPONS.forEach(function(w) {
    if (!state.weaponSkins[w.id]) state.weaponSkins[w.id] = 0;
  });
}

function savePersistentState() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      totalXP: state.totalXP,
      totalKills: state.totalKills,
      totalDeaths: state.totalDeaths,
      gamesPlayed: state.gamesPlayed,
      highScores: state.highScores,
      weaponSkins: state.weaponSkins,
      userName: state.userName,
      difficulty: state.difficulty
    }));
  } catch(e) {}
}

function getRank(xp) {
  var rank = RANKS[0];
  for (var i = RANKS.length - 1; i >= 0; i--) {
    if (xp >= RANKS[i].xp) { rank = RANKS[i]; break; }
  }
  return rank;
}

function getNextRank(xp) {
  for (var i = 0; i < RANKS.length; i++) {
    if (xp < RANKS[i].xp) return RANKS[i];
  }
  return null;
}

//  GAME INIT 
function initGame() {
  var loadFill = document.getElementById('load-fill');
  var progress = 0;

  function setProgress(p) {
    progress = p;
    loadFill.style.width = p + '%';
  }

  // Create renderer
  var canvas = document.getElementById('game-canvas');
  renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.setClearColor(0x0a0a1a);
  setProgress(10);

  // Scene
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0a1a, 0.012);
  setProgress(20);

  // Camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0, PLAYER_HEIGHT, 0);
  setProgress(30);

  // Lights
  var ambientLight = new THREE.AmbientLight(0x404060, 0.4);
  scene.add(ambientLight);

  var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(20, 40, 20);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 1024;
  dirLight.shadow.mapSize.height = 1024;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 100;
  dirLight.shadow.camera.left = -50;
  dirLight.shadow.camera.right = 50;
  dirLight.shadow.camera.top = 50;
  dirLight.shadow.camera.bottom = -50;
  scene.add(dirLight);

  // Point lights around arena
  var colors = [0xef4444, 0x3b82f6, 0xa855f7, 0x22c55e, 0xf59e0b, 0xec4899];
  for (var i = 0; i < 6; i++) {
    var pl = new THREE.PointLight(colors[i], 0.6, 30);
    var angle = (i / 6) * Math.PI * 2;
    pl.position.set(Math.cos(angle) * 25, 5, Math.sin(angle) * 25);
    scene.add(pl);
  }
  setProgress(40);

  // Build arena
  buildArena();
  setProgress(60);

  // Minimap
  var minimapCanvas = document.getElementById('minimap-canvas');
  minimapCtx = minimapCanvas.getContext('2d');
  setProgress(70);

  // Init weapons ammo
  WEAPONS.forEach(function(w) {
    state.ammoClip.push(w.clipSize);
    state.ammoReserve.push(w.reserve);
  });
  setProgress(80);

  // Spawn bots
  spawnBots();
  setProgress(90);

  // Spawn pickups
  spawnPickups();

  // Create hazard zones
  createHazardZones();

  // Setup input
  setupInput();

  setProgress(100);

  // Initialize weapon viewmodel
  FPWeapon.init();

  // Start after a short delay
  setTimeout(function() {
    document.getElementById('loading-screen').classList.add('hidden');
    document.getElementById('hud').style.display = 'block';
    document.getElementById('back-btn').style.display = 'block';
    document.getElementById('fp-weapon').style.display = 'block';
    state.gameStarted = true;
    state.matchActive = true;
    state.matchTime = MATCH_DURATION;
    state.grenades = 3;
    replayBuffer = [];
    replayShots = [];
    replayRecordAccum = 0;
    document.getElementById('hud-grenades').textContent = state.grenades;
    updateHUD();

    // Prompt for name if first time
    if (state.userName === 'Player' && state.gamesPlayed === 0) {
      var n = prompt('Enter your callsign:', 'Player');
      if (n && n.trim()) state.userName = n.trim().substring(0, 20);
      savePersistentState();
    }

    // Lock pointer
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.addEventListener('click', function() {
      if (!state.paused && state.matchActive) canvas.requestPointerLock();
      // Init audio on first click
      AudioSys.init();
      AudioSys.playAmbient();
    });

    // Load settings
    loadSettings();

    showStreakBanner('MATCH START', '#ef4444', 'Eliminate all enemies!');
    showControlsHelp();
    gameLoop();
  }, 800);
}

//  ARENA BUILDER 
function buildArena() {
  // Floor
  var floorGeo = new THREE.PlaneGeometry(ARENA_SIZE, ARENA_SIZE);
  var floorMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a2e, roughness: 0.9, metalness: 0.1
  });
  var floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Grid lines on floor
  var gridHelper = new THREE.GridHelper(ARENA_SIZE, 40, 0x222244, 0x1a1a30);
  gridHelper.position.y = 0.01;
  scene.add(gridHelper);

  // Walls
  var wallMat = new THREE.MeshStandardMaterial({ color: 0x252540, roughness: 0.7, metalness: 0.3 });
  var wallHeight = 6;
  var halfSize = ARENA_SIZE / 2;

  // 4 boundary walls
  var wallPositions = [
    { pos: [0, wallHeight / 2, -halfSize], rot: [0, 0, 0], w: ARENA_SIZE, h: wallHeight },
    { pos: [0, wallHeight / 2, halfSize],  rot: [0, Math.PI, 0], w: ARENA_SIZE, h: wallHeight },
    { pos: [-halfSize, wallHeight / 2, 0], rot: [0, Math.PI / 2, 0], w: ARENA_SIZE, h: wallHeight },
    { pos: [halfSize, wallHeight / 2, 0],  rot: [0, -Math.PI / 2, 0], w: ARENA_SIZE, h: wallHeight }
  ];

  wallPositions.forEach(function(wp) {
    var wg = new THREE.BoxGeometry(wp.w, wp.h, 0.5);
    var wall = new THREE.Mesh(wg, wallMat);
    wall.position.set(wp.pos[0], wp.pos[1], wp.pos[2]);
    wall.rotation.set(wp.rot[0], wp.rot[1], wp.rot[2]);
    wall.castShadow = true;
    wall.receiveShadow = true;
    scene.add(wall);
    arenaObjects.push(wall);
  });

  // Interior structures - boxes, walls, ramps for cover
  var structures = [
    // Central tower
    { pos: [0, 2, 0], size: [4, 4, 4], color: 0x2d2d50 },
    { pos: [0, 5, 0], size: [6, 1, 6], color: 0x3a3a5e }, // platform on top

    // Corner bunkers
    { pos: [-20, 1.5, -20], size: [6, 3, 6], color: 0x352525 },
    { pos: [20, 1.5, -20],  size: [6, 3, 6], color: 0x253525 },
    { pos: [-20, 1.5, 20],  size: [6, 3, 6], color: 0x252535 },
    { pos: [20, 1.5, 20],   size: [6, 3, 6], color: 0x352535 },

    // Cover walls
    { pos: [-10, 1.5, 0], size: [1, 3, 8], color: 0x3d3d5a },
    { pos: [10, 1.5, 0],  size: [1, 3, 8], color: 0x3d3d5a },
    { pos: [0, 1.5, -10], size: [8, 3, 1], color: 0x3d3d5a },
    { pos: [0, 1.5, 10],  size: [8, 3, 1], color: 0x3d3d5a },

    // Crates scattered
    { pos: [-15, 0.75, -10], size: [1.5, 1.5, 1.5], color: 0x5a4a3a },
    { pos: [15, 0.75, 10],   size: [1.5, 1.5, 1.5], color: 0x5a4a3a },
    { pos: [-8, 0.75, 15],   size: [1.5, 1.5, 1.5], color: 0x5a4a3a },
    { pos: [8, 0.75, -15],   size: [1.5, 1.5, 1.5], color: 0x5a4a3a },
    { pos: [25, 0.75, 5],    size: [1.5, 1.5, 1.5], color: 0x5a4a3a },
    { pos: [-25, 0.75, -5],  size: [1.5, 1.5, 1.5], color: 0x5a4a3a },

    // Long walls for lanes
    { pos: [-15, 2, -25], size: [1, 4, 12], color: 0x2d2d50 },
    { pos: [15, 2, 25],   size: [1, 4, 12], color: 0x2d2d50 },
    { pos: [-30, 2, 10],  size: [12, 4, 1], color: 0x2d2d50 },
    { pos: [30, 2, -10],  size: [12, 4, 1], color: 0x2d2d50 },

    // Elevated platforms
    { pos: [-25, 3, -30], size: [8, 0.5, 8], color: 0x404060 },
    { pos: [25, 3, 30],   size: [8, 0.5, 8], color: 0x404060 },
    // Ramps to platforms
    { pos: [-25, 1.5, -25], size: [3, 0.3, 6], color: 0x404060 },
    { pos: [25, 1.5, 25],   size: [3, 0.3, 6], color: 0x404060 }
  ];

  structures.forEach(function(s) {
    var geo = new THREE.BoxGeometry(s.size[0], s.size[1], s.size[2]);
    var mat = new THREE.MeshStandardMaterial({ color: s.color, roughness: 0.8, metalness: 0.2 });
    var mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(s.pos[0], s.pos[1], s.pos[2]);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    arenaObjects.push(mesh);
  });

  // Skybox effect: distant colored panels
  var skyMat = new THREE.MeshBasicMaterial({ color: 0x0f0f20, side: THREE.BackSide });
  var sky = new THREE.Mesh(new THREE.BoxGeometry(180, 60, 180), skyMat);
  sky.position.y = 25;
  scene.add(sky);

  // Neon strip lights on structures
  var neonColors = [0xef4444, 0x3b82f6, 0xa855f7, 0x22c55e];
  structures.slice(0, 5).forEach(function(s, i) {
    var neonGeo = new THREE.BoxGeometry(s.size[0] + 0.2, 0.1, s.size[2] + 0.2);
    var neonMat = new THREE.MeshBasicMaterial({ color: neonColors[i % neonColors.length] });
    var neon = new THREE.Mesh(neonGeo, neonMat);
    neon.position.set(s.pos[0], s.pos[1] + s.size[1] / 2 + 0.05, s.pos[2]);
    scene.add(neon);
  });

  // Additional cover objects for tactical gameplay
  var extraCovers = [
    // Low walls for crouch cover
    { pos: [-5, 0.5, -18], size: [4, 1, 0.5], color: 0x3a3a5e },
    { pos: [5, 0.5, 18], size: [4, 1, 0.5], color: 0x3a3a5e },
    { pos: [18, 0.5, -5], size: [0.5, 1, 4], color: 0x3a3a5e },
    { pos: [-18, 0.5, 5], size: [0.5, 1, 4], color: 0x3a3a5e },
    // Pillars
    { pos: [-12, 2, -12], size: [1.5, 4, 1.5], color: 0x404060 },
    { pos: [12, 2, 12], size: [1.5, 4, 1.5], color: 0x404060 },
    { pos: [12, 2, -12], size: [1.5, 4, 1.5], color: 0x404060 },
    { pos: [-12, 2, 12], size: [1.5, 4, 1.5], color: 0x404060 },
    // Barrier walls in corridors
    { pos: [-28, 1, 0], size: [0.5, 2, 4], color: 0x2d2d50 },
    { pos: [28, 1, 0], size: [0.5, 2, 4], color: 0x2d2d50 },
    { pos: [0, 1, -28], size: [4, 2, 0.5], color: 0x2d2d50 },
    { pos: [0, 1, 28], size: [4, 2, 0.5], color: 0x2d2d50 },
    // Shipping containers
    { pos: [-30, 1.5, -15], size: [3, 3, 7], color: 0x8b3a3a },
    { pos: [30, 1.5, 15], size: [3, 3, 7], color: 0x3a3a8b },
    // Bridge between elevated platforms
    { pos: [0, 3, 0], size: [2, 0.3, 12], color: 0x505070 }
  ];

  extraCovers.forEach(function(s) {
    var geo = new THREE.BoxGeometry(s.size[0], s.size[1], s.size[2]);
    var mat = new THREE.MeshStandardMaterial({ color: s.color, roughness: 0.8, metalness: 0.2 });
    var mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(s.pos[0], s.pos[1], s.pos[2]);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    arenaObjects.push(mesh);
  });

  // Floating dust particles
  var dustGeo = new THREE.BufferGeometry();
  var dustPositions = [];
  for (var d = 0; d < 300; d++) {
    dustPositions.push(
      (Math.random() - 0.5) * ARENA_SIZE,
      Math.random() * 8,
      (Math.random() - 0.5) * ARENA_SIZE
    );
  }
  dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPositions, 3));
  var dustMat = new THREE.PointsMaterial({ color: 0x888888, size: 0.05, transparent: true, opacity: 0.3 });
  var dustParticles = new THREE.Points(dustGeo, dustMat);
  scene.add(dustParticles);

  // Animated neon signs on walls
  var signPositions = [
    { pos: [0, 4, -ARENA_SIZE/2 + 0.3], rot: [0, 0, 0], text: 'FPS ARENA', color: 0xef4444 },
    { pos: [0, 4, ARENA_SIZE/2 - 0.3], rot: [0, Math.PI, 0], text: 'FIGHT', color: 0x3b82f6 },
    { pos: [-ARENA_SIZE/2 + 0.3, 4, 0], rot: [0, Math.PI/2, 0], text: 'NO MERCY', color: 0xa855f7 },
    { pos: [ARENA_SIZE/2 - 0.3, 4, 0], rot: [0, -Math.PI/2, 0], text: 'DANGER', color: 0xf59e0b }
  ];
  signPositions.forEach(function(sp) {
    var light = new THREE.PointLight(sp.color, 0.4, 10);
    light.position.set(sp.pos[0], sp.pos[1], sp.pos[2]);
    scene.add(light);
  });
}

//  BOT SYSTEM 
function spawnBots() {
  state.bots = [];
  botMeshes.forEach(function(m) { scene.remove(m); });
  botMeshes = [];

  for (var i = 0; i < BOT_COUNT; i++) {
    var bot = createBot(i);
    state.bots.push(bot);
  }
}

function createBot(index) {
  var diff = DIFF[state.difficulty];
  var pos = getRandomSpawn();

  // Bot mesh: simple humanoid shape
  var group = new THREE.Group();

  // Body
  var bodyGeo = new THREE.BoxGeometry(0.6, 1.0, 0.4);
  var botColor = new THREE.Color().setHSL((index * 0.13) % 1, 0.7, 0.5);
  var bodyMat = new THREE.MeshStandardMaterial({ color: botColor, roughness: 0.6, transparent: true });
  var body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.2;
  body.castShadow = true;
  group.add(body);

  // Head
  var headGeo = new THREE.SphereGeometry(0.2, 8, 8);
  var headMat = new THREE.MeshStandardMaterial({ color: 0xddccbb, roughness: 0.5 });
  var head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.9;
  head.castShadow = true;
  group.add(head);

  // Eyes (glowing)
  var eyeGeo = new THREE.SphereGeometry(0.04, 4, 4);
  var eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.07, 1.92, 0.15);
  group.add(leftEye);
  var rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.07, 1.92, 0.15);
  group.add(rightEye);

  // Weapon (simple barrel)
  var gunGeo = new THREE.BoxGeometry(0.08, 0.08, 0.5);
  var gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
  var gun = new THREE.Mesh(gunGeo, gunMat);
  gun.position.set(0.3, 1.1, 0.3);
  group.add(gun);

  // Legs (to make bot look more humanoid)
  var legGeo = new THREE.BoxGeometry(0.15, 0.7, 0.15);
  var legMat = new THREE.MeshStandardMaterial({ color: 0x333340, roughness: 0.7 });
  var leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-0.15, 0.35, 0);
  leftLeg.castShadow = true;
  group.add(leftLeg);
  var rightLeg = new THREE.Mesh(legGeo, legMat);
  rightLeg.position.set(0.15, 0.35, 0);
  rightLeg.castShadow = true;
  group.add(rightLeg);

  // Arms
  var armGeo = new THREE.BoxGeometry(0.12, 0.6, 0.12);
  var armMat = new THREE.MeshStandardMaterial({ color: botColor.clone().multiplyScalar(0.8), roughness: 0.6 });
  var leftArm = new THREE.Mesh(armGeo, armMat);
  leftArm.position.set(-0.42, 1.1, 0);
  group.add(leftArm);
  var rightArm = new THREE.Mesh(armGeo, armMat);
  rightArm.position.set(0.42, 1.1, 0.15);
  group.add(rightArm);

  // Name tag above bot (billboard sprite)
  var botName = BOT_NAMES[index % BOT_NAMES.length];
  var nameCanvas = document.createElement('canvas');
  nameCanvas.width = 256; nameCanvas.height = 48;
  var nCtx = nameCanvas.getContext('2d');
  nCtx.fillStyle = 'rgba(0,0,0,0.5)';
  nCtx.roundRect ? nCtx.roundRect(0, 0, 256, 48, 8) : nCtx.fillRect(0, 0, 256, 48);
  nCtx.fill();
  nCtx.font = 'bold 20px Inter, sans-serif';
  nCtx.textAlign = 'center';
  nCtx.fillStyle = '#ef4444';
  nCtx.fillText(botName, 128, 20);
  nCtx.font = '14px Inter, sans-serif';
  nCtx.fillStyle = '#666';
  nCtx.fillText('BOT', 128, 40);
  var nameTex = new THREE.CanvasTexture(nameCanvas);
  var nameSpriteMat = new THREE.SpriteMaterial({ map: nameTex, transparent: true, depthWrite: false });
  var nameSprite = new THREE.Sprite(nameSpriteMat);
  nameSprite.position.set(0, 2.6, 0);
  nameSprite.scale.set(2, 0.4, 1);
  group.add(nameSprite);

  group.position.set(pos.x, 0, pos.z);
  scene.add(group);
  botMeshes.push(group);

  return {
    index: index,
    name: BOT_NAMES[index % BOT_NAMES.length],
    mesh: group,
    health: diff.botHealth,
    maxHealth: diff.botHealth,
    alive: true,
    position: new THREE.Vector3(pos.x, 0, pos.z),
    velocity: new THREE.Vector3(),
    target: null,
    fireTimer: 0,
    respawnTimer: 0,
    moveDir: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
    changeDirTimer: 2 + Math.random() * 3,
    kills: 0,
    deaths: 0,
    xp: Math.floor(Math.random() * 3000)
  };
}

function getRandomSpawn() {
  var half = ARENA_SIZE / 2 - 5;
  return {
    x: (Math.random() - 0.5) * 2 * half,
    z: (Math.random() - 0.5) * 2 * half
  };
}

//  PICKUPS 
function spawnPickups() {
  state.pickups = [];
  pickupMeshes.forEach(function(m) { scene.remove(m); });
  pickupMeshes = [];

  var pickupTypes = [
    { type: 'health', color: 0x22c55e, size: 0.4, y: 0.5 },
    { type: 'armor',  color: 0x3b82f6, size: 0.4, y: 0.5 },
    { type: 'ammo',   color: 0xf59e0b, size: 0.35, y: 0.4 }
  ];

  var positions = [
    [0, 7], [0, -7], [7, 0], [-7, 0],
    [15, 15], [-15, -15], [15, -15], [-15, 15],
    [25, 0], [-25, 0], [0, 25], [0, -25],
    [30, 20], [-30, -20], [20, -30], [-20, 30]
  ];

  positions.forEach(function(p, i) {
    var pType = pickupTypes[i % pickupTypes.length];
    var geo = pType.type === 'health' ? new THREE.OctahedronGeometry(pType.size) :
              pType.type === 'armor' ? new THREE.BoxGeometry(pType.size, pType.size, pType.size) :
              new THREE.TetrahedronGeometry(pType.size);
    var mat = new THREE.MeshBasicMaterial({ color: pType.color, transparent: true, opacity: 0.8 });
    var mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(p[0], pType.y + 0.3, p[1]);
    scene.add(mesh);
    pickupMeshes.push(mesh);

    state.pickups.push({
      type: pType.type,
      position: new THREE.Vector3(p[0], pType.y + 0.3, p[1]),
      mesh: mesh,
      active: true,
      respawnTimer: 0
    });
  });
}

//  INPUT 
function setupInput() {
  document.addEventListener('keydown', function(e) {
    state.keys[e.code] = true;

    // Skip killcam on any key press (after 1s to prevent accidental skip)
    if (killcam.active && (performance.now() - killcam.startTime) > 1000) {
      endKillcam();
      return;
    }

    // Weapon switch by number
    if (e.key >= '1' && e.key <= '6') {
      var idx = parseInt(e.key) - 1;
      if (idx < WEAPONS.length) switchWeapon(idx);
    }

    // Reload
    if (e.code === 'KeyR' && !state.reloading) reloadWeapon();

    // Sprint
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') state.sprinting = true;

    // Crouch
    if (e.code === 'ControlLeft' || e.code === 'KeyC') state.crouching = true;

    // Grenade
    if (e.code === 'KeyG' && state.grenades > 0 && state.grenadeTimer <= 0) throwGrenade();

    // Pause
    if (e.code === 'Escape') {
      e.preventDefault();
      if (state.matchActive) togglePause();
    }

    // Weapon wheel
    if (e.code === 'KeyQ') showWeaponWheel();

    // Tab scoreboard
    if (e.code === 'Tab') {
      e.preventDefault();
      showTabScoreboard();
    }

    // Weapon inspect
    if (e.code === 'KeyF' && !state.reloading) startWeaponInspect();

    // Slide: Sprint + Crouch
    if ((e.code === 'ControlLeft' || e.code === 'KeyC') && state.sprinting && state.onGround && !state.sliding) {
      startSlide();
    }
  });

  document.addEventListener('keyup', function(e) {
    state.keys[e.code] = false;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') state.sprinting = false;
    if (e.code === 'ControlLeft' || e.code === 'KeyC') state.crouching = false;
    if (e.code === 'KeyQ') hideWeaponWheel();
    if (e.code === 'Tab') hideTabScoreboard();
  });

  document.addEventListener('mousemove', function(e) {
    if (!state.gameStarted || state.paused || !document.pointerLockElement) return;
    // ADS reduces sensitivity
    var sens = state.mouseSensitivity * (state.ads ? 0.5 : 1);
    state.yaw -= e.movementX * sens;
    state.pitch -= e.movementY * sens;
    state.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, state.pitch));
    // Weapon sway from mouse
    state.weaponSwayX = -e.movementX * 0.005;
    state.weaponSwayY = -e.movementY * 0.005;
  });

  document.addEventListener('mousedown', function(e) {
    // Skip killcam on click (after 1s)
    if (killcam.active && (performance.now() - killcam.startTime) > 1000) {
      endKillcam();
      return;
    }
    if (e.button === 0) state.mouseDown = true;
    // Right-click for ADS
    if (e.button === 2) {
      e.preventDefault();
      state.ads = true;
    }
    // Init audio on first interaction
    AudioSys.init();
  });
  document.addEventListener('mouseup', function(e) {
    if (e.button === 0) state.mouseDown = false;
    if (e.button === 2) state.ads = false;
  });
  // Prevent context menu for right-click ADS
  document.addEventListener('contextmenu', function(e) {
    if (state.gameStarted && document.pointerLockElement) e.preventDefault();
  });

  // Scroll to switch weapons
  document.addEventListener('wheel', function(e) {
    if (!state.gameStarted || state.paused) return;
    var dir = e.deltaY > 0 ? 1 : -1;
    var next = (state.currentWeapon + dir + WEAPONS.length) % WEAPONS.length;
    switchWeapon(next);
  });

  window.addEventListener('resize', function() {
    if (!renderer || !camera) return;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

//  TAB SCOREBOARD 
function showTabScoreboard() {
  var sb = document.getElementById('tab-scoreboard');
  sb.classList.add('active');
  var tbody = document.getElementById('sb-tbody');
  var entries = [{ name: state.userName, kills: state.kills, deaths: state.deaths, streak: state.streak, isMe: true, isBot: false }];
  state.bots.forEach(function(b) {
    entries.push({ name: b.name, kills: b.kills, deaths: b.deaths, streak: 0, isMe: false, isBot: true });
  });
  entries.sort(function(a, b) { return b.kills - a.kills; });
  tbody.innerHTML = entries.map(function(e, i) {
    var kd = e.deaths > 0 ? (e.kills / e.deaths).toFixed(1) : e.kills.toString();
    var cls = e.isMe ? ' class="is-me"' : (e.isBot ? ' class="is-bot"' : '');
    return '<tr' + cls + '><td>' + (i + 1) + '</td><td>' + escHTML(e.name) + (e.isMe ? ' (You)' : '') + '</td><td>' + e.kills + '</td><td>' + e.deaths + '</td><td>' + kd + '</td><td>' + e.streak + '</td></tr>';
  }).join('');
}

function hideTabScoreboard() {
  document.getElementById('tab-scoreboard').classList.remove('active');
}

//  GRENADE SYSTEM 
function throwGrenade() {
  if (state.grenades <= 0 || state.grenadeTimer > 0) return;
  state.grenades--;
  state.grenadeTimer = 1.0;
  document.getElementById('hud-grenades').textContent = state.grenades;
  AudioSys.playGrenade();

  var dir = new THREE.Vector3(0, 0.3, -1);
  dir.applyEuler(new THREE.Euler(state.pitch * 0.5, state.yaw, 0, 'YXZ'));
  dir.normalize();
  var startPos = camera.position.clone();

  var geo = new THREE.SphereGeometry(0.15, 8, 8);
  var mat = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.5 });
  var grenadeMesh = new THREE.Mesh(geo, mat);
  grenadeMesh.position.copy(startPos);
  scene.add(grenadeMesh);

  var velocity = dir.clone().multiplyScalar(20);
  velocity.y += 5;
  var grenadeTimer = 0;
  var grenadeInterval = setInterval(function() {
    grenadeTimer += 0.016;
    velocity.y -= 25 * 0.016;
    grenadeMesh.position.add(velocity.clone().multiplyScalar(0.016));
    if (grenadeMesh.position.y < 0.15) {
      grenadeMesh.position.y = 0.15;
      velocity.y *= -0.3;
      velocity.x *= 0.7;
      velocity.z *= 0.7;
    }
    // Clamp to arena
    var half = ARENA_SIZE / 2 - 1;
    grenadeMesh.position.x = Math.max(-half, Math.min(half, grenadeMesh.position.x));
    grenadeMesh.position.z = Math.max(-half, Math.min(half, grenadeMesh.position.z));

    if (grenadeTimer >= 2.0) {
      clearInterval(grenadeInterval);
      var ePos = grenadeMesh.position.clone();
      scene.remove(grenadeMesh);
      // Explosion
      createExplosion(ePos);
      AudioSys.playExplosion();
      addScreenShake(0.4);
      // Damage bots
      state.bots.forEach(function(bot) {
        if (!bot.alive) return;
        var d = bot.position.distanceTo(ePos);
        if (d < 8) {
          var dmg = Math.round(120 * (1 - d / 8));
          damageBot(bot, dmg);
        }
      });
      // Self damage
      var selfDist = camera.position.distanceTo(ePos);
      if (selfDist < 8) {
        var selfDmg = Math.round(60 * (1 - selfDist / 8));
        damagePlayer(selfDmg, 'Grenade');
      }
    }
  }, 16);
}

//  SCREEN SHAKE 
function addScreenShake(amount) {
  state.screenShake = Math.min(state.screenShake + amount, 1);
}

//  SETTINGS SYSTEM 
var gameSettings = {
  sensitivity: 10,
  adsSens: 5,
  volume: 40,
  crosshairColor: 'rgba(255,255,255,0.7)',
  crosshairSize: 10,
  fov: 75,
  headbob: true
};

function loadSettings() {
  try {
    var s = JSON.parse(localStorage.getItem('fps_settings'));
    if (s) Object.assign(gameSettings, s);
  } catch(e) {}
  applySettings();
}

function saveSettings() {
  try { localStorage.setItem('fps_settings', JSON.stringify(gameSettings)); } catch(e) {}
}

function applySettings() {
  state.mouseSensitivity = gameSettings.sensitivity * 0.0002;
  state.baseFov = gameSettings.fov;
  state.targetFov = gameSettings.fov;
  if (AudioSys.masterGain) AudioSys.masterGain.gain.value = gameSettings.volume / 100;
}

window.updateSetting = function(key, value) {
  switch(key) {
    case 'sensitivity':
      gameSettings.sensitivity = parseInt(value);
      document.getElementById('set-sensitivity-val').textContent = value;
      state.mouseSensitivity = gameSettings.sensitivity * 0.0002;
      break;
    case 'adsSens':
      gameSettings.adsSens = parseInt(value);
      document.getElementById('set-ads-sens-val').textContent = (value / 10).toFixed(1);
      break;
    case 'volume':
      gameSettings.volume = parseInt(value);
      document.getElementById('set-volume-val').textContent = value + '%';
      if (AudioSys.masterGain) AudioSys.masterGain.gain.value = value / 100;
      break;
    case 'crosshairColor':
      gameSettings.crosshairColor = value;
      var preview = document.getElementById('crosshair-preview');
      preview.querySelectorAll('.cp-dot, .cp-line').forEach(function(el) { el.style.background = value; });
      break;
    case 'crosshairSize':
      gameSettings.crosshairSize = parseInt(value);
      document.getElementById('set-crosshair-size-val').textContent = value;
      break;
    case 'fov':
      gameSettings.fov = parseInt(value);
      document.getElementById('set-fov-val').textContent = value;
      state.baseFov = gameSettings.fov;
      break;
    case 'headbob':
      gameSettings.headbob = value === '1';
      break;
  }
  saveSettings();
};

window.showSettings = function() {
  document.getElementById('settings-panel').classList.add('active');
  // Populate current values
  document.getElementById('set-sensitivity').value = gameSettings.sensitivity;
  document.getElementById('set-sensitivity-val').textContent = gameSettings.sensitivity;
  document.getElementById('set-volume').value = gameSettings.volume;
  document.getElementById('set-volume-val').textContent = gameSettings.volume + '%';
  document.getElementById('set-fov').value = gameSettings.fov;
  document.getElementById('set-fov-val').textContent = gameSettings.fov;
};

window.closeSettings = function() {
  document.getElementById('settings-panel').classList.remove('active');
  saveSettings();
};

//  WEAPON INSPECT 
var inspecting = false;

function startWeaponInspect() {
  if (inspecting || state.reloading) return;
  inspecting = true;
  var w = WEAPONS[state.currentWeapon];
  var skinIdx = state.weaponSkins[w.id] || 0;
  var skinName = w.skins[skinIdx] ? w.skins[skinIdx].name : 'Default';

  document.getElementById('inspect-name').textContent = w.name;
  document.getElementById('inspect-type').textContent = w.type + ' | DMG: ' + w.damage + ' | Range: ' + w.range;
  document.getElementById('inspect-skin').textContent = 'Skin: ' + skinName;
  document.getElementById('weapon-inspect').classList.add('active');

  // Animate the FP weapon (spin it)
  var fpEl = document.getElementById('fp-weapon');
  fpEl.style.transition = 'transform 2s ease-in-out';
  fpEl.style.transform = 'rotateY(360deg) translateY(-20px)';

  setTimeout(function() {
    fpEl.style.transition = 'transform 0.5s ease';
    fpEl.style.transform = '';
    document.getElementById('weapon-inspect').classList.remove('active');
    inspecting = false;
  }, 2000);
}

//  SLIDE MECHANIC 
state.sliding = false;
state.slideTimer = 0;
state.slideDir = new THREE.Vector3();

function startSlide() {
  if (state.sliding || !state.onGround) return;
  state.sliding = true;
  state.slideTimer = 0.6; // 0.6 second slide
  state.crouching = true;
  // Slide direction = current facing direction
  state.slideDir = new THREE.Vector3(0, 0, -1);
  state.slideDir.applyEuler(new THREE.Euler(0, state.yaw, 0));
  state.slideDir.normalize();
  document.getElementById('slide-indicator').style.display = 'block';
}

//  CONTROLS HELP 
function showControlsHelp() {
  var el = document.getElementById('controls-help');
  el.style.display = 'flex';
  el.style.opacity = '1';
  setTimeout(function() {
    el.style.opacity = '0';
    setTimeout(function() { el.style.display = 'none'; }, 1000);
  }, 8000);
}

//  WEAPON SYSTEM 
function switchWeapon(idx) {
  if (state.reloading) return;
  if (idx === state.currentWeapon) return;
  state.currentWeapon = idx;
  state.reloading = false;
  // Play a subtle switch sound
  if (AudioSys.initialized) {
    AudioSys.resume();
    var ctx = AudioSys.ctx; var now = ctx.currentTime;
    var osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 300;
    var g = ctx.createGain(); g.gain.setValueAtTime(0.1, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
    g.connect(AudioSys.masterGain); osc.connect(g); osc.start(now); osc.stop(now + 0.05);
  }
  updateWeaponHUD();
}

function reloadWeapon() {
  var w = WEAPONS[state.currentWeapon];
  var clip = state.ammoClip[state.currentWeapon];
  var reserve = state.ammoReserve[state.currentWeapon];
  if (clip >= w.clipSize || reserve <= 0) return;

  state.reloading = true;
  state.reloadTimer = 1.5; // reload time
  AudioSys.playReload();
  var fpEl = document.getElementById('fp-weapon');
  fpEl.classList.remove('reloading');
  void fpEl.offsetWidth;
  fpEl.classList.add('reloading');
  showToast('Reloading...');
}

function fireWeapon() {
  var w = WEAPONS[state.currentWeapon];
  if (state.ammoClip[state.currentWeapon] <= 0) {
    // Click - empty
    if (state.ammoReserve[state.currentWeapon] > 0) reloadWeapon();
    return;
  }

  state.ammoClip[state.currentWeapon]--;

  // Muzzle flash
  state.muzzleFlashTimer = 0.05;
  var flashEl = document.getElementById('muzzle-flash-overlay');
  flashEl.classList.add('active');
  setTimeout(function() { flashEl.classList.remove('active'); }, 30);

  // Audio
  AudioSys.playGunshot(w.id);

  // Recoil with recovery target
  var recoilAmount = w.recoil * 0.001 * (state.ads ? 0.5 : 1);
  state.viewPunchX += recoilAmount * (0.5 + Math.random() * 0.5);
  state.viewPunchY += (Math.random() - 0.5) * recoilAmount * 0.5;

  // Screen shake for heavy weapons
  if (w.id === 'shotgun' || w.id === 'sniper' || w.id === 'rocket') {
    addScreenShake(0.15);
  }

  // Increase crosshair spread
  state.crosshairSpread = Math.min(state.crosshairSpread + w.recoil * 0.5, 30);

  // Weapon kick animation
  var fpEl = document.getElementById('fp-weapon');
  fpEl.classList.remove('firing');
  void fpEl.offsetWidth; // reflow
  fpEl.classList.add('firing');

  // Raycast for hit detection
  var direction = new THREE.Vector3(0, 0, -1);
  direction.applyEuler(new THREE.Euler(state.pitch, state.yaw, 0, 'YXZ'));
  // Add spread (reduced when ADS)
  var spreadMult = state.ads ? 0.3 : 1;
  // Moving increases spread
  if (state.sprinting) spreadMult *= 2;
  else if (state.keys['KeyW'] || state.keys['KeyS'] || state.keys['KeyA'] || state.keys['KeyD']) spreadMult *= 1.3;
  // Crouching reduces spread
  if (state.crouching) spreadMult *= 0.7;

  direction.x += (Math.random() - 0.5) * w.spread * spreadMult;
  direction.y += (Math.random() - 0.5) * w.spread * spreadMult;
  direction.normalize();

  raycaster.set(camera.position, direction);
  raycaster.far = w.range;

  // Check bot hits
  var hitBot = false;
  state.bots.forEach(function(bot) {
    if (!bot.alive) return;
    var dist = camera.position.distanceTo(bot.position);
    if (dist > w.range) return;

    // Simple sphere hit detection
    var toBot = new THREE.Vector3().subVectors(bot.mesh.position, camera.position).add(new THREE.Vector3(0, 1.2, 0));
    var dot = toBot.dot(direction);
    if (dot < 0) return;
    var closest = direction.clone().multiplyScalar(dot);
    var hitDist = closest.distanceTo(toBot);

    if (hitDist < 0.8) { // hit radius
      var damage = w.damage;
      var isHeadshot = false;
      // Headshot detection (if closest point is near head height)
      var hitY = camera.position.y + closest.y;
      var botHeadY = bot.position.y + 1.9;
      if (Math.abs(hitY - botHeadY) < 0.3) {
        damage *= 2.5; // headshot
        isHeadshot = true;
        AudioSys.playHeadshot();
        showStreakBanner('HEADSHOT', '#fbbf24', '+' + Math.round(damage) + ' DMG');
      } else {
        AudioSys.playHit();
      }

      // Distance falloff
      var falloff = 1 - Math.max(0, (dist - w.range * 0.5) / (w.range * 0.5)) * 0.5;
      damage *= falloff;

      var finalDmg = Math.round(damage);
      damageBot(bot, finalDmg);
      hitBot = true;
      showHitmarker();

      // Show floating damage number
      showDamageNumber(finalDmg, isHeadshot, bot.mesh.position);
    }
  });

  // Rocket launcher: create projectile
  if (w.id === 'rocket') {
    createProjectile(camera.position.clone(), direction.clone());
  }

  // Create tracer effect
  createTracer(camera.position.clone(), direction.clone(), w.range);

  // Create impact particles where the shot lands
  if (!hitBot) {
    var hitPos = camera.position.clone().add(direction.clone().multiplyScalar(w.range));
    createImpactSparks(hitPos);
  }

  updateWeaponHUD();
}

//  FLOATING DAMAGE NUMBERS 
function showDamageNumber(damage, isHeadshot, worldPos) {
  // Project 3D position to screen
  if (!camera) return;
  var vec = worldPos.clone();
  vec.y += 2.2;
  vec.project(camera);
  var x = (vec.x * 0.5 + 0.5) * window.innerWidth;
  var y = (-vec.y * 0.5 + 0.5) * window.innerHeight;

  var el = document.createElement('div');
  el.className = 'dmg-number ' + (isHeadshot ? 'headshot' : (damage >= 40 ? 'crit' : 'normal'));
  el.textContent = damage;
  el.style.left = (x + (Math.random() - 0.5) * 40) + 'px';
  el.style.top = y + 'px';
  document.body.appendChild(el);
  setTimeout(function() { el.remove(); }, 1000);
}

//  XP POPUP 
function showXPPopup(amount) {
  var el = document.createElement('div');
  el.className = 'xp-popup';
  el.textContent = '+' + amount + ' XP';
  document.body.appendChild(el);
  setTimeout(function() { el.remove(); }, 1500);
}

//  KILL CONFIRMED POPUP 
function showKillConfirmed(victimName) {
  var el = document.createElement('div');
  el.className = 'kill-confirmed';
  el.textContent = 'ELIMINATED ' + victimName;
  document.body.appendChild(el);
  setTimeout(function() { el.remove(); }, 1200);
}

//  STREAK BANNER 
function showStreakBanner(text, color, subtitle) {
  var el = document.createElement('div');
  el.className = 'streak-banner';
  el.innerHTML = '<div class="sb-title" style="color:' + color + '">' + text + '</div>' +
    (subtitle ? '<div class="sb-sub">' + subtitle + '</div>' : '');
  document.body.appendChild(el);
  setTimeout(function() { el.remove(); }, 2500);
}

//  DAMAGE DIRECTION INDICATOR 
function showDamageIndicator(attackerPos) {
  if (!attackerPos) return;
  var dx = attackerPos.x - camera.position.x;
  var dz = attackerPos.z - camera.position.z;
  var angle = Math.atan2(dx, dz) - state.yaw;

  var container = document.getElementById('damage-indicators');
  var indicator = document.createElement('div');
  indicator.className = 'dmg-indicator';
  indicator.style.transform = 'translate(-50%, -50%) rotate(' + (angle * 180 / Math.PI) + 'deg) translateY(-80px)';
  indicator.innerHTML = '<div class="dmg-indicator-arrow"></div>';
  container.appendChild(indicator);
  setTimeout(function() { indicator.remove(); }, 600);
}

//  IMPACT SPARK PARTICLES 
function createImpactSparks(pos) {
  for (var i = 0; i < 4; i++) {
    var sparkGeo = new THREE.SphereGeometry(0.03, 4, 4);
    var sparkMat = new THREE.MeshBasicMaterial({ color: 0xffaa44 });
    var spark = new THREE.Mesh(sparkGeo, sparkMat);
    spark.position.copy(pos);
    scene.add(spark);
    var vel = new THREE.Vector3((Math.random() - 0.5) * 3, Math.random() * 3, (Math.random() - 0.5) * 3);
    var startTime = performance.now();
    (function(s, v, st) {
      function animSpark() {
        var elapsed = (performance.now() - st) / 1000;
        if (elapsed > 0.4) { scene.remove(s); return; }
        v.y -= 15 * 0.016;
        s.position.add(v.clone().multiplyScalar(0.016));
        s.material.opacity = 1 - elapsed / 0.4;
        requestAnimationFrame(animSpark);
      }
      animSpark();
    })(spark, vel, startTime);
  }
}

function createProjectile(pos, dir) {
  var geo = new THREE.SphereGeometry(0.15, 6, 6);
  var mat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
  var mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  projectileMeshes.push(mesh);

  state.projectiles.push({
    mesh: mesh,
    position: pos.clone(),
    direction: dir.clone(),
    speed: 30,
    lifetime: 3,
    damage: WEAPONS[5].damage
  });
}

function createTracer(pos, dir, range) {
  var geo = new THREE.BufferGeometry();
  var end = pos.clone().add(dir.clone().multiplyScalar(range));
  geo.setFromPoints([pos, end]);
  var mat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.3 });
  var line = new THREE.Line(geo, mat);
  scene.add(line);
  setTimeout(function() { scene.remove(line); }, 50);
}

function showHitmarker() {
  var hm = document.getElementById('hitmarker');
  hm.classList.add('show');
  setTimeout(function() { hm.classList.remove('show'); }, 150);
}

//  DAMAGE SYSTEM 
function damageBot(bot, damage) {
  bot.health -= damage;
  // Flash bot color
  if (bot.mesh.children[0]) {
    bot.mesh.children[0].material.emissive.setHex(0xff0000);
    setTimeout(function() {
      if (bot.mesh.children[0]) bot.mesh.children[0].material.emissive.setHex(0x000000);
    }, 100);
  }

  if (bot.health <= 0) {
    killBot(bot);
  }
}

function killBot(bot) {
  bot.alive = false;
  bot.deaths++;
  bot.respawnTimer = RESPAWN_TIME;

  // Death animation - bot falls over then disappears
  var deathStart = performance.now();
  (function(mesh) {
    function deathAnim() {
      var elapsed = (performance.now() - deathStart) / 1000;
      if (elapsed > 1.5) { mesh.visible = false; return; }
      if (elapsed < 0.5) {
        mesh.rotation.z = elapsed * Math.PI * 0.5;
        mesh.position.y = -elapsed * 0.5;
      } else {
        mesh.children.forEach(function(c) {
          if (c.material) c.material.opacity = 1 - (elapsed - 0.5);
        });
      }
      requestAnimationFrame(deathAnim);
    }
    deathAnim();
  })(bot.mesh);

  state.kills++;
  state.streak++;
  if (state.streak > state.bestStreak) state.bestStreak = state.streak;

  // XP with more granularity
  var diff = DIFF[state.difficulty];
  var xpGain = Math.round(25 * diff.xpMult);
  if (state.streak >= 3) xpGain += 10;
  if (state.streak >= 5) xpGain += 20;
  if (state.streak >= 10) xpGain += 30;
  state.xpThisMatch += xpGain;

  // Audio
  AudioSys.playKill();

  // 50% chance to drop a weapon
  if (Math.random() < 0.5) {
    spawnWeaponDrop(bot.position);
  }

  // Kill feed
  addKillFeed(state.userName, bot.name);

  // Kill confirmed popup
  showKillConfirmed(bot.name);
  showXPPopup(xpGain);

  // Streak notifications with banners
  if (state.streak === 3) showStreakBanner('TRIPLE KILL', '#f97316', '3 Kill Streak');
  else if (state.streak === 5) showStreakBanner('KILLING SPREE', '#ef4444', '5 Kill Streak - Bonus XP!');
  else if (state.streak === 8) showStreakBanner('UNSTOPPABLE', '#a855f7', '8 Kill Streak!');
  else if (state.streak === 10) showStreakBanner('GODLIKE', '#fbbf24', '10 Kill Streak - LEGENDARY!');
  else if (state.streak === 15) showStreakBanner('NUCLEAR', '#ff0000', '15 KILLS - ABSOLUTE DOMINATION');

  updateHUD();
}

function damagePlayer(damage, attackerName, attackerPos) {
  // Spawn protection
  if (isSpawnProtected()) return;

  // Record shot for killcam replay
  if (attackerPos) {
    recordShot(attackerName, attackerPos);
  }

  // Armor absorbs 60% of damage
  if (state.armor > 0) {
    var armorDmg = Math.min(state.armor, damage * 0.6);
    state.armor -= armorDmg;
    damage -= armorDmg;
  }
  state.health -= damage;

  // Damage flash
  var overlay = document.getElementById('damage-overlay');
  overlay.classList.add('hit');
  setTimeout(function() { overlay.classList.remove('hit'); }, 200);

  // Audio
  AudioSys.playDamage();

  // Screen shake on damage
  addScreenShake(damage * 0.005);

  // View punch - flinch when hit
  state.viewPunchX -= 0.02;
  state.viewPunchY += (Math.random() - 0.5) * 0.02;

  // Damage direction indicator
  if (attackerPos) {
    showDamageIndicator(attackerPos);
  }

  // Low health effects
  var lowHealthOverlay = document.getElementById('low-health-overlay');
  if (state.health <= 30 && state.health > 0) {
    lowHealthOverlay.classList.add('active');
  } else {
    lowHealthOverlay.classList.remove('active');
  }

  // Chrome aberration effect for heavy damage
  if (damage > 20) {
    document.getElementById('game-canvas').style.filter = 'saturate(0.5) contrast(1.2)';
    setTimeout(function() { document.getElementById('game-canvas').style.filter = ''; }, 150);
  }

  if (state.health <= 0) {
    playerDie(attackerName);
  }
  updateHUD();
}

function playerDie(killerName) {
  state.health = 0;
  state.deaths++;
  state.streak = 0;
  addKillFeed(killerName, state.userName);

  showStreakBanner('ELIMINATED', '#ef4444', 'Killed by ' + killerName);

  // Start killcam instant replay
  startKillcam(killerName);
}

function respawnPlayer() {
  var pos = getRandomSpawn();
  camera.position.set(pos.x, PLAYER_HEIGHT, pos.z);
  state.health = state.maxHealth;
  state.armor = 50;
  state.velocity.set(0, 0, 0);
  state.grenades = Math.min(state.grenades + 1, 3); // Gain 1 grenade on respawn
  document.getElementById('hud-grenades').textContent = state.grenades;
  // Clear low health overlay
  document.getElementById('low-health-overlay').classList.remove('active');
  // Refill ammo
  WEAPONS.forEach(function(w, i) {
    state.ammoClip[i] = w.clipSize;
    state.ammoReserve[i] = w.reserve;
  });
  // Spawn protection
  activateSpawnProtection();
  updateHUD();
}

//  GAME LOOP 
function gameLoop() {
  requestAnimationFrame(gameLoop);

  if (!state.gameStarted || state.paused || !state.matchActive) {
    renderer.render(scene, camera);
    return;
  }

  var dt = Math.min(clock.getDelta(), 0.05);

  // Match timer
  state.matchTime -= dt;
  if (state.matchTime <= 0) {
    endMatch();
    return;
  }

  // Killcam replay mode  skip normal gameplay updates
  if (killcam.active) {
    updateKillcam(dt);
    updateTimerHUD();
    renderer.render(scene, camera);
    return;
  }

  // Record replay frames while alive
  if (state.health > 0) {
    recordReplayFrame(dt);
  }

  // Update camera rotation
  camera.rotation.order = 'YXZ';
  camera.rotation.x = state.pitch;
  camera.rotation.y = state.yaw;

  // Player movement
  updatePlayerMovement(dt);

  // Firing
  state.fireTimer -= dt;
  if (state.mouseDown && state.fireTimer <= 0 && !state.reloading && state.health > 0) {
    var w = WEAPONS[state.currentWeapon];
    if (w.auto || state.fireTimer <= -0.1) { // auto or first click
      fireWeapon();
      state.fireTimer = 1 / w.fireRate;
    }
  }

  // Reload
  if (state.reloading) {
    state.reloadTimer -= dt;
    if (state.reloadTimer <= 0) {
      var w2 = WEAPONS[state.currentWeapon];
      var needed = w2.clipSize - state.ammoClip[state.currentWeapon];
      var available = Math.min(needed, state.ammoReserve[state.currentWeapon]);
      state.ammoClip[state.currentWeapon] += available;
      state.ammoReserve[state.currentWeapon] -= available;
      state.reloading = false;
      updateWeaponHUD();
    }
  }

  // Update bots
  updateBots(dt);

  // Update projectiles
  updateProjectiles(dt);

  // Update pickups
  updatePickups(dt);

  // Update HUD
  updateTimerHUD();

  // Render minimap
  renderMinimap();

  // Render
  renderer.render(scene, camera);
}

//  PLAYER MOVEMENT 
function updatePlayerMovement(dt) {
  if (state.health <= 0) return;

  // Slide update
  if (state.sliding) {
    state.slideTimer -= dt;
    if (state.slideTimer <= 0) {
      state.sliding = false;
      state.crouching = false;
      document.getElementById('slide-indicator').style.display = 'none';
    } else {
      // Apply slide velocity
      var slideSpeed = PLAYER_SPEED * 2.2 * (state.slideTimer / 0.6);
      camera.position.x += state.slideDir.x * slideSpeed * dt;
      camera.position.z += state.slideDir.z * slideSpeed * dt;
      // Clamp
      var half = ARENA_SIZE / 2 - 0.5;
      camera.position.x = Math.max(-half, Math.min(half, camera.position.x));
      camera.position.z = Math.max(-half, Math.min(half, camera.position.z));
      // Low camera
      var slideHeight = PLAYER_HEIGHT - 0.8;
      if (camera.position.y > slideHeight) camera.position.y = slideHeight;
      return; // Skip normal movement during slide
    }
  }

  // Speed modifiers
  var speed = PLAYER_SPEED;
  if (state.sprinting && !state.ads && !state.crouching) speed *= SPRINT_MULTIPLIER;
  if (state.crouching) speed *= 0.5;
  if (state.ads) speed *= 0.6;

  var forward = new THREE.Vector3(0, 0, -1);
  forward.applyEuler(new THREE.Euler(0, state.yaw, 0));
  var right = new THREE.Vector3(1, 0, 0);
  right.applyEuler(new THREE.Euler(0, state.yaw, 0));

  var moveDir = new THREE.Vector3();
  if (state.keys['KeyW']) moveDir.add(forward);
  if (state.keys['KeyS']) moveDir.sub(forward);
  if (state.keys['KeyA']) moveDir.sub(right);
  if (state.keys['KeyD']) moveDir.add(right);

  if (moveDir.length() > 0) moveDir.normalize();

  // Horizontal movement with slight acceleration
  var targetVelX = moveDir.x * speed;
  var targetVelZ = moveDir.z * speed;
  state.velocity.x += (targetVelX - state.velocity.x) * Math.min(1, dt * 12);
  state.velocity.z += (targetVelZ - state.velocity.z) * Math.min(1, dt * 12);

  // Gravity
  state.velocity.y += GRAVITY * dt;

  // Jump (can't jump while crouching)
  if (state.keys['Space'] && state.onGround && !state.crouching) {
    state.velocity.y = JUMP_SPEED;
    state.onGround = false;
  }

  // Apply velocity
  var newPos = camera.position.clone();
  newPos.x += state.velocity.x * dt;
  newPos.y += state.velocity.y * dt;
  newPos.z += state.velocity.z * dt;

  // Floor collision with crouch height
  var currentHeight = PLAYER_HEIGHT - (state.crouchLerp * 0.6);
  if (newPos.y < currentHeight) {
    newPos.y = currentHeight;
    state.velocity.y = 0;
    state.onGround = true;
  }

  // Arena boundary
  var half = ARENA_SIZE / 2 - 0.5;
  newPos.x = Math.max(-half, Math.min(half, newPos.x));
  newPos.z = Math.max(-half, Math.min(half, newPos.z));

  // Simple structure collision
  arenaObjects.forEach(function(obj) {
    if (!obj.geometry || !obj.geometry.parameters) return;
    var p = obj.geometry.parameters;
    var w = (p.width || 0) / 2 + 0.3;
    var h = (p.height || 0) / 2;
    var d = (p.depth || 0) / 2 + 0.3;
    var op = obj.position;

    if (Math.abs(newPos.x - op.x) < w &&
        Math.abs(newPos.y - op.y) < h + PLAYER_HEIGHT * 0.5 &&
        Math.abs(newPos.z - op.z) < d) {
      // Push out
      var dx = newPos.x - op.x;
      var dz = newPos.z - op.z;
      if (Math.abs(dx / w) > Math.abs(dz / d)) {
        newPos.x = op.x + (dx > 0 ? w : -w);
      } else {
        newPos.z = op.z + (dz > 0 ? d : -d);
      }
    }
  });

  camera.position.copy(newPos);
}

//  ENHANCED BOT AI 
// Bot AI states: 'patrol', 'chase', 'combat', 'retreat', 'flank'
function updateBots(dt) {
  var diff = DIFF[state.difficulty];

  state.bots.forEach(function(bot) {
    if (!bot.alive) {
      bot.respawnTimer -= dt;
      if (bot.respawnTimer <= 0) {
        // Respawn bot with full reset
        var pos = getRandomSpawn();
        bot.position.set(pos.x, 0, pos.z);
        bot.mesh.position.copy(bot.position);
        bot.mesh.rotation.z = 0;
        bot.mesh.position.y = 0;
        bot.health = diff.botHealth;
        bot.alive = true;
        bot.mesh.visible = true;
        bot.mesh.children.forEach(function(c) {
          if (c.material) { c.material.opacity = 1; c.material.transparent = false; }
        });
        bot.aiState = 'patrol';
        bot.strafeDir = 1;
        bot.strafeTimer = 0;
      }
      return;
    }

    // Initialize AI state if missing
    if (!bot.aiState) bot.aiState = 'patrol';
    if (!bot.strafeDir) bot.strafeDir = 1;
    if (!bot.strafeTimer) bot.strafeTimer = 0;
    if (!bot.retreatTimer) bot.retreatTimer = 0;

    // Distance to player
    var toPlayer = new THREE.Vector3().subVectors(camera.position, bot.position);
    toPlayer.y = 0;
    var distToPlayer = toPlayer.length();

    // AI state machine
    var healthPct = bot.health / diff.botHealth;

    // State transitions
    if (healthPct < 0.25 && bot.aiState !== 'retreat') {
      bot.aiState = 'retreat';
      bot.retreatTimer = 3 + Math.random() * 2;
    } else if (distToPlayer < 12 && healthPct > 0.4) {
      bot.aiState = 'combat';
    } else if (distToPlayer < 35) {
      if (bot.aiState === 'patrol') {
        bot.aiState = Math.random() < 0.3 ? 'flank' : 'chase';
      }
    } else if (distToPlayer > 50) {
      bot.aiState = 'patrol';
    }

    var moveSpeed = diff.botSpeed;

    switch (bot.aiState) {
      case 'patrol':
        // Wander around looking for player
        bot.changeDirTimer -= dt;
        if (bot.changeDirTimer <= 0) {
          bot.changeDirTimer = 2 + Math.random() * 4;
          // Patrol toward random points of interest
          var patrolTargets = [[0,0], [-20,-20], [20,20], [-20,20], [20,-20], [0,-25], [0,25]];
          var target = patrolTargets[Math.floor(Math.random() * patrolTargets.length)];
          var dir = new THREE.Vector3(target[0] - bot.position.x, 0, target[1] - bot.position.z);
          if (dir.length() > 0) dir.normalize();
          bot.moveDir = dir;
        }
        break;

      case 'chase':
        // Move toward player
        bot.changeDirTimer -= dt;
        if (bot.changeDirTimer <= 0) {
          bot.changeDirTimer = 0.5 + Math.random() * 1;
          bot.moveDir = toPlayer.clone().normalize();
          // Add slight randomness to path
          bot.moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.4);
        }
        moveSpeed *= 1.1;
        break;

      case 'combat':
        // Strafe and shoot - the most engaging behavior
        bot.strafeTimer -= dt;
        if (bot.strafeTimer <= 0) {
          bot.strafeTimer = 0.5 + Math.random() * 1.5;
          bot.strafeDir = Math.random() < 0.5 ? 1 : -1;
          // Sometimes dodge backward
          if (Math.random() < 0.2) bot.strafeDir = 0;
        }

        // Calculate strafe direction (perpendicular to player direction)
        var toPlayerNorm = toPlayer.clone().normalize();
        var strafeVec = new THREE.Vector3(-toPlayerNorm.z, 0, toPlayerNorm.x).multiplyScalar(bot.strafeDir);

        // If too close, back up
        if (distToPlayer < 6) {
          bot.moveDir = toPlayerNorm.clone().negate().add(strafeVec.multiplyScalar(0.5)).normalize();
          moveSpeed *= 1.2;
        } else if (distToPlayer > 20) {
          // Move closer while strafing
          bot.moveDir = toPlayerNorm.clone().multiplyScalar(0.5).add(strafeVec.multiplyScalar(0.5)).normalize();
        } else {
          // Pure strafe at optimal range
          bot.moveDir = strafeVec.normalize();
        }
        moveSpeed *= 0.8;
        break;

      case 'retreat':
        // Run away from player to heal (find cover)
        bot.retreatTimer -= dt;
        var awayDir = toPlayer.clone().negate().normalize();
        // Add randomness to not run in straight line
        awayDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.8);
        bot.moveDir = awayDir;
        moveSpeed *= 1.3;

        // Slowly regenerate health while retreating
        bot.health = Math.min(diff.botHealth, bot.health + dt * 5);

        if (bot.retreatTimer <= 0 || healthPct > 0.6) {
          bot.aiState = distToPlayer < 30 ? 'combat' : 'chase';
        }
        break;

      case 'flank':
        // Try to get around the player
        bot.changeDirTimer -= dt;
        if (bot.changeDirTimer <= 0) {
          bot.changeDirTimer = 1 + Math.random() * 2;
          // Move perpendicular to player, then toward them
          var perpDir = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x).normalize();
          if (Math.random() < 0.5) perpDir.negate();
          bot.moveDir = perpDir.add(toPlayer.clone().normalize().multiplyScalar(0.3)).normalize();
        }
        moveSpeed *= 1.1;
        // Transition to combat when flanked
        if (distToPlayer < 15) bot.aiState = 'combat';
        break;
    }

    // Apply movement
    bot.position.add(bot.moveDir.clone().multiplyScalar(moveSpeed * dt));

    // Arena bounds
    var half = ARENA_SIZE / 2 - 1;
    bot.position.x = Math.max(-half, Math.min(half, bot.position.x));
    bot.position.z = Math.max(-half, Math.min(half, bot.position.z));

    // Simple obstacle avoidance
    arenaObjects.forEach(function(obj) {
      if (!obj.geometry || !obj.geometry.parameters) return;
      var p = obj.geometry.parameters;
      var ow = (p.width || 0) / 2 + 0.8;
      var od = (p.depth || 0) / 2 + 0.8;
      var op = obj.position;
      if (Math.abs(bot.position.x - op.x) < ow && Math.abs(bot.position.z - op.z) < od) {
        var dx = bot.position.x - op.x;
        var dz = bot.position.z - op.z;
        if (Math.abs(dx / ow) > Math.abs(dz / od)) {
          bot.position.x = op.x + (dx > 0 ? ow : -ow);
        } else {
          bot.position.z = op.z + (dz > 0 ? od : -od);
        }
      }
    });

    bot.mesh.position.copy(bot.position);

    // Face player when in combat or chasing
    if (distToPlayer < 40 && (bot.aiState === 'combat' || bot.aiState === 'chase' || bot.aiState === 'flank')) {
      var lookDir = toPlayer.clone().normalize();
      var targetRot = Math.atan2(lookDir.x, lookDir.z);
      // Smooth rotation
      var rotDiff = targetRot - bot.mesh.rotation.y;
      while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
      while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
      bot.mesh.rotation.y += rotDiff * Math.min(1, dt * 8);
    } else {
      // Face movement direction
      bot.mesh.rotation.y = Math.atan2(bot.moveDir.x, bot.moveDir.z);
    }

    // Health bar above bot
    updateBotHealthBar(bot);

    // Fire at player - smarter shooting
    if (distToPlayer < 35 && state.health > 0 && bot.aiState !== 'retreat') {
      bot.fireTimer -= dt;
      if (bot.fireTimer <= 0) {
        // Fire rate increases in combat state
        var fireRateMult = bot.aiState === 'combat' ? 1.3 : 1;
        bot.fireTimer = 1 / (diff.botFireRate * fireRateMult);

        // Accuracy affected by state and distance
        var accMult = 1;
        if (bot.aiState === 'combat') accMult = 1.2; // Better accuracy when focused
        if (bot.aiState === 'flank') accMult = 0.8; // Worse when moving fast
        if (distToPlayer < 10) accMult *= 1.3; // Better at close range
        if (distToPlayer > 25) accMult *= 0.7; // Worse at long range

        if (Math.random() < diff.botAccuracy * accMult) {
          var dmg = 8 + Math.floor(Math.random() * 12);
          // Headshot chance for bots (difficulty based)
          if (Math.random() < diff.botAccuracy * 0.15) {
            dmg *= 2;
          }
          damagePlayer(dmg, bot.name, bot.position);

          // Muzzle flash on bot
          if (bot.mesh.children.length > 0) {
            var gun = bot.mesh.children[bot.mesh.children.length - 1];
            if (gun && gun.material) {
              gun.material.emissive = new THREE.Color(0xff6600);
              setTimeout(function() { if (gun.material) gun.material.emissive = new THREE.Color(0x000000); }, 50);
            }
          }
        }
      }
    }
  });
}

//  BOT HEALTH BAR 
function updateBotHealthBar(bot) {
  var diff = DIFF[state.difficulty];
  var healthPct = bot.health / diff.botHealth;

  // Find or create health bar sprite
  if (!bot.healthBar) {
    var canvas2d = document.createElement('canvas');
    canvas2d.width = 64; canvas2d.height = 8;
    var tex = new THREE.CanvasTexture(canvas2d);
    var spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    var sprite = new THREE.Sprite(spriteMat);
    sprite.position.set(0, 2.4, 0);
    sprite.scale.set(1, 0.12, 1);
    bot.mesh.add(sprite);
    bot.healthBar = { sprite: sprite, canvas: canvas2d, texture: tex };
  }

  // Only show if damaged
  bot.healthBar.sprite.visible = healthPct < 1;
  if (healthPct < 1) {
    var ctx = bot.healthBar.canvas.getContext('2d');
    ctx.clearRect(0, 0, 64, 8);
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, 64, 8);
    var barColor = healthPct > 0.6 ? '#22c55e' : healthPct > 0.3 ? '#f59e0b' : '#ef4444';
    ctx.fillStyle = barColor;
    ctx.fillRect(1, 1, 62 * healthPct, 6);
    bot.healthBar.texture.needsUpdate = true;
  }
}

//  PROJECTILES 
function updateProjectiles(dt) {
  for (var i = state.projectiles.length - 1; i >= 0; i--) {
    var proj = state.projectiles[i];
    proj.position.add(proj.direction.clone().multiplyScalar(proj.speed * dt));
    proj.mesh.position.copy(proj.position);
    proj.lifetime -= dt;

    // Check bot hits
    var hitSomething = false;
    state.bots.forEach(function(bot) {
      if (!bot.alive) return;
      if (proj.position.distanceTo(bot.position.clone().add(new THREE.Vector3(0, 1, 0))) < 2) {
        damageBot(bot, proj.damage);
        hitSomething = true;
        // Explosion effect
        createExplosion(proj.position.clone());
      }
    });

    // Check arena collision
    if (Math.abs(proj.position.x) > ARENA_SIZE / 2 || Math.abs(proj.position.z) > ARENA_SIZE / 2) {
      hitSomething = true;
      createExplosion(proj.position.clone());
    }

    if (proj.lifetime <= 0 || hitSomething) {
      scene.remove(proj.mesh);
      projectileMeshes.splice(projectileMeshes.indexOf(proj.mesh), 1);
      state.projectiles.splice(i, 1);
    }
  }
}

function createExplosion(pos) {
  // Main explosion sphere
  var geo = new THREE.SphereGeometry(2, 12, 12);
  var mat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.7 });
  var sphere = new THREE.Mesh(geo, mat);
  sphere.position.copy(pos);
  scene.add(sphere);

  // Inner bright core
  var coreGeo = new THREE.SphereGeometry(1, 8, 8);
  var coreMat = new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, opacity: 0.9 });
  var core = new THREE.Mesh(coreGeo, coreMat);
  core.position.copy(pos);
  scene.add(core);

  // Shockwave ring
  var ringGeo = new THREE.RingGeometry(0.5, 1, 32);
  var ringMat = new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  var ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.copy(pos);
  ring.position.y += 0.1;
  ring.rotation.x = -Math.PI / 2;
  scene.add(ring);

  // Debris particles
  for (var i = 0; i < 12; i++) {
    var debrisGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    var debrisMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff6600 : 0x888888 });
    var debris = new THREE.Mesh(debrisGeo, debrisMat);
    debris.position.copy(pos);
    scene.add(debris);
    var vel = new THREE.Vector3((Math.random()-0.5)*8, Math.random()*8+2, (Math.random()-0.5)*8);
    (function(d, v) {
      var st = performance.now();
      function animDebris() {
        var el = (performance.now() - st) / 1000;
        if (el > 1.5) { scene.remove(d); return; }
        v.y -= 15 * 0.016;
        d.position.add(v.clone().multiplyScalar(0.016));
        d.rotation.x += 5 * 0.016;
        d.rotation.z += 3 * 0.016;
        requestAnimationFrame(animDebris);
      }
      animDebris();
    })(debris, vel);
  }

  // Audio
  AudioSys.playExplosion();

  // Screen shake if close to player
  var playerDist = camera.position.distanceTo(pos);
  if (playerDist < 30) {
    addScreenShake(0.3 * (1 - playerDist / 30));
  }

  // Damage nearby bots
  state.bots.forEach(function(bot) {
    if (!bot.alive) return;
    var dist = bot.position.distanceTo(pos);
    if (dist < 5) {
      var splashDmg = Math.round(80 * (1 - dist / 5));
      damageBot(bot, splashDmg);
    }
  });

  // Point light flash
  var flashLight = new THREE.PointLight(0xff6600, 3, 20);
  flashLight.position.copy(pos);
  scene.add(flashLight);

  // Animate and remove
  var start = performance.now();
  function animateExplosion() {
    var elapsed = (performance.now() - start) / 600;
    if (elapsed > 1) {
      scene.remove(sphere);
      scene.remove(core);
      scene.remove(ring);
      scene.remove(flashLight);
      return;
    }
    sphere.scale.setScalar(1 + elapsed * 3);
    sphere.material.opacity = 0.7 * (1 - elapsed);
    core.scale.setScalar(1 + elapsed * 1.5);
    core.material.opacity = 0.9 * (1 - elapsed * 1.5);
    ring.scale.setScalar(1 + elapsed * 8);
    ring.material.opacity = 0.5 * (1 - elapsed);
    flashLight.intensity = 3 * (1 - elapsed);
    requestAnimationFrame(animateExplosion);
  }
  animateExplosion();
}

//  WEAPON DROPS FROM KILLED BOTS 
var weaponDrops = [];
var weaponDropMeshes = [];

function spawnWeaponDrop(position) {
  // Random weapon drop
  var weaponIdx = Math.floor(Math.random() * WEAPONS.length);
  var w = WEAPONS[weaponIdx];

  var group = new THREE.Group();
  // Simple box representation of weapon
  var geo = new THREE.BoxGeometry(0.3, 0.15, 0.6);
  var mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(w.color), emissive: new THREE.Color(w.color), emissiveIntensity: 0.3 });
  var mesh = new THREE.Mesh(geo, mat);
  group.add(mesh);

  // Glow
  var glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
  var glowMat = new THREE.MeshBasicMaterial({ color: new THREE.Color(w.color), transparent: true, opacity: 0.15 });
  var glow = new THREE.Mesh(glowGeo, glowMat);
  group.add(glow);

  group.position.set(position.x, 0.5, position.z);
  scene.add(group);
  weaponDropMeshes.push(group);

  weaponDrops.push({
    mesh: group,
    weaponIdx: weaponIdx,
    position: new THREE.Vector3(position.x, 0.5, position.z),
    active: true,
    lifetime: 20 // Disappears after 20 seconds
  });
}

function updateWeaponDrops(dt) {
  for (var i = weaponDrops.length - 1; i >= 0; i--) {
    var drop = weaponDrops[i];
    if (!drop.active) continue;

    drop.lifetime -= dt;
    if (drop.lifetime <= 0) {
      scene.remove(drop.mesh);
      weaponDropMeshes.splice(weaponDropMeshes.indexOf(drop.mesh), 1);
      weaponDrops.splice(i, 1);
      continue;
    }

    // Animate: hover and rotate
    drop.mesh.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.15;
    drop.mesh.rotation.y += dt * 2;

    // Blink when about to expire
    if (drop.lifetime < 5) {
      drop.mesh.visible = Math.sin(Date.now() * 0.01) > 0;
    }

    // Check player pickup
    var dist = camera.position.distanceTo(drop.position);
    if (dist < 2) {
      // Switch to this weapon and refill its ammo
      var w = WEAPONS[drop.weaponIdx];
      state.currentWeapon = drop.weaponIdx;
      state.ammoClip[drop.weaponIdx] = w.clipSize;
      state.ammoReserve[drop.weaponIdx] = w.reserve;
      AudioSys.playPickup();
      showToast('Picked up ' + w.name + '!');
      updateWeaponHUD();
      updateHUD();

      scene.remove(drop.mesh);
      weaponDropMeshes.splice(weaponDropMeshes.indexOf(drop.mesh), 1);
      weaponDrops.splice(i, 1);
    }
  }
}

//  SPAWN PROTECTION 
var spawnProtectionTimer = 0;

function activateSpawnProtection() {
  spawnProtectionTimer = 3; // 3 seconds of protection
  showToast('SPAWN PROTECTION (3s)');
}

function isSpawnProtected() {
  return spawnProtectionTimer > 0;
}

//  ENVIRONMENT HAZARDS 
var hazardZones = [];

function createHazardZones() {
  // Electric zones that pulse and damage players/bots who stand in them
  var hazardPositions = [
    { x: 0, z: 0, radius: 2 },      // Central danger zone
    { x: -30, z: -30, radius: 3 },   // Corner hazards
    { x: 30, z: 30, radius: 3 },
  ];

  hazardPositions.forEach(function(hz) {
    // Visual indicator - pulsing ring on ground
    var ringGeo = new THREE.RingGeometry(hz.radius - 0.2, hz.radius, 32);
    var ringMat = new THREE.MeshBasicMaterial({
      color: 0xf59e0b, transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    var ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.set(hz.x, 0.05, hz.z);
    ring.rotation.x = -Math.PI / 2;
    scene.add(ring);

    // Inner danger area
    var innerGeo = new THREE.CircleGeometry(hz.radius - 0.2, 32);
    var innerMat = new THREE.MeshBasicMaterial({
      color: 0xf59e0b, transparent: true, opacity: 0.08, side: THREE.DoubleSide
    });
    var inner = new THREE.Mesh(innerGeo, innerMat);
    inner.position.set(hz.x, 0.04, hz.z);
    inner.rotation.x = -Math.PI / 2;
    scene.add(inner);

    // Electric particle effect
    var particleGeo = new THREE.BufferGeometry();
    var positions = [];
    for (var j = 0; j < 20; j++) {
      var angle = Math.random() * Math.PI * 2;
      var r = Math.random() * hz.radius;
      positions.push(hz.x + Math.cos(angle) * r, 0.5 + Math.random() * 2, hz.z + Math.sin(angle) * r);
    }
    particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    var particleMat = new THREE.PointsMaterial({ color: 0xf59e0b, size: 0.08, transparent: true, opacity: 0.6 });
    var particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);

    hazardZones.push({
      x: hz.x, z: hz.z, radius: hz.radius,
      ring: ring, inner: inner, particles: particles,
      damageTimer: 0
    });
  });
}

function updateHazardZones(dt) {
  hazardZones.forEach(function(hz) {
    // Pulse animation
    var pulse = 0.3 + Math.sin(Date.now() * 0.005) * 0.15;
    hz.ring.material.opacity = pulse;
    hz.inner.material.opacity = pulse * 0.25;

    // Update particles
    var posArr = hz.particles.geometry.attributes.position.array;
    for (var i = 0; i < posArr.length; i += 3) {
      posArr[i + 1] += dt * (1 + Math.random());
      if (posArr[i + 1] > 3) {
        posArr[i + 1] = 0.2;
        var angle = Math.random() * Math.PI * 2;
        var r = Math.random() * hz.radius;
        posArr[i] = hz.x + Math.cos(angle) * r;
        posArr[i + 2] = hz.z + Math.sin(angle) * r;
      }
    }
    hz.particles.geometry.attributes.position.needsUpdate = true;

    // Damage check
    hz.damageTimer -= dt;
    if (hz.damageTimer <= 0) {
      hz.damageTimer = 0.5; // damage every 0.5s

      // Player damage
      var playerDist = Math.sqrt(
        Math.pow(camera.position.x - hz.x, 2) + Math.pow(camera.position.z - hz.z, 2)
      );
      if (playerDist < hz.radius && state.health > 0 && !isSpawnProtected()) {
        damagePlayer(8, 'Electric Hazard');
        showToast('HAZARD ZONE!');
      }

      // Bot damage
      state.bots.forEach(function(bot) {
        if (!bot.alive) return;
        var botDist = Math.sqrt(
          Math.pow(bot.position.x - hz.x, 2) + Math.pow(bot.position.z - hz.z, 2)
        );
        if (botDist < hz.radius) {
          damageBot(bot, 10);
        }
      });
    }
  });
}

//  PICKUPS 
function updatePickups(dt) {
  state.pickups.forEach(function(pickup) {
    if (!pickup.active) {
      pickup.respawnTimer -= dt;
      if (pickup.respawnTimer <= 0) {
        pickup.active = true;
        pickup.mesh.visible = true;
      }
      return;
    }

    // Animate rotation
    pickup.mesh.rotation.y += dt * 2;
    pickup.mesh.position.y = pickup.position.y + Math.sin(Date.now() * 0.003) * 0.15;

    // Check player proximity
    var dist = camera.position.distanceTo(pickup.mesh.position);
    if (dist < 1.5) {
      switch (pickup.type) {
        case 'health':
          if (state.health < state.maxHealth) {
            state.health = Math.min(state.maxHealth, state.health + 25);
            pickup.active = false;
            pickup.mesh.visible = false;
            pickup.respawnTimer = 15;
            AudioSys.playPickup();
            showToast('+25 Health');
            // Remove low health effect
            if (state.health > 30) document.getElementById('low-health-overlay').classList.remove('active');
          }
          break;
        case 'armor':
          if (state.armor < state.maxArmor) {
            state.armor = Math.min(state.maxArmor, state.armor + 25);
            pickup.active = false;
            pickup.mesh.visible = false;
            pickup.respawnTimer = 15;
            AudioSys.playPickup();
            showToast('+25 Armor');
          }
          break;
        case 'ammo':
          var w = WEAPONS[state.currentWeapon];
          if (state.ammoReserve[state.currentWeapon] < w.reserve) {
            state.ammoReserve[state.currentWeapon] = Math.min(w.reserve, state.ammoReserve[state.currentWeapon] + Math.ceil(w.clipSize * 1.5));
            pickup.active = false;
            pickup.mesh.visible = false;
            pickup.respawnTimer = 10;
            AudioSys.playPickup();
            showToast('+Ammo');
          }
          break;
      }
      updateHUD();
    }
  });
}

//  MINIMAP 
function renderMinimap() {
  if (!minimapCtx) return;
  var ctx = minimapCtx;
  var w = 150, h = 150;
  var scale = w / ARENA_SIZE;

  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgba(10,10,30,0.8)';
  ctx.fillRect(0, 0, w, h);

  // Arena border
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.strokeRect(2, 2, w - 4, h - 4);

  // Player position (center-relative)
  var px = w / 2 + camera.position.x * scale;
  var pz = h / 2 + camera.position.z * scale;
  ctx.fillStyle = '#22c55e';
  ctx.beginPath();
  ctx.arc(px, pz, 3, 0, Math.PI * 2);
  ctx.fill();

  // Player direction
  var dx = Math.sin(state.yaw) * 8;
  var dz = -Math.cos(state.yaw) * 8;
  ctx.strokeStyle = '#22c55e';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(px, pz);
  ctx.lineTo(px - dx, pz - dz);
  ctx.stroke();

  // Bots
  state.bots.forEach(function(bot) {
    if (!bot.alive) return;
    var bx = w / 2 + bot.position.x * scale;
    var bz = h / 2 + bot.position.z * scale;
    ctx.fillStyle = '#ef4444';
    ctx.beginPath();
    ctx.arc(bx, bz, 2.5, 0, Math.PI * 2);
    ctx.fill();
  });

  // Pickups
  state.pickups.forEach(function(p) {
    if (!p.active) return;
    var px2 = w / 2 + p.position.x * scale;
    var pz2 = h / 2 + p.position.z * scale;
    ctx.fillStyle = p.type === 'health' ? '#22c55e' : p.type === 'armor' ? '#3b82f6' : '#f59e0b';
    ctx.fillRect(px2 - 1.5, pz2 - 1.5, 3, 3);
  });
}

//  HUD UPDATES 
function updateHUD() {
  document.getElementById('hud-health').textContent = Math.max(0, Math.round(state.health));
  document.getElementById('health-bar').style.width = Math.max(0, state.health / state.maxHealth * 100) + '%';
  document.getElementById('hud-armor').textContent = Math.max(0, Math.round(state.armor));
  document.getElementById('armor-bar').style.width = Math.max(0, state.armor / state.maxArmor * 100) + '%';
  document.getElementById('hud-kills').textContent = state.kills;
  document.getElementById('hud-deaths').textContent = state.deaths;
  document.getElementById('hud-streak').textContent = state.streak;
  document.getElementById('hud-xp').textContent = state.xpThisMatch;
  document.getElementById('hud-player-name').textContent = state.userName;

  var currentXP = state.totalXP + state.xpThisMatch;
  var rank = getRank(currentXP);
  document.getElementById('hud-rank').textContent = rank.name.toUpperCase();
  document.getElementById('hud-rank').style.color = rank.color;

  // Rank progress bar
  var nextRank = getNextRank(currentXP);
  if (nextRank) {
    var progress = (currentXP - rank.xp) / (nextRank.xp - rank.xp) * 100;
    document.getElementById('hud-rank-bar').style.width = Math.min(100, progress) + '%';
    document.getElementById('hud-rank-bar').style.background = rank.color;
  } else {
    document.getElementById('hud-rank-bar').style.width = '100%';
    document.getElementById('hud-rank-bar').style.background = '#fbbf24';
  }

  updateWeaponHUD();
}

function updateWeaponHUD() {
  var w = WEAPONS[state.currentWeapon];
  document.getElementById('hud-ammo-clip').textContent = state.ammoClip[state.currentWeapon];
  document.getElementById('hud-ammo-reserve').textContent = state.ammoReserve[state.currentWeapon];
  document.getElementById('hud-weapon-name').textContent = w.name;
  document.getElementById('hud-weapon-detail').textContent = w.type + ' \u2022 ' + (w.auto ? 'Auto' : 'Semi');
}

function updateTimerHUD() {
  var t = Math.max(0, Math.ceil(state.matchTime));
  var m = Math.floor(t / 60);
  var s = t % 60;
  document.getElementById('hud-timer').textContent = m + ':' + (s < 10 ? '0' : '') + s;

  // Flash when low
  var timerEl = document.getElementById('match-timer');
  if (t <= 30) {
    timerEl.style.borderColor = 'rgba(239,68,68,0.5)';
    document.getElementById('hud-timer').style.color = '#ef4444';
  } else {
    timerEl.style.borderColor = 'rgba(255,255,255,0.08)';
    document.getElementById('hud-timer').style.color = '#fff';
  }
}

//  KILL FEED 
function addKillFeed(killer, victim) {
  var feed = document.getElementById('kill-feed');
  var entry = document.createElement('div');
  entry.className = 'kill-entry';
  entry.innerHTML = '<span class="killer">' + escHTML(killer) + '</span> eliminated <span class="victim">' + escHTML(victim) + '</span>';
  feed.appendChild(entry);
  setTimeout(function() { entry.style.opacity = '0'; entry.style.transition = 'opacity 0.5s'; setTimeout(function() { entry.remove(); }, 500); }, 5000);

  // Limit entries
  while (feed.children.length > 5) feed.removeChild(feed.firstChild);
}

function escHTML(s) { var d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

//  MATCH END 
function endMatch() {
  // Clean up killcam if active
  if (killcam.active) {
    endKillcam();
  }

  state.matchActive = false;

  // Exit pointer lock
  if (document.exitPointerLock) document.exitPointerLock();

  // Calculate results
  var oldRank = getRank(state.totalXP);
  state.totalXP += state.xpThisMatch;
  state.totalKills += state.kills;
  state.totalDeaths += state.deaths;
  state.gamesPlayed++;
  var newRank = getRank(state.totalXP);

  // Record high score
  state.highScores.push({
    date: new Date().toISOString(),
    kills: state.kills,
    deaths: state.deaths,
    score: state.xpThisMatch,
    bestStreak: state.bestStreak,
    difficulty: state.difficulty
  });
  // Keep top 20
  state.highScores.sort(function(a, b) { return b.score - a.score; });
  state.highScores = state.highScores.slice(0, 20);

  savePersistentState();

  // Update end screen
  document.getElementById('end-kills').textContent = state.kills;
  document.getElementById('end-deaths').textContent = state.deaths;
  document.getElementById('end-best-streak').textContent = state.bestStreak;
  document.getElementById('end-xp').textContent = state.xpThisMatch;

  var kd = state.deaths > 0 ? (state.kills / state.deaths).toFixed(2) : state.kills;
  document.getElementById('end-subtitle').textContent = 'K/D Ratio: ' + kd + ' | Difficulty: ' + state.difficulty.charAt(0).toUpperCase() + state.difficulty.slice(1);

  // Rank up check
  var rankUpEl = document.getElementById('end-rank-up');
  if (newRank.name !== oldRank.name) {
    rankUpEl.innerHTML = '<div class="rank-up-badge">RANK UP! ' + newRank.name.toUpperCase() + ' ' + newRank.icon + '</div>';
  } else {
    var nextRank = getNextRank(state.totalXP);
    if (nextRank) {
      rankUpEl.innerHTML = '<div style="color:#666;font-size:12px;">Next rank: ' + nextRank.name + ' (' + (nextRank.xp - state.totalXP) + ' XP needed)</div>';
    } else {
      rankUpEl.innerHTML = '<div style="color:#fbbf24;font-size:12px;">MAX RANK ACHIEVED!</div>';
    }
  }

  document.getElementById('match-end').classList.add('active');
}

//  PAUSE / RESUME 
function togglePause() {
  state.paused = !state.paused;
  document.getElementById('pause-menu').classList.toggle('active', state.paused);
  if (state.paused) {
    if (document.exitPointerLock) document.exitPointerLock();
    // Update difficulty buttons
    document.querySelectorAll('.diff-btn').forEach(function(btn) {
      btn.classList.toggle('active', btn.dataset.diff === state.difficulty);
    });
  }
}

window.resumeGame = function() {
  state.paused = false;
  document.getElementById('pause-menu').classList.remove('active');
  var canvas = document.getElementById('game-canvas');
  if (canvas.requestPointerLock) canvas.requestPointerLock();
};

window.setDifficulty = function(diff) {
  state.difficulty = diff;
  savePersistentState();
  document.querySelectorAll('.diff-btn').forEach(function(btn) {
    btn.classList.toggle('active', btn.dataset.diff === diff);
  });
};

window.restartMatch = function() {
  // Close all overlays
  document.getElementById('match-end').classList.remove('active');
  document.getElementById('pause-menu').classList.remove('active');
  document.getElementById('highscores-panel').classList.remove('active');
  document.getElementById('customize-panel').classList.remove('active');

  // Reset match state
  state.kills = 0;
  state.deaths = 0;
  state.streak = 0;
  state.bestStreak = 0;
  state.xpThisMatch = 0;
  state.health = state.maxHealth;
  state.armor = 50;
  state.matchTime = MATCH_DURATION;
  state.matchActive = true;
  state.paused = false;
  state.grenades = 3;
  state.screenShake = 0;
  state.viewPunchX = 0;
  state.viewPunchY = 0;
  state.crosshairSpread = 0;
  replayBuffer = [];
  replayShots = [];
  replayRecordAccum = 0;
  document.getElementById('hud-grenades').textContent = state.grenades;
  document.getElementById('low-health-overlay').classList.remove('active');

  // Reset ammo
  WEAPONS.forEach(function(w, i) {
    state.ammoClip[i] = w.clipSize;
    state.ammoReserve[i] = w.reserve;
  });

  // Respawn bots
  spawnBots();

  // Reset pickups
  state.pickups.forEach(function(p) {
    p.active = true;
    p.mesh.visible = true;
  });

  // Random spawn
  var pos = getRandomSpawn();
  camera.position.set(pos.x, PLAYER_HEIGHT, pos.z);
  state.velocity.set(0, 0, 0);

  updateHUD();

  var canvas = document.getElementById('game-canvas');
  if (canvas.requestPointerLock) canvas.requestPointerLock();

  showToast('NEW MATCH - GO!');
};

//  WEAPON WHEEL 
function showWeaponWheel() {
  var wheel = document.getElementById('weapon-wheel');
  wheel.classList.add('active');
  var ring = document.getElementById('weapon-ring');
  ring.innerHTML = '';

  var radius = 140;
  WEAPONS.forEach(function(w, i) {
    var angle = ((i / WEAPONS.length) * Math.PI * 2) - Math.PI / 2;
    var x = radius * Math.cos(angle) + 160;
    var y = radius * Math.sin(angle) + 160;

    var slot = document.createElement('div');
    slot.className = 'weapon-slot' + (i === state.currentWeapon ? ' selected' : '');
    slot.style.left = x + 'px';
    slot.style.top = y + 'px';
    slot.innerHTML = '<div class="w-icon">' + w.icon + '</div><div class="w-name">' + w.name + '</div><div class="w-key">[' + w.key + ']</div>';
    slot.onclick = function() { switchWeapon(i); hideWeaponWheel(); };
    ring.appendChild(slot);
  });

  if (document.exitPointerLock) document.exitPointerLock();
}

function hideWeaponWheel() {
  document.getElementById('weapon-wheel').classList.remove('active');
}

//  HIGH SCORES 
window.showHighscores = function() {
  var panel = document.getElementById('highscores-panel');
  panel.classList.add('active');

  // My rank
  var rank = getRank(state.totalXP);
  var nextRank = getNextRank(state.totalXP);
  var myRankEl = document.getElementById('hs-my-rank');
  myRankEl.innerHTML = '<div style="font-size:24px;font-weight:800;color:' + rank.color + '">' + rank.icon + ' ' + rank.name + '</div>' +
    '<div style="font-size:13px;color:#94a3b8;margin-top:4px;">Total XP: ' + state.totalXP + ' | Games: ' + state.gamesPlayed + ' | Kills: ' + state.totalKills + ' | Deaths: ' + state.totalDeaths + '</div>' +
    (nextRank ? '<div style="font-size:11px;color:#666;margin-top:4px;">Next: ' + nextRank.name + ' (' + (nextRank.xp - state.totalXP) + ' XP needed)</div>' :
      '<div style="font-size:11px;color:#fbbf24;margin-top:4px;">MAX RANK!</div>');

  // High scores table
  var tbody = document.getElementById('hs-tbody');
  tbody.innerHTML = '';

  // Add player scores + simulated bot scores
  var allScores = [];

  // Player's actual high scores
  state.highScores.forEach(function(hs) {
    allScores.push({
      name: state.userName,
      rank: getRank(state.totalXP).name,
      score: hs.score,
      kills: hs.kills,
      kd: hs.deaths > 0 ? (hs.kills / hs.deaths).toFixed(1) : hs.kills.toString(),
      isPlayer: true
    });
  });

  // Add simulated bot high scores
  BOT_NAMES.slice(0, 10).forEach(function(name) {
    var botXP = Math.floor(Math.random() * 8000);
    var botKills = 5 + Math.floor(Math.random() * 25);
    var botDeaths = 3 + Math.floor(Math.random() * 15);
    allScores.push({
      name: name,
      rank: getRank(botXP).name,
      score: 50 + Math.floor(Math.random() * 200),
      kills: botKills,
      kd: (botKills / botDeaths).toFixed(1),
      isPlayer: false
    });
  });

  allScores.sort(function(a, b) { return b.score - a.score; });
  allScores = allScores.slice(0, 15);

  allScores.forEach(function(hs, i) {
    var tr = document.createElement('tr');
    var rankClass = i === 0 ? 'hs-gold' : i === 1 ? 'hs-silver' : i === 2 ? 'hs-bronze' : '';
    tr.style.color = hs.isPlayer ? '#a855f7' : '#ccc';
    tr.innerHTML = '<td class="hs-rank-col ' + rankClass + '">' + (i + 1) + '</td>' +
      '<td>' + escHTML(hs.name) + (hs.isPlayer ? ' (You)' : '') + '</td>' +
      '<td>' + hs.rank + '</td>' +
      '<td style="font-weight:700">' + hs.score + '</td>' +
      '<td>' + hs.kills + '</td>' +
      '<td>' + hs.kd + '</td>';
    tbody.appendChild(tr);
  });
};

window.closeHighscores = function() {
  document.getElementById('highscores-panel').classList.remove('active');
};

//  WEAPON CUSTOMIZE 
window.showCustomize = function() {
  var panel = document.getElementById('customize-panel');
  panel.classList.add('active');

  var grid = document.getElementById('cust-weapons-grid');
  grid.innerHTML = '';

  WEAPONS.forEach(function(w, wIdx) {
    var card = document.createElement('div');
    card.className = 'cust-weapon' + (wIdx === state.currentWeapon ? ' selected' : '');

    var stats = [
      { label: 'Damage', value: w.damage, max: 150 },
      { label: 'Fire Rate', value: w.fireRate, max: 15 },
      { label: 'Accuracy', value: w.accuracy, max: 100 },
      { label: 'Range', value: w.range, max: 100 },
      { label: 'Clip Size', value: w.clipSize, max: 30 }
    ];

    var statsHTML = stats.map(function(s) {
      var pct = (s.value / s.max * 100);
      return '<div class="cust-stat"><span class="cs-lbl">' + s.label + '</span><div class="cs-bar"><div class="cs-fill" style="width:' + pct + '%"></div></div><span class="cs-val">' + s.value + '</span></div>';
    }).join('');

    var skinsHTML = '<div class="skin-row">' + w.skins.map(function(skin, sIdx) {
      var isActive = (state.weaponSkins[w.id] || 0) === sIdx;
      return '<div class="skin-chip' + (isActive ? ' active' : '') + '" style="background:' + skin.color + '" title="' + skin.name + '" data-weapon="' + w.id + '" data-skin="' + sIdx + '"></div>';
    }).join('') + '</div>';

    card.innerHTML =
      '<div class="cw-header"><span class="cw-icon">' + w.icon + '</span><span class="cw-name">' + w.name + '</span></div>' +
      '<div class="cw-type">' + w.type + ' [' + w.key + ']</div>' +
      statsHTML +
      '<div style="font-size:11px;color:#666;margin-top:8px;">Skin:</div>' +
      skinsHTML;

    grid.appendChild(card);
  });

  // Skin click handlers
  grid.querySelectorAll('.skin-chip').forEach(function(chip) {
    chip.addEventListener('click', function() {
      var weaponId = chip.dataset.weapon;
      var skinIdx = parseInt(chip.dataset.skin);
      state.weaponSkins[weaponId] = skinIdx;
      savePersistentState();
      // Update active state
      chip.closest('.skin-row').querySelectorAll('.skin-chip').forEach(function(c) { c.classList.remove('active'); });
      chip.classList.add('active');
    });
  });
};

window.closeCustomize = function() {
  document.getElementById('customize-panel').classList.remove('active');
};

//  TOAST NOTIFICATION 
function showToast(text) {
  var toast = document.createElement('div');
  toast.className = 'game-toast';
  toast.textContent = text;
  document.body.appendChild(toast);
  setTimeout(function() { toast.remove(); }, 2000);
}

// =============================================================================
// MULTIPLAYER CLIENT MODULE
// =============================================================================
var MP = {
  socket: null,
  connected: false,
  roomId: null,
  playerId: null,
  isHost: false,
  gameMode: 'solo',
  remotePlayers: {},
  serverUrl: (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.hostname + ':3003',
  lobbyDifficulty: 'normal'
};

//  MP: Connect to Server 
function mpConnect() {
  if (MP.socket && MP.socket.connected) return;
  if (typeof io === 'undefined') { console.warn('[MP] Socket.io not loaded'); return; }

  try {
    MP.socket = io(MP.serverUrl, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 2000,
      timeout: 10000
    });

    MP.socket.on('connect', function() {
      MP.connected = true;
      updateMPStatus('connected', 'Online');
    });

    MP.socket.on('disconnect', function() {
      MP.connected = false;
      updateMPStatus('disconnected', 'Disconnected');
    });

    MP.socket.on('connect_error', function() {
      MP.connected = false;
      updateMPStatus('disconnected', 'Server unavailable');
    });

    // Room events
    MP.socket.on('room_created', function(data) {
      MP.roomId = data.roomId;
      MP.playerId = data.playerId;
      MP.isHost = true;
      showWaitingRoom(data.room);
      if (MP.gameMode === 'quickmatch') {
        setTimeout(function() {
          if (MP.roomId && MP.isHost) startMultiplayerMatch();
        }, 3000);
      }
    });

    MP.socket.on('room_joined', function(data) {
      MP.roomId = data.roomId;
      MP.playerId = data.playerId;
      MP.isHost = false;
      if (data.room.state === 'playing') {
        startMultiplayerGame(data);
      } else {
        showWaitingRoom(data.room);
      }
    });

    MP.socket.on('player_joined', function(data) {
      addChatMessage(null, data.player.name + ' joined the arena', true);
      if (MP.roomId) refreshWaitingRoom();
      if (state.gameStarted) createRemotePlayerMesh(data.player);
    });

    MP.socket.on('player_left', function(data) {
      addChatMessage(null, data.playerName + ' left the arena', true);
      removeRemotePlayer(data.playerId);
      if (MP.roomId && !state.gameStarted) refreshWaitingRoom();
    });

    MP.socket.on('host_changed', function(data) {
      addChatMessage(null, data.newHostName + ' is now the host', true);
      if (data.newHostId === MP.playerId) MP.isHost = true;
      if (!state.gameStarted) refreshWaitingRoom();
    });

    // Match events
    MP.socket.on('match_started', function(data) {
      startMultiplayerGame(data);
    });

    MP.socket.on('game_state', function(data) {
      handleGameState(data);
    });

    MP.socket.on('hit_confirmed', function(data) {
      showHitmarker();
      if (data.headshot) showToast('HEADSHOT!');
    });

    MP.socket.on('player_damaged', function(data) {
      if (data.targetId === MP.playerId) {
        state.health = data.health;
        state.armor = data.armor;
        var overlay = document.getElementById('damage-overlay');
        overlay.classList.add('hit');
        setTimeout(function() { overlay.classList.remove('hit'); }, 200);
        if (state.health <= 0) {
          state.health = 0;
          showToast('YOU DIED! Respawning...');
        }
        updateHUD();
      }
    });

    MP.socket.on('player_killed', function(data) {
      addKillFeed(data.killerName, data.victimName);
      if (data.pvp) addChatMessage(null, data.killerName + ' fragged ' + data.victimName + (data.headshot ? ' (HEADSHOT)' : ''), true);
      if (data.victimId === MP.playerId) {
        state.deaths++;
        state.streak = 0;
      }
      if (data.killerId === MP.playerId) {
        state.kills++;
        state.streak = data.killerStreak;
        if (state.streak > state.bestStreak) state.bestStreak = state.streak;
        state.xpThisMatch += data.xpGain;
        if (state.streak === 3) showToast('TRIPLE KILL!');
        else if (state.streak === 5) showToast('KILLING SPREE!');
        else if (state.streak === 8) showToast('UNSTOPPABLE!');
        else if (state.streak === 10) showToast('GODLIKE!');
      }
      updateHUD();
    });

    MP.socket.on('player_respawned', function(data) {
      if (data.playerId === MP.playerId) {
        camera.position.set(data.position.x, data.position.y || PLAYER_HEIGHT, data.position.z);
        state.health = data.health;
        state.armor = data.armor;
        state.velocity.set(0, 0, 0);
        WEAPONS.forEach(function(w, i) {
          state.ammoClip[i] = w.clipSize;
          state.ammoReserve[i] = w.reserve;
        });
        updateHUD();
      }
    });

    MP.socket.on('match_ended', function(data) {
      state.matchActive = false;
      if (document.exitPointerLock) document.exitPointerLock();
      showMultiplayerEndScreen(data);
    });

    MP.socket.on('game_chat', function(data) {
      addChatMessage(data.playerName, data.message, false);
    });

    MP.socket.on('error', function(data) {
      showToast('Server: ' + data.message);
    });

  } catch(e) {
    console.warn('[MP] Failed to connect:', e);
    updateMPStatus('disconnected', 'Connection failed');
  }
}

function updateMPStatus(statusCls, text) {
  var dot = document.getElementById('mp-dot');
  var textEl = document.getElementById('mp-status-text');
  if (dot) dot.className = 'mp-dot ' + statusCls;
  if (textEl) textEl.textContent = text;
}

//  MP: Game Mode Selection 
window.selectGameMode = function(mode) {
  MP.gameMode = mode;
  document.querySelectorAll('.lobby-mode-btn').forEach(function(b) {
    b.classList.toggle('selected', b.dataset.mode === mode);
  });
  document.getElementById('solo-options').style.display = mode === 'solo' ? 'block' : 'none';
  document.getElementById('mp-options').style.display = mode === 'multiplayer' ? 'block' : 'none';
  document.getElementById('qm-options').style.display = mode === 'quickmatch' ? 'block' : 'none';
  document.getElementById('mp-waiting').style.display = 'none';
  if (mode === 'multiplayer' || mode === 'quickmatch') {
    mpConnect();
    if (mode === 'multiplayer') refreshRoomList();
  }
};

window.setLobbyDiff = function(diff) {
  MP.lobbyDifficulty = diff;
  document.querySelectorAll('#solo-options .diff-btn').forEach(function(b) {
    b.classList.toggle('active', b.dataset.diff === diff);
  });
};

window.startSoloGame = function() {
  state.difficulty = MP.lobbyDifficulty;
  document.getElementById('mp-lobby').classList.remove('active');
  document.getElementById('loading-screen').classList.remove('hidden');
  loadPersistentState();
  initGame();
};

//  MP: Room Management 
window.refreshRoomList = function() {
  if (!MP.connected) {
    document.getElementById('mp-room-list').innerHTML = '<div style="text-align:center;color:#ef4444;padding:16px;font-size:13px;">Not connected to server. Retrying...</div>';
    mpConnect();
    return;
  }
  var url = (window.location.protocol === 'https:' ? 'https://' : 'http://') + window.location.hostname + ':3003/api/fps/rooms';
  fetch(url).then(function(r) { return r.json(); }).then(function(data) {
    var list = document.getElementById('mp-room-list');
    if (!data.rooms || data.rooms.length === 0) {
      list.innerHTML = '<div style="text-align:center;color:#475569;padding:20px;font-size:13px;">No active rooms. Create one!</div>';
      return;
    }
    list.innerHTML = data.rooms.map(function(room) {
      return '<div class="lobby-room-item" onclick="joinRoom(\'' + room.id + '\')">' +
        '<div class="room-info"><div class="room-name">' + escHTML(room.name) + '</div>' +
        '<div class="room-meta">' + room.difficulty + ' | ' + room.botCount + ' bots</div></div>' +
        '<div class="room-players">' + room.players + '/' + room.maxPlayers + '</div>' +
        '<div class="room-state ' + room.state + '">' + room.state + '</div></div>';
    }).join('');
  }).catch(function() {
    document.getElementById('mp-room-list').innerHTML = '<div style="text-align:center;color:#ef4444;padding:16px;font-size:13px;">Cannot reach game server</div>';
  });
};

window.joinRoom = function(roomId) {
  if (!MP.connected) return;
  MP.socket.emit('join_room', {
    roomId: roomId,
    userId: state.userId,
    userName: state.userName,
    totalXP: state.totalXP
  });
};

window.createMultiplayerRoom = function() {
  if (!MP.connected) { mpConnect(); return; }
  MP.socket.emit('create_room', {
    userId: state.userId,
    userName: state.userName,
    totalXP: state.totalXP,
    options: { botCount: 4, difficulty: MP.lobbyDifficulty, maxPlayers: 8 }
  });
};

window.startQuickMatch = function() {
  if (!MP.connected) { mpConnect(); setTimeout(startQuickMatch, 2000); return; }
  MP.socket.emit('quick_match', {
    userId: state.userId,
    userName: state.userName,
    totalXP: state.totalXP
  });
};

function showWaitingRoom(room) {
  document.getElementById('solo-options').style.display = 'none';
  document.getElementById('mp-options').style.display = 'none';
  document.getElementById('qm-options').style.display = 'none';
  document.getElementById('mp-waiting').style.display = 'block';
  document.getElementById('mp-room-name').textContent = room.name;
  renderWaitingPlayers(room.players);
  document.getElementById('mp-start-btn').style.display = MP.isHost ? 'block' : 'none';
}

function refreshWaitingRoom() {
  if (!MP.roomId) return;
  var url = (window.location.protocol === 'https:' ? 'https://' : 'http://') + window.location.hostname + ':3003/api/fps/rooms/' + MP.roomId;
  fetch(url).then(function(r) { return r.json(); }).then(function(data) {
    if (data.room) renderWaitingPlayers(data.room.players);
  }).catch(function() {});
}

function renderWaitingPlayers(players) {
  var list = document.getElementById('mp-player-list');
  list.innerHTML = players.map(function(p) {
    var isMe = p.id === MP.playerId;
    var cls = isMe ? ' is-you' : (p.isBot ? ' is-bot' : '');
    return '<div class="lobby-player-item' + cls + '">' +
      '<div class="lp-dot"></div>' +
      '<div class="lp-name">' + escHTML(p.name) + (isMe ? ' (You)' : '') + (p.isBot ? ' [BOT]' : '') + '</div>' +
      '<div class="lp-rank">' + (p.rank || 'Recruit') + '</div></div>';
  }).join('');
  var humanCount = players.filter(function(p) { return !p.isBot; }).length;
  document.getElementById('mp-waiting-msg').textContent = humanCount + ' player(s) in room. ' + (MP.isHost ? 'You can start the match.' : 'Waiting for host...');
  document.getElementById('mp-player-count').textContent = humanCount + ' players';
}

window.startMultiplayerMatch = function() {
  if (!MP.socket || !MP.isHost) return;
  MP.socket.emit('start_match');
};

window.leaveMultiplayerRoom = function() {
  if (MP.socket) MP.socket.emit('leave_room');
  MP.roomId = null;
  MP.playerId = null;
  MP.isHost = false;
  selectGameMode('multiplayer');
};

//  MP: Start Multiplayer Game 
function startMultiplayerGame(data) {
  document.getElementById('mp-lobby').classList.remove('active');
  document.getElementById('loading-screen').classList.remove('hidden');
  document.getElementById('mp-status').style.display = 'flex';
  document.getElementById('game-chat').style.display = 'block';

  if (!state.gameStarted) {
    initGame();
  } else {
    state.kills = 0; state.deaths = 0; state.streak = 0; state.bestStreak = 0; state.xpThisMatch = 0;
    state.health = state.maxHealth; state.armor = 50;
    state.matchTime = data.matchDuration || MATCH_DURATION;
    state.matchActive = true; state.paused = false;
    if (data.spawnPosition) {
      camera.position.set(data.spawnPosition.x, data.spawnPosition.y || PLAYER_HEIGHT, data.spawnPosition.z);
    }
    WEAPONS.forEach(function(w, i) {
      state.ammoClip[i] = w.clipSize; state.ammoReserve[i] = w.reserve;
    });
    document.getElementById('loading-screen').classList.add('hidden');
    document.getElementById('hud').style.display = 'block';
    document.getElementById('back-btn').style.display = 'block';
    updateHUD();
  }

  // Create remote player meshes
  if (data.players) {
    data.players.forEach(function(p) {
      if (p.id !== MP.playerId) createRemotePlayerMesh(p);
    });
  }

  startPositionSync();
  addChatMessage(null, 'Match started! Eliminate all enemies!', true);
}

//  MP: Remote Player Rendering 
function createRemotePlayerMesh(playerData) {
  if (MP.remotePlayers[playerData.id]) return;
  if (!scene) return;

  var group = new THREE.Group();
  var isBot = playerData.isBot;
  var bodyColor = isBot ? 0x666666 : new THREE.Color().setHSL(Math.random(), 0.7, 0.5).getHex();

  var bodyGeo = new THREE.BoxGeometry(0.6, 1.0, 0.4);
  var bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.6 });
  var body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.2;
  body.castShadow = true;
  group.add(body);

  var headGeo = new THREE.SphereGeometry(0.2, 8, 8);
  var headMat = new THREE.MeshStandardMaterial({ color: isBot ? 0xaaaaaa : 0xddccbb, roughness: 0.5 });
  var head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.9;
  head.castShadow = true;
  group.add(head);

  var eyeColor = isBot ? 0xff0000 : 0x3b82f6;
  var eyeGeo = new THREE.SphereGeometry(0.04, 4, 4);
  var eyeMat = new THREE.MeshBasicMaterial({ color: eyeColor });
  var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.07, 1.92, 0.15);
  group.add(leftEye);
  var rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.07, 1.92, 0.15);
  group.add(rightEye);

  // Name tag for human players
  if (!isBot) {
    var canvas2d = document.createElement('canvas');
    canvas2d.width = 256; canvas2d.height = 64;
    var ctx = canvas2d.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, 256, 64);
    ctx.font = 'bold 24px Inter, sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.fillText(playerData.name || 'Player', 128, 40);
    var tex = new THREE.CanvasTexture(canvas2d);
    var tagMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    var tag = new THREE.Sprite(tagMat);
    tag.position.set(0, 2.5, 0);
    tag.scale.set(2, 0.5, 1);
    group.add(tag);
  }

  var gunGeo = new THREE.BoxGeometry(0.08, 0.08, 0.5);
  var gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
  var gun = new THREE.Mesh(gunGeo, gunMat);
  gun.position.set(0.3, 1.1, 0.3);
  group.add(gun);

  var pos = playerData.position || { x: 0, y: 0, z: 0 };
  group.position.set(pos.x, pos.y || 0, pos.z);
  scene.add(group);

  MP.remotePlayers[playerData.id] = {
    mesh: group,
    state: playerData,
    targetPos: new THREE.Vector3(pos.x, pos.y || 0, pos.z),
    targetRot: playerData.rotation || { x: 0, y: 0 }
  };
}

function removeRemotePlayer(playerId) {
  var rp = MP.remotePlayers[playerId];
  if (rp && rp.mesh) scene.remove(rp.mesh);
  delete MP.remotePlayers[playerId];
}

function updateRemotePlayers(dt) {
  Object.keys(MP.remotePlayers).forEach(function(id) {
    var rp = MP.remotePlayers[id];
    if (!rp || !rp.mesh) return;
    rp.mesh.position.lerp(rp.targetPos, Math.min(1, dt * 10));
    var diff2 = (rp.targetRot.y || 0) - rp.mesh.rotation.y;
    while (diff2 > Math.PI) diff2 -= Math.PI * 2;
    while (diff2 < -Math.PI) diff2 += Math.PI * 2;
    rp.mesh.rotation.y += diff2 * Math.min(1, dt * 10);
    rp.mesh.visible = rp.state.alive !== false;
  });
}

//  MP: Position Sync 
var positionSyncInterval = null;

function startPositionSync() {
  if (positionSyncInterval) clearInterval(positionSyncInterval);
  positionSyncInterval = setInterval(function() {
    if (!MP.socket || !MP.connected || !state.matchActive) return;
    MP.socket.emit('player_update', {
      position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
      rotation: { x: state.pitch, y: state.yaw },
      weapon: WEAPONS[state.currentWeapon].id
    });
  }, 50);
}

function stopPositionSync() {
  if (positionSyncInterval) { clearInterval(positionSyncInterval); positionSyncInterval = null; }
}

//  MP: Handle Game State 
function handleGameState(data) {
  if (!state.gameStarted) return;
  state.matchTime = data.matchTime;
  var playerCount = 0;
  data.players.forEach(function(p) {
    if (p.id === MP.playerId) {
      state.kills = p.kills;
      state.deaths = p.deaths;
      return;
    }
    if (!p.isBot) playerCount++;
    if (MP.remotePlayers[p.id]) {
      var rp = MP.remotePlayers[p.id];
      rp.targetPos.set(p.position.x, p.position.y || 0, p.position.z);
      rp.targetRot = p.rotation || { x: 0, y: 0 };
      rp.state = p;
    } else {
      createRemotePlayerMesh(p);
    }
  });
  document.getElementById('mp-player-count').textContent = (playerCount + 1) + ' players';
}

//  MP: Shooting 
function mpFireWeapon() {
  var w = WEAPONS[state.currentWeapon];
  if (state.ammoClip[state.currentWeapon] <= 0) {
    if (state.ammoReserve[state.currentWeapon] > 0) reloadWeapon();
    return;
  }
  state.ammoClip[state.currentWeapon]--;
  state.muzzleFlashTimer = 0.05;
  state.pitch += (w.recoil * 0.001) * (0.5 + Math.random() * 0.5);
  state.yaw += (Math.random() - 0.5) * w.recoil * 0.0005;

  var direction = new THREE.Vector3(0, 0, -1);
  direction.applyEuler(new THREE.Euler(state.pitch, state.yaw, 0, 'YXZ'));
  direction.x += (Math.random() - 0.5) * w.spread;
  direction.y += (Math.random() - 0.5) * w.spread;
  direction.normalize();

  raycaster.set(camera.position, direction);
  raycaster.far = w.range;

  var hitTarget = null;
  var hitDist = Infinity;
  var isHeadshot = false;

  Object.keys(MP.remotePlayers).forEach(function(id) {
    var rp = MP.remotePlayers[id];
    if (!rp || !rp.state || rp.state.alive === false) return;
    var toTarget = new THREE.Vector3().subVectors(rp.mesh.position, camera.position).add(new THREE.Vector3(0, 1.2, 0));
    var dotVal = toTarget.dot(direction);
    if (dotVal < 0) return;
    var closest = direction.clone().multiplyScalar(dotVal);
    var hitDistCheck = closest.distanceTo(toTarget);
    if (hitDistCheck < 0.8) {
      var dist = camera.position.distanceTo(rp.mesh.position);
      if (dist < hitDist && dist <= w.range * 1.2) {
        hitDist = dist;
        hitTarget = rp;
        var hitY = camera.position.y + closest.y;
        var targetHeadY = rp.mesh.position.y + 1.9;
        isHeadshot = Math.abs(hitY - targetHeadY) < 0.3;
      }
    }
  });

  if (hitTarget && MP.socket) {
    MP.socket.emit('shoot', {
      targetId: hitTarget.state.id,
      headshot: isHeadshot,
      hitPosition: { x: camera.position.x, y: camera.position.y, z: camera.position.z }
    });
    showHitmarker();
  }

  if (w.id === 'rocket') {
    var endPos = camera.position.clone().add(direction.clone().multiplyScalar(w.range));
    if (MP.socket) {
      setTimeout(function() {
        MP.socket.emit('rocket_explode', { position: { x: endPos.x, y: endPos.y, z: endPos.z } });
      }, 500);
    }
    createProjectile(camera.position.clone(), direction.clone());
  }

  createTracer(camera.position.clone(), direction.clone(), w.range);
  updateWeaponHUD();
}

//  MP: Chat 
function addChatMessage(name, message, isSystem) {
  var container = document.getElementById('game-chat-messages');
  if (!container) return;
  var el = document.createElement('div');
  el.className = 'chat-msg' + (isSystem ? ' system' : '');
  if (isSystem) { el.textContent = message; }
  else { el.innerHTML = '<span class="chat-name">' + escHTML(name) + ':</span> ' + escHTML(message); }
  container.appendChild(el);
  container.scrollTop = container.scrollHeight;
  while (container.children.length > 50) container.removeChild(container.firstChild);
  setTimeout(function() {
    if (el.parentNode) { el.style.opacity = '0.3'; el.style.transition = 'opacity 2s'; }
  }, 15000);
}

function setupChatInput() {
  var input = document.getElementById('game-chat-input');
  if (!input) return;
  document.addEventListener('keydown', function(e) {
    if (e.code === 'KeyT' && document.activeElement !== input && state.gameStarted && !state.paused) {
      e.preventDefault();
      input.style.display = 'block';
      input.focus();
      return;
    }
    if (e.code === 'Enter' && document.activeElement === input) {
      var msg = input.value.trim();
      if (msg && MP.socket && MP.connected) {
        MP.socket.emit('game_chat', { message: msg });
        addChatMessage(state.userName, msg, false);
      }
      input.value = '';
      input.style.display = 'none';
      input.blur();
      var canvas = document.getElementById('game-canvas');
      if (canvas.requestPointerLock && state.matchActive && !state.paused) canvas.requestPointerLock();
    }
    if (e.code === 'Escape' && document.activeElement === input) {
      input.value = '';
      input.style.display = 'none';
      input.blur();
    }
  });
}

//  MP: End Screen 
function showMultiplayerEndScreen(data) {
  stopPositionSync();

  var oldRank = getRank(state.totalXP);
  state.totalXP += state.xpThisMatch;
  state.totalKills += state.kills;
  state.totalDeaths += state.deaths;
  state.gamesPlayed++;
  var newRank = getRank(state.totalXP);

  state.highScores.push({
    date: new Date().toISOString(),
    kills: state.kills, deaths: state.deaths,
    score: state.xpThisMatch, bestStreak: state.bestStreak,
    difficulty: state.difficulty, multiplayer: true
  });
  state.highScores.sort(function(a, b) { return b.score - a.score; });
  state.highScores = state.highScores.slice(0, 20);
  savePersistentState();

  document.getElementById('end-kills').textContent = state.kills;
  document.getElementById('end-deaths').textContent = state.deaths;
  document.getElementById('end-best-streak').textContent = state.bestStreak;
  document.getElementById('end-xp').textContent = state.xpThisMatch;

  var kd = state.deaths > 0 ? (state.kills / state.deaths).toFixed(2) : state.kills;
  document.getElementById('end-subtitle').textContent = 'K/D: ' + kd + ' | Multiplayer Match';

  var rankUpEl = document.getElementById('end-rank-up');
  if (newRank.name !== oldRank.name) {
    rankUpEl.innerHTML = '<div class="rank-up-badge">RANK UP! ' + newRank.name.toUpperCase() + '</div>';
  } else {
    var nextRank = getNextRank(state.totalXP);
    if (nextRank) {
      rankUpEl.innerHTML = '<div style="color:#666;font-size:12px;">Next rank: ' + nextRank.name + ' (' + (nextRank.xp - state.totalXP) + ' XP needed)</div>';
    } else {
      rankUpEl.innerHTML = '<div style="color:#fbbf24;font-size:12px;">MAX RANK ACHIEVED!</div>';
    }
  }

  if (data.scoreboard && data.scoreboard.length > 0) {
    var sbHTML = '<div style="margin-top:16px;max-height:200px;overflow-y:auto;">' +
      '<table class="hs-table" style="width:100%"><thead><tr><th>#</th><th>Player</th><th>K</th><th>D</th><th>K/D</th><th>XP</th></tr></thead><tbody>';
    data.scoreboard.forEach(function(p, i) {
      var isMe = p.id === MP.playerId;
      sbHTML += '<tr style="color:' + (isMe ? '#6366f1' : p.isBot ? '#64748b' : '#fff') + '">' +
        '<td>' + (i + 1) + '</td><td>' + escHTML(p.name) + (isMe ? ' (You)' : '') + (p.isBot ? ' [BOT]' : '') + '</td>' +
        '<td>' + p.kills + '</td><td>' + p.deaths + '</td><td>' + p.kd + '</td><td>' + (p.xpEarned || 0) + '</td></tr>';
    });
    sbHTML += '</tbody></table></div>';
    rankUpEl.insertAdjacentHTML('afterend', sbHTML);
  }

  document.getElementById('match-end').classList.add('active');
}

//  Override enterGame to show lobby 
var originalEnterGame = enterGame;
enterGame = function() {
  document.getElementById('age-gate').classList.add('hidden');
  loadPersistentState();
  loadSettings();
  if (state.userName === 'Player' && state.gamesPlayed === 0) {
    var n = prompt('Enter your callsign:', 'Player');
    if (n && n.trim()) state.userName = n.trim().substring(0, 20);
    savePersistentState();
  }
  // Populate lobby stats
  var rank = getRank(state.totalXP);
  var rankEl = document.getElementById('lobby-rank-display');
  if (rankEl) { rankEl.textContent = rank.name; rankEl.style.color = rank.color; }
  var xpEl = document.getElementById('lobby-xp-display');
  if (xpEl) xpEl.textContent = state.totalXP.toLocaleString();
  var killsEl = document.getElementById('lobby-kills-display');
  if (killsEl) killsEl.textContent = state.totalKills;
  var gamesEl = document.getElementById('lobby-games-display');
  if (gamesEl) gamesEl.textContent = state.gamesPlayed;
  document.getElementById('mp-lobby').classList.add('active');
  setupChatInput();
};

// Override restartMatch for multiplayer
var originalRestartMatch = window.restartMatch;
window.restartMatch = function() {
  if (MP.roomId && MP.connected) {
    document.getElementById('match-end').classList.remove('active');
    document.getElementById('pause-menu').classList.remove('active');
    Object.keys(MP.remotePlayers).forEach(function(id) { removeRemotePlayer(id); });
    stopPositionSync();
    leaveMultiplayerRoom();
    document.getElementById('mp-lobby').classList.add('active');
  } else {
    originalRestartMatch();
  }
};

//  Patched game loop with multiplayer + premium features 
var _origGameLoopRef = gameLoop;
gameLoop = function() {
  requestAnimationFrame(gameLoop);
  if (!state.gameStarted || state.paused || !state.matchActive) {
    if (renderer && scene && camera) renderer.render(scene, camera);
    return;
  }
  var dt = Math.min(clock.getDelta(), 0.05);

  state.matchTime -= dt;
  if (state.matchTime <= 0 && !MP.roomId) { endMatch(); return; }

  //  Camera Effects 
  // Recoil recovery (smooth return)
  state.viewPunchX *= 0.9;
  state.viewPunchY *= 0.9;
  if (Math.abs(state.viewPunchX) < 0.0001) state.viewPunchX = 0;
  if (Math.abs(state.viewPunchY) < 0.0001) state.viewPunchY = 0;

  // Screen shake
  state.screenShake *= 0.92;
  if (state.screenShake < 0.001) state.screenShake = 0;
  var shakeX = (Math.random() - 0.5) * state.screenShake * 0.05;
  var shakeY = (Math.random() - 0.5) * state.screenShake * 0.05;

  // Weapon sway decay
  state.weaponSwayX *= 0.9;
  state.weaponSwayY *= 0.9;

  // Head bob while moving (respects settings)
  var isMoving = state.keys['KeyW'] || state.keys['KeyS'] || state.keys['KeyA'] || state.keys['KeyD'];
  if (isMoving && state.onGround && state.health > 0 && gameSettings.headbob) {
    var bobSpeed = state.sprinting ? 14 : 8;
    state.headBobTimer += dt * bobSpeed;
    state.headBobAmount = Math.min(state.headBobAmount + dt * 2, state.sprinting ? 0.8 : 0.4);
    // Footstep sounds
    state.footstepTimer -= dt;
    if (state.footstepTimer <= 0) {
      state.footstepTimer = state.sprinting ? 0.3 : 0.5;
      AudioSys.playFootstep(state.sprinting);
    }
  } else {
    state.headBobAmount *= 0.9;
  }
  var bobOffsetX = Math.sin(state.headBobTimer) * state.headBobAmount * 0.015;
  var bobOffsetY = Math.abs(Math.cos(state.headBobTimer)) * state.headBobAmount * 0.01;

  // ADS (Aim Down Sights) smooth transition
  state.adsLerp += (state.ads ? 1 : -1) * dt * 8;
  state.adsLerp = Math.max(0, Math.min(1, state.adsLerp));

  // FOV: sprint increases, ADS decreases
  var targetFov = state.baseFov;
  if (state.sprinting && isMoving) targetFov += 8;
  if (state.ads) targetFov -= 20;
  if (WEAPONS[state.currentWeapon].id === 'sniper' && state.ads) targetFov -= 20; // Extra zoom for sniper
  state.targetFov += (targetFov - state.targetFov) * dt * 8;
  camera.fov = state.targetFov;
  camera.updateProjectionMatrix();

  // Crouch
  state.crouchLerp += (state.crouching ? 1 : -1) * dt * 6;
  state.crouchLerp = Math.max(0, Math.min(1, state.crouchLerp));

  // Apply camera rotation with effects
  camera.rotation.order = 'YXZ';
  camera.rotation.x = state.pitch + state.viewPunchX + shakeY + bobOffsetY;
  camera.rotation.y = state.yaw + state.viewPunchY + shakeX + bobOffsetX;

  // Crosshair spread decay
  state.crosshairSpread *= 0.92;
  if (state.crosshairSpread < 0.5) state.crosshairSpread = 0;

  // Update dynamic crosshair
  updateDynamicCrosshair();

  // Scope overlay for sniper ADS
  var scopeOverlay = document.getElementById('scope-overlay');
  var crosshair = document.getElementById('crosshair');
  if (WEAPONS[state.currentWeapon].id === 'sniper' && state.adsLerp > 0.8) {
    scopeOverlay.classList.add('active');
    crosshair.style.display = 'none';
  } else {
    scopeOverlay.classList.remove('active');
    crosshair.style.display = '';
  }

  //  Player Movement (with crouch modifier) 
  updatePlayerMovement(dt);

  //  Firing 
  state.fireTimer -= dt;
  state.grenadeTimer -= dt;
  if (state.mouseDown && state.fireTimer <= 0 && !state.reloading && state.health > 0) {
    var w = WEAPONS[state.currentWeapon];
    if (w.auto || state.fireTimer <= -0.1) {
      if (MP.roomId) { mpFireWeapon(); } else { fireWeapon(); }
      state.fireTimer = 1 / w.fireRate;
    }
  }

  //  Reload 
  if (state.reloading) {
    state.reloadTimer -= dt;
    if (state.reloadTimer <= 0) {
      var w2 = WEAPONS[state.currentWeapon];
      var needed = w2.clipSize - state.ammoClip[state.currentWeapon];
      var available = Math.min(needed, state.ammoReserve[state.currentWeapon]);
      state.ammoClip[state.currentWeapon] += available;
      state.ammoReserve[state.currentWeapon] -= available;
      state.reloading = false;
      updateWeaponHUD();
    }
  }

  //  Bots & Multiplayer 
  // Spawn protection timer
  if (spawnProtectionTimer > 0) spawnProtectionTimer -= dt;

  if (!MP.roomId) { updateBots(dt); }
  updateRemotePlayers(dt);
  updateProjectiles(dt);
  if (!MP.roomId) {
    updatePickups(dt);
    updateWeaponDrops(dt);
    updateHazardZones(dt);
  }
  updateTimerHUD();
  renderMinimap();

  //  First Person Weapon Viewmodel 
  FPWeapon.render(state.currentWeapon, state.muzzleFlashTimer > 0, state.reloading, state.ads, dt);

  //  Render remote players on minimap 
  if (minimapCtx && MP.roomId) {
    var w3 = 150, scale2 = w3 / ARENA_SIZE;
    Object.keys(MP.remotePlayers).forEach(function(id) {
      var rp = MP.remotePlayers[id];
      if (!rp || !rp.state || !rp.state.alive) return;
      var bx = w3 / 2 + rp.state.position.x * scale2;
      var bz = w3 / 2 + rp.state.position.z * scale2;
      minimapCtx.fillStyle = rp.state.isBot ? '#ef4444' : '#6366f1';
      minimapCtx.beginPath();
      minimapCtx.arc(bx, bz, rp.state.isBot ? 2 : 3, 0, Math.PI * 2);
      minimapCtx.fill();
    });
  }

  renderer.render(scene, camera);
};

//  DYNAMIC CROSSHAIR 
function updateDynamicCrosshair() {
  var crosshair = document.getElementById('crosshair');
  if (!crosshair) return;

  var lines = crosshair.querySelectorAll('.crosshair-line');
  var spread = state.crosshairSpread;

  // Base spread from movement
  if (state.sprinting) spread += 15;
  else if (state.keys['KeyW'] || state.keys['KeyS'] || state.keys['KeyA'] || state.keys['KeyD']) spread += 5;
  if (state.crouching) spread -= 3;
  if (state.ads) spread -= 5;
  spread = Math.max(0, spread);

  // Color based on state and settings
  var color = gameSettings.crosshairColor || 'rgba(255,255,255,0.7)';
  if (state.ads) color = 'rgba(255,100,100,0.9)';

  lines.forEach(function(line) {
    line.style.background = color;
    if (line.classList.contains('top')) line.style.top = (-18 - spread) + 'px';
    else if (line.classList.contains('bottom')) line.style.bottom = (-18 - spread) + 'px';
    else if (line.classList.contains('left')) line.style.left = (-18 - spread) + 'px';
    else if (line.classList.contains('right')) line.style.right = (-18 - spread) + 'px';
  });

  // Dot color
  var dot = crosshair.querySelector('.crosshair-dot');
  if (dot) dot.style.background = color;
}

//  INIT 
checkAuth();

})();
</script>

<!-- VR Navigation Menu -->
<script src="/vr/nav-menu.js"></script>
</body>
</html>
