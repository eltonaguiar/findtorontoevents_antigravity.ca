<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tic-Tac-Toe VR - Game Arena | Toronto Events</title>
  <script src="/vr/https-redirect.js"></script>
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>

  <script>
    AFRAME.registerComponent('look-at-camera', {
      tick: function () {
        var cam = this.el.sceneEl.camera;
        if (cam) this.el.object3D.lookAt(cam.getWorldPosition(new THREE.Vector3()));
      }
    });
  </script>

  <style>
    body { margin: 0; overflow: hidden; font-family: 'Inter', -apple-system, sans-serif; }
    #loading {
      position: fixed; inset: 0;
      background: linear-gradient(135deg, #0a0a1f 0%, #1a0a2e 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 9999; color: white; transition: opacity 0.5s;
    }
    #loading h1 {
      font-size: 2.5rem; margin-bottom: 0.5rem;
      background: linear-gradient(90deg, #6366f1, #a855f7);
      background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    #loading p { color: #888; font-size: 1.1rem; }
    .spinner {
      width: 60px; height: 60px; border: 4px solid rgba(99,102,241,0.3);
      border-top-color: #6366f1; border-radius: 50%;
      animation: spin 1s linear infinite; margin-bottom: 1.5rem;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .hidden { display: none !important; }

    /* HUD */
    #hud {
      position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
      z-index: 200; display: flex; gap: 12px; align-items: center;
    }
    .hud-card {
      background: rgba(10,10,30,0.88); backdrop-filter: blur(10px);
      border: 1px solid rgba(99,102,241,0.4); border-radius: 14px;
      padding: 10px 20px; color: white; text-align: center; font-size: 14px;
    }
    .hud-card.player-x { border-color: rgba(99,102,241,0.6); }
    .hud-card.player-o { border-color: rgba(236,72,153,0.6); }
    .hud-card.active { box-shadow: 0 0 20px rgba(99,102,241,0.4); }
    .hud-card h3 { margin: 0; font-size: 13px; }
    .hud-card .mark { font-size: 28px; font-weight: 800; }
    .hud-card .mark.x { color: #6366f1; }
    .hud-card .mark.o { color: #ec4899; }
    .hud-vs { font-size: 18px; font-weight: 800; color: #666; }
    #hud-status {
      position: fixed; top: 90px; left: 50%; transform: translateX(-50%);
      z-index: 200; background: rgba(10,10,30,0.88); backdrop-filter: blur(10px);
      border: 1px solid rgba(168,85,247,0.3); border-radius: 12px;
      padding: 8px 24px; color: #a855f7; font-size: 15px; font-weight: 600;
      text-align: center; transition: all 0.3s;
    }

    /* Buttons */
    .btn-bar {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      z-index: 200; display: flex; gap: 10px;
    }
    .btn {
      padding: 10px 20px; border-radius: 10px; font-size: 13px; font-weight: 600;
      cursor: pointer; border: none; transition: all 0.2s; color: white;
    }
    .btn-primary { background: linear-gradient(135deg, #6366f1, #a855f7); }
    .btn-primary:hover { box-shadow: 0 4px 15px rgba(99,102,241,0.4); transform: translateY(-1px); }
    .btn-danger { background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.4); color: #ef4444; }
    .btn-danger:hover { background: rgba(239,68,68,0.3); }
    .btn-secondary { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); }
    .btn-secondary:hover { background: rgba(255,255,255,0.12); }

    /* Win overlay */
    #win-overlay {
      position: fixed; inset: 0; z-index: 300;
      background: rgba(0,0,0,0.7); backdrop-filter: blur(6px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; opacity: 0; pointer-events: none; transition: opacity 0.4s;
    }
    #win-overlay.active { opacity: 1; pointer-events: all; }
    #win-overlay h1 { font-size: 3rem; margin-bottom: 0.5rem; }
    #win-overlay p { font-size: 1.2rem; color: #aaa; margin-bottom: 1.5rem; }
    #win-overlay .btn-bar { position: static; transform: none; }

    /* Mode select overlay */
    #mode-select {
      position: fixed; inset: 0; z-index: 250;
      background: rgba(5,5,20,0.92); backdrop-filter: blur(12px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; gap: 18px; transition: opacity 0.3s;
    }
    #mode-select.hidden { display: none; }
    #mode-select h1 {
      font-size: 2.2rem; font-weight: 900;
      background: linear-gradient(90deg, #6366f1, #ec4899);
      background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    #mode-select p { color: #888; font-size: 1rem; max-width: 380px; text-align: center; line-height: 1.5; }
    .mode-btns { display: flex; gap: 14px; flex-wrap: wrap; justify-content: center; }
    .mode-btn {
      padding: 16px 32px; border-radius: 14px; font-size: 16px; font-weight: 700;
      cursor: pointer; border: 2px solid transparent; transition: all 0.2s;
      display: flex; flex-direction: column; align-items: center; gap: 4px; min-width: 160px;
    }
    .mode-btn:hover { transform: translateY(-2px); }
    .mode-btn .mode-icon { font-size: 28px; }
    .mode-btn .mode-sub { font-size: 11px; font-weight: 400; opacity: 0.7; }
    .mode-btn-human {
      background: linear-gradient(135deg, #22c55e, #10b981); color: #fff;
      border-color: rgba(34,197,94,0.5); box-shadow: 0 4px 20px rgba(34,197,94,0.3);
    }
    .mode-btn-human:hover { box-shadow: 0 6px 30px rgba(34,197,94,0.5); }
    .mode-btn-ai {
      background: rgba(99,102,241,0.15); color: #a5b4fc;
      border-color: rgba(99,102,241,0.4);
    }
    .mode-btn-ai:hover { background: rgba(99,102,241,0.25); }
    #queue-status {
      display: none; text-align: center; padding: 12px 24px;
      background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.3);
      border-radius: 12px; font-size: 14px; color: #86efac;
    }
    #queue-status .queue-dot {
      display: inline-block; width: 8px; height: 8px; border-radius: 50%;
      background: #22c55e; margin-right: 8px;
      animation: pulse-dot 1s ease-in-out infinite;
    }
    @keyframes pulse-dot { 0%,100% { opacity:1; } 50% { opacity:0.3; } }
    #queue-cancel { margin-top: 8px; background: none; border: 1px solid rgba(255,255,255,0.2);
      color: #888; padding: 6px 16px; border-radius: 8px; cursor: pointer; font-size: 12px; }
    #queue-cancel:hover { color: #fff; border-color: rgba(255,255,255,0.4); }
    #online-count { color: #64748b; font-size: 12px; }

    /* Toast */
    #toast-container {
      position: fixed; top: 130px; right: 16px; z-index: 9000;
      display: flex; flex-direction: column; gap: 8px; max-width: 300px;
    }
    .toast {
      background: rgba(10,10,30,0.9); border: 1px solid rgba(99,102,241,0.5);
      border-radius: 12px; padding: 12px 16px; color: white;
      animation: toastIn 0.3s ease-out; font-size: 13px;
    }
    @keyframes toastIn { from { transform: translateX(100%); opacity: 0; } }
    .toast-title { font-weight: 700; margin-bottom: 2px; }
    .toast-msg { color: #aaa; font-size: 12px; }
    .toast-actions { display: flex; gap: 6px; margin-top: 8px; }
    .toast-btn { padding: 4px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; border: none; }
    .toast-btn.accept { background: #22c55e; color: white; }
    .toast-btn.decline { background: rgba(255,255,255,0.1); color: #aaa; }

    /* ═══ Chat Panel ═══ */
    #chat-panel {
      position: fixed; right: 16px; top: 50%; transform: translateY(-50%);
      width: 310px; max-height: 460px; z-index: 260;
      background: rgba(10,10,30,0.95); backdrop-filter: blur(12px);
      border: 1px solid rgba(99,102,241,0.4); border-radius: 16px;
      display: none; flex-direction: column; overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    #chat-panel.open { display: flex; }
    .chat-header {
      padding: 10px 14px; display: flex; justify-content: space-between; align-items: center;
      border-bottom: 1px solid rgba(99,102,241,0.2); color: white; font-weight: 700; font-size: 14px;
      flex-shrink: 0;
    }
    .chat-header-left { display: flex; align-items: center; gap: 8px; }
    .chat-header button { background: none; border: none; color: #888; cursor: pointer; font-size: 16px; }
    .chat-header button:hover { color: #fff; }
    .chat-spec-count {
      font-size: 11px; font-weight: 400; color: #f59e0b;
      background: rgba(245,158,11,0.15); padding: 2px 8px; border-radius: 10px;
    }
    .chat-spectators-bar {
      padding: 6px 14px; border-bottom: 1px solid rgba(99,102,241,0.15);
      font-size: 11px; color: #888; flex-shrink: 0; max-height: 80px; overflow-y: auto;
    }
    .spec-item {
      display: flex; justify-content: space-between; align-items: center; padding: 3px 0;
    }
    .spec-name { color: #f59e0b; }
    .spec-badge { font-size: 10px; color: #64748b; }
    .spec-badge.approved { color: #22c55e; }
    .spec-approve-btn {
      background: #22c55e; border: none; color: white; padding: 2px 10px;
      border-radius: 4px; font-size: 10px; cursor: pointer; font-weight: 600;
    }
    .spec-approve-btn:hover { background: #16a34a; }
    #chat-messages {
      flex: 1; overflow-y: auto; padding: 10px 14px;
      display: flex; flex-direction: column; gap: 6px;
      min-height: 120px;
    }
    .chat-msg { font-size: 12px; line-height: 1.4; word-break: break-word; }
    .chat-msg .chat-name { font-weight: 700; margin-right: 4px; }
    .chat-msg .chat-name.player { color: #6366f1; }
    .chat-msg .chat-name.spectator { color: #f59e0b; }
    .chat-msg .chat-name.system { color: #64748b; }
    .chat-msg .chat-text { color: #ccc; }
    .chat-msg.system-msg { color: #64748b; font-style: italic; font-size: 11px; }
    #chat-input-area {
      display: flex; gap: 6px; padding: 8px 12px;
      border-top: 1px solid rgba(99,102,241,0.2); flex-shrink: 0;
    }
    #chat-input {
      flex: 1; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px; padding: 7px 10px; color: white; font-size: 12px; outline: none;
      font-family: inherit;
    }
    #chat-input:focus { border-color: rgba(99,102,241,0.5); }
    #chat-send-btn {
      padding: 7px 14px; background: linear-gradient(135deg, #6366f1, #a855f7);
      border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; font-size: 12px;
    }
    #chat-send-btn:hover { box-shadow: 0 2px 10px rgba(99,102,241,0.4); }
    #chat-request-area {
      display: none; padding: 8px 12px; border-top: 1px solid rgba(99,102,241,0.2);
      text-align: center; flex-shrink: 0;
    }
    #chat-request-btn {
      background: rgba(245,158,11,0.2); border: 1px solid rgba(245,158,11,0.4);
      color: #f59e0b; padding: 7px 18px; border-radius: 8px; cursor: pointer;
      font-weight: 600; font-size: 12px; width: 100%;
    }
    #chat-request-btn:hover { background: rgba(245,158,11,0.3); }
    #chat-request-btn:disabled { opacity: 0.5; cursor: default; }
    #chat-request-status { display: block; margin-top: 4px; color: #888; font-size: 11px; }

    /* Chat toggle floating button */
    #chat-toggle-btn {
      position: fixed; right: 16px; bottom: 80px; z-index: 260;
      width: 48px; height: 48px; border-radius: 50%;
      background: linear-gradient(135deg, #6366f1, #a855f7);
      border: none; color: white; font-size: 20px; cursor: pointer;
      box-shadow: 0 4px 15px rgba(99,102,241,0.4);
      display: none; align-items: center; justify-content: center;
      transition: transform 0.2s;
    }
    #chat-toggle-btn:hover { transform: scale(1.1); }
    #chat-toggle-btn.has-new {
      animation: chatPulse 0.6s ease-in-out;
    }
    @keyframes chatPulse { 0%,100% { box-shadow: 0 4px 15px rgba(99,102,241,0.4); } 50% { box-shadow: 0 4px 25px rgba(236,72,153,0.7); } }
    #chat-unread {
      position: absolute; top: -4px; right: -4px; width: 18px; height: 18px;
      background: #ef4444; border-radius: 50%; font-size: 10px; font-weight: 700;
      display: none; align-items: center; justify-content: center; line-height: 18px;
    }

    /* Spectator badge */
    #spectator-badge {
      position: fixed; top: 90px; right: 16px; z-index: 200;
      background: rgba(10,10,30,0.88); backdrop-filter: blur(10px);
      border: 1px solid rgba(245,158,11,0.3); border-radius: 10px;
      padding: 6px 14px; color: #f59e0b; font-size: 13px; font-weight: 600;
      display: none;
    }

    /* Watch mode button */
    .mode-btn-watch {
      background: rgba(245,158,11,0.15); color: #fbbf24;
      border-color: rgba(245,158,11,0.4);
    }
    .mode-btn-watch:hover { background: rgba(245,158,11,0.25); box-shadow: 0 4px 20px rgba(245,158,11,0.3); }

    /* Active games list */
    #active-games-list {
      display: none; width: 100%; max-width: 500px; text-align: center;
    }
    #active-games-list h3 { color: #f59e0b; font-size: 1.1rem; margin-bottom: 12px; }
    .game-card {
      background: rgba(255,255,255,0.05); border: 1px solid rgba(99,102,241,0.3);
      border-radius: 12px; padding: 14px 20px; margin: 8px auto;
      display: flex; justify-content: space-between; align-items: center;
      cursor: pointer; transition: all 0.2s; max-width: 420px; text-align: left;
    }
    .game-card:hover { background: rgba(99,102,241,0.15); border-color: rgba(99,102,241,0.5); transform: translateY(-1px); }
    .game-card-players { color: white; font-weight: 600; font-size: 14px; }
    .game-card-info { color: #888; font-size: 11px; margin-top: 2px; }
    .game-card-watch { color: #f59e0b; font-weight: 700; font-size: 13px; white-space: nowrap; margin-left: 12px; }
    #no-games-msg { color: #64748b; font-size: 14px; padding: 20px; }
    #back-from-watch {
      margin-top: 14px; background: none; border: 1px solid rgba(255,255,255,0.2);
      color: #888; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 13px;
    }
    #back-from-watch:hover { color: #fff; border-color: rgba(255,255,255,0.4); }
  </style>
</head>
<body>

  <div id="loading">
    <div class="spinner"></div>
    <h1>Tic-Tac-Toe</h1>
    <p>Setting up the board...</p>
  </div>

  <!-- Mode Selection Overlay -->
  <div id="mode-select">
    <h1>TIC-TAC-TOE</h1>
    <p>Play against a real human opponent across devices, or challenge the AI.</p>
    <div id="online-count"></div>
    <div class="mode-btns">
      <button class="mode-btn mode-btn-human" onclick="startHumanQueue()">
        <span class="mode-icon">&#x1F91C;</span>
        FIND HUMAN
        <span class="mode-sub">Cross-device matchmaking</span>
      </button>
      <button class="mode-btn mode-btn-ai" onclick="startAIMode()">
        <span class="mode-icon">&#x1F916;</span>
        PLAY vs AI
        <span class="mode-sub">Practice offline</span>
      </button>
      <button class="mode-btn mode-btn-watch" onclick="startWatchMode()">
        <span class="mode-icon">&#x1F441;</span>
        WATCH A GAME
        <span class="mode-sub">Spectate live matches</span>
      </button>
    </div>
    <div id="active-games-list">
      <h3>&#x1F3AE; Live Games</h3>
      <div id="games-list-inner"></div>
      <div id="no-games-msg" style="display:none;">No active games right now. Check back soon!</div>
      <button id="back-from-watch" onclick="cancelWatch()">&#x2190; Back</button>
    </div>
    <div id="queue-status">
      <span class="queue-dot"></span>
      <span id="queue-text">Searching for opponent...</span>
    </div>
    <button id="queue-cancel" style="display:none;" onclick="cancelQueue()">Cancel Search</button>
  </div>

  <!-- HUD -->
  <div id="hud">
    <div class="hud-card player-x active" id="hud-x">
      <div class="mark x">X</div>
      <h3 id="name-x">You</h3>
    </div>
    <div class="hud-vs">VS</div>
    <div class="hud-card player-o" id="hud-o">
      <div class="mark o">O</div>
      <h3 id="name-o">AI</h3>
    </div>
  </div>
  <div id="hud-status">Your turn - Click a cell!</div>

  <!-- Buttons -->
  <div class="btn-bar" id="game-btns">
    <button class="btn btn-primary" onclick="resetGame()">New Game</button>
    <button class="btn btn-danger" onclick="abandonMatch()">Abandon</button>
    <a class="btn btn-secondary" href="/vr/game-arena/">Back to Arena</a>
  </div>

  <!-- Win overlay -->
  <div id="win-overlay">
    <h1 id="win-title">You Win!</h1>
    <p id="win-subtitle">Great game!</p>
    <div class="btn-bar">
      <button class="btn btn-primary" onclick="resetGame()">Play Again</button>
      <a class="btn btn-secondary" href="/vr/game-arena/">Back to Arena</a>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast-container"></div>

  <!-- Spectator badge -->
  <div id="spectator-badge">&#x1F441; <span id="spectator-count">0</span> watching</div>

  <!-- Chat toggle button -->
  <button id="chat-toggle-btn" onclick="toggleChat()">
    &#x1F4AC;
    <span id="chat-unread">0</span>
  </button>

  <!-- Chat Panel -->
  <div id="chat-panel">
    <div class="chat-header">
      <div class="chat-header-left">
        <span>&#x1F4AC; Game Chat</span>
        <span class="chat-spec-count" id="chat-spec-label"></span>
      </div>
      <button onclick="toggleChat()" title="Close chat">&#x2715;</button>
    </div>
    <div class="chat-spectators-bar" id="chat-spectators-bar" style="display:none;"></div>
    <div id="chat-messages"></div>
    <div id="chat-input-area">
      <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200" autocomplete="off" />
      <button id="chat-send-btn" onclick="sendChatMessage()">Send</button>
    </div>
    <div id="chat-request-area">
      <button id="chat-request-btn" onclick="requestChatPermission()">&#x1F64B; Request to Chat</button>
      <span id="chat-request-status"></span>
    </div>
  </div>

  <!-- A-FRAME SCENE -->
  <a-scene
    renderer="antialias: true; colorManagement: true; sortTransparentObjects: true"
    vr-mode-ui="enabled: true"
    loading-screen="enabled: false"
    cursor="rayOrigin: mouse; fuse: false"
    raycaster="objects: .clickable"
  >
    <a-assets></a-assets>

    <a-entity environment="
      preset: starry;
      groundColor: #0a0a1f;
      groundTexture: none;
      dressing: none;
      skyType: atmosphere;
      skyColor: #050510;
      horizonColor: #0a0a2e;
      fog: 0.3"></a-entity>

    <!-- Floor -->
    <a-cylinder position="0 -0.05 0" radius="12" height="0.1" color="#0a0a1f" opacity="0.9"></a-cylinder>
    <a-ring position="0 0.02 0" rotation="-90 0 0" radius-inner="4" radius-outer="4.1" color="#6366f1" opacity="0.4"
            animation="property: rotation; to: -90 360 0; dur: 30000; loop: true; easing: linear"></a-ring>

    <!-- ===== 3D TIC-TAC-TOE BOARD ===== -->
    <a-entity id="ttt-board" position="0 1.5 -3">
      <!-- Board frame - grid lines -->
      <!-- Vertical lines -->
      <a-box position="-0.55 0 0" width="0.06" height="3.4" depth="0.06" color="#6366f1" opacity="0.8"></a-box>
      <a-box position="0.55 0 0" width="0.06" height="3.4" depth="0.06" color="#6366f1" opacity="0.8"></a-box>
      <!-- Horizontal lines -->
      <a-box position="0 -0.55 0" width="3.4" height="0.06" depth="0.06" color="#6366f1" opacity="0.8"></a-box>
      <a-box position="0 0.55 0" width="3.4" height="0.06" depth="0.06" color="#6366f1" opacity="0.8"></a-box>
      <!-- Back panel glow -->
      <a-plane position="0 0 -0.1" width="3.6" height="3.6" color="#0a0a2e" opacity="0.6" material="shader: flat"></a-plane>

      <!-- 9 Clickable cells (row 0 = top, row 2 = bottom) -->
      <!-- Row 0 (top) -->
      <a-plane class="clickable cell" data-cell="0" position="-1.1 1.1 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <a-plane class="clickable cell" data-cell="1" position="0 1.1 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <a-plane class="clickable cell" data-cell="2" position="1.1 1.1 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <!-- Row 1 (mid) -->
      <a-plane class="clickable cell" data-cell="3" position="-1.1 0 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <a-plane class="clickable cell" data-cell="4" position="0 0 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <a-plane class="clickable cell" data-cell="5" position="1.1 0 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <!-- Row 2 (bottom) -->
      <a-plane class="clickable cell" data-cell="6" position="-1.1 -1.1 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <a-plane class="clickable cell" data-cell="7" position="0 -1.1 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>
      <a-plane class="clickable cell" data-cell="8" position="1.1 -1.1 0.01" width="1" height="1" color="#1a1a3e" opacity="0.5" material="shader: flat"></a-plane>

      <!-- Cell marks container -->
      <a-entity id="marks-container"></a-entity>

      <!-- Win line (hidden initially) -->
      <a-entity id="win-line" visible="false">
        <a-box id="win-line-box" width="0.08" height="3.4" depth="0.08" color="#22c55e" opacity="0.9"
               animation="property: material.opacity; from: 0.3; to: 0.9; dur: 500; dir: alternate; loop: true"></a-box>
      </a-entity>
    </a-entity>

    <!-- Title -->
    <a-entity position="0 4.2 -3" look-at-camera>
      <a-text value="TIC-TAC-TOE" align="center" width="8" color="#6366f1" font="mozillavr"></a-text>
    </a-entity>

    <!-- Score panel -->
    <a-entity position="3.5 2 -2.5" rotation="0 -30 0">
      <a-plane width="2.5" height="2" color="#0a0a1f" opacity="0.9" material="shader: flat">
        <a-plane width="2.3" height="1.8" color="#111128" opacity="0.95" position="0 0 0.01" material="shader: flat"></a-plane>
      </a-plane>
      <a-text value="SCORE" align="center" width="3" color="#a855f7" position="0 0.6 0.05" font="mozillavr"></a-text>
      <a-text id="score-x-label" value="X (You): 0" align="left" width="2.5" color="#6366f1" position="-0.9 0.15 0.05"></a-text>
      <a-text id="score-o-label" value="O (AI): 0" align="left" width="2.5" color="#ec4899" position="-0.9 -0.2 0.05"></a-text>
      <a-text id="score-draw-label" value="Draws: 0" align="left" width="2.5" color="#888" position="-0.9 -0.55 0.05"></a-text>
    </a-entity>

    <!-- Decorative particles -->
    <a-sphere position="-6 3 -6" radius="0.1" color="#6366f1" opacity="0.5"
              animation="property: position; to: -6 5 -6; dur: 4000; loop: true; dir: alternate; easing: easeInOutSine"></a-sphere>
    <a-sphere position="6 4 -4" radius="0.08" color="#ec4899" opacity="0.4"
              animation="property: position; to: 6 6 -4; dur: 3500; loop: true; dir: alternate; easing: easeInOutSine"></a-sphere>
    <a-sphere position="0 2 -8" radius="0.12" color="#a855f7" opacity="0.3"
              animation="property: position; to: 0 4 -8; dur: 5000; loop: true; dir: alternate; easing: easeInOutSine"></a-sphere>

    <!-- Lighting -->
    <a-light type="ambient" color="#303060" intensity="0.4"></a-light>
    <a-light type="point" position="0 5 -2" color="#6366f1" intensity="0.8" distance="15"></a-light>
    <a-light type="point" position="-3 3 -3" color="#a855f7" intensity="0.4" distance="10"></a-light>
    <a-light type="point" position="3 3 -3" color="#ec4899" intensity="0.4" distance="10"></a-light>

    <!-- Camera Rig -->
    <a-entity id="rig" position="0 1.6 2">
      <a-camera look-controls wasd-controls="acceleration: 10" fov="80">
        <!-- Gaze cursor ring: visual-only on desktop. layout-fix.js adds cursor+raycaster on enter-vr. -->
        <a-ring class="vr-gaze-ring"
                radius-inner="0.005" radius-outer="0.012"
                color="#6366f1" shader="flat" position="0 0 -1"
                visible="false"
                data-vr-cursor="fuse: true; fuseTimeout: 2500"
                data-vr-raycaster="objects: .clickable; far: 20"></a-ring>
      </a-camera>
      <a-entity laser-controls="hand: left" raycaster="objects: .clickable; far: 20; lineColor: #6366f1; lineOpacity: 0.5" cursor="rayOrigin: entity; fuse: false"></a-entity>
      <a-entity laser-controls="hand: right" raycaster="objects: .clickable; far: 20; lineColor: #a855f7; lineOpacity: 0.5" cursor="rayOrigin: entity; fuse: false"></a-entity>
    </a-entity>
  </a-scene>

  <script>
  (function() {
    'use strict';

    /* ═══════════════════════════════════════════
       CONFIG
       ═══════════════════════════════════════════ */
    var API_URL = '/api/ttt_match.php';
    var STORAGE_KEY = 'gameArena';
    var arenaState = (function() {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch(e) { return {}; }
    })();
    // Check for logged-in user name (Google auth / FavCreators)
    var authUser = null;
    try {
      var vrAuth = sessionStorage.getItem('vr_auth_user');
      if (vrAuth) authUser = JSON.parse(vrAuth);
      if (!authUser) {
        var fcAuth = sessionStorage.getItem('fc_user');
        if (fcAuth) authUser = JSON.parse(fcAuth);
      }
    } catch(e) {}

    var playerName = (authUser && (authUser.display_name || authUser.username))
                     || arenaState.playerName
                     || 'Guest_' + Math.floor(Math.random() * 9000 + 1000);
    var playerId   = (authUser && authUser.id)
                     || arenaState.playerId
                     || 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);

    // Persist playerId
    if (!arenaState.playerId) {
      arenaState.playerId = playerId;
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(arenaState)); } catch(e) {}
    }

    /* ═══════════════════════════════════════════
       LOADING
       ═══════════════════════════════════════════ */
    window.addEventListener('load', function () {
      setTimeout(function () {
        var el = document.getElementById('loading');
        el.style.opacity = '0';
        setTimeout(function () { el.classList.add('hidden'); }, 500);
      }, 1000);
      // Fetch queue count for lobby
      fetchQueueCount();
    });

    /* ═══════════════════════════════════════════
       GAME STATE
       ═══════════════════════════════════════════ */
    var gameMode     = null;  // 'ai' | 'human'
    var board        = [null,null,null,null,null,null,null,null,null];
    var currentPlayer = 'X';
    var gameOver     = false;
    var myMark       = 'X';
    var opponentName = 'AI';
    var scoreX = 0, scoreO = 0, scoreDraw = 0;

    // Multiplayer state
    var matchId      = null;
    var pollInterval = null;
    var queueTimeout = null;
    var lastBoardStr = '---------';

    var CELL_POS = [
      { x: -1.1, y: 1.1 }, { x: 0, y: 1.1 }, { x: 1.1, y: 1.1 },
      { x: -1.1, y: 0 },   { x: 0, y: 0 },   { x: 1.1, y: 0 },
      { x: -1.1, y: -1.1 },{ x: 0, y: -1.1 },{ x: 1.1, y: -1.1 }
    ];

    var WIN_LINES = [
      [0,1,2], [3,4,5], [6,7,8],
      [0,3,6], [1,4,7], [2,5,8],
      [0,4,8], [2,4,6]
    ];

    /* ═══════════════════════════════════════════
       API HELPERS
       ═══════════════════════════════════════════ */
    function apiPost(action, params, cb) {
      var body = 'action=' + encodeURIComponent(action);
      for (var k in params) {
        if (params.hasOwnProperty(k)) body += '&' + encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }
      var xhr = new XMLHttpRequest();
      xhr.open('POST', API_URL, true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      xhr.onload = function() {
        try { cb(null, JSON.parse(xhr.responseText)); } catch(e) { cb(e, null); }
      };
      xhr.onerror = function() { cb(new Error('Network error'), null); };
      xhr.send(body);
    }

    function apiGet(action, params, cb) {
      var qs = '?action=' + encodeURIComponent(action);
      for (var k in params) {
        if (params.hasOwnProperty(k)) qs += '&' + encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }
      var xhr = new XMLHttpRequest();
      xhr.open('GET', API_URL + qs, true);
      xhr.onload = function() {
        try { cb(null, JSON.parse(xhr.responseText)); } catch(e) { cb(e, null); }
      };
      xhr.onerror = function() { cb(new Error('Network error'), null); };
      xhr.send();
    }

    /* ═══════════════════════════════════════════
       QUEUE COUNT (lobby)
       ═══════════════════════════════════════════ */
    function fetchQueueCount() {
      apiGet('queue_count', {}, function(err, data) {
        var el = document.getElementById('online-count');
        if (!el) return;
        if (err || !data || !data.success) {
          el.textContent = '';
          return;
        }
        var parts = [];
        if (data.waiting > 0) parts.push(data.waiting + ' waiting in queue');
        if (data.active > 0)  parts.push(data.active + ' game(s) active');
        el.textContent = parts.length > 0 ? parts.join(' · ') : 'No players in queue — be the first!';
      });
    }

    /* ═══════════════════════════════════════════
       MODE SELECTION
       ═══════════════════════════════════════════ */
    window.startHumanQueue = function() {
      document.getElementById('queue-status').style.display = 'block';
      document.getElementById('queue-cancel').style.display = 'inline-block';
      document.getElementById('queue-text').textContent = 'Searching for opponent...';

      apiPost('join', { player_id: playerId, player_name: playerName }, function(err, data) {
        if (err || !data || !data.success) {
          document.getElementById('queue-text').textContent = 'Server error — try AI mode instead.';
          return;
        }

        matchId = data.match_id;
        myMark  = data.mark;

        if (data.matched) {
          // Instant match!
          opponentName = data.opponent || 'Human';
          startHumanGame();
        } else {
          // Waiting in queue...
          document.getElementById('queue-text').textContent = 'Waiting for opponent... (you are ' + myMark + ')';
          // Poll until matched (every 1.5s, timeout after 60s)
          var elapsed = 0;
          pollInterval = setInterval(function() {
            elapsed += 1500;
            if (elapsed > 60000) {
              clearInterval(pollInterval);
              pollInterval = null;
              document.getElementById('queue-text').textContent = 'No opponent found. Starting AI game...';
              apiPost('leave', { player_id: playerId, match_id: matchId }, function(){});
              setTimeout(function() { startAIMode(); }, 1500);
              return;
            }
            apiGet('poll', { player_id: playerId, match_id: matchId }, function(err2, data2) {
              if (err2 || !data2 || !data2.success) return;
              if (data2.status === 'active') {
                clearInterval(pollInterval);
                pollInterval = null;
                opponentName = data2.opponent || 'Human';
                myMark = data2.my_mark;
                startHumanGame();
              }
            });
          }, 1500);
        }
      });
    };

    window.startAIMode = function() {
      gameMode = 'ai';
      opponentName = 'AI';
      myMark = 'X';
      hideModeSelect();
      document.getElementById('name-x').textContent = playerName;
      document.getElementById('name-o').textContent = 'AI';
      resetBoardState();
      updateTurnHUD();
      setStatus('Your turn - Click a cell!');
    };

    window.cancelQueue = function() {
      if (pollInterval) { clearInterval(pollInterval); pollInterval = null; }
      if (matchId) {
        apiPost('leave', { player_id: playerId, match_id: matchId }, function(){});
        matchId = null;
      }
      document.getElementById('queue-status').style.display = 'none';
      document.getElementById('queue-cancel').style.display = 'none';
    };

    function startHumanGame() {
      gameMode = 'human';
      hideModeSelect();

      if (myMark === 'X') {
        document.getElementById('name-x').textContent = playerName;
        document.getElementById('name-o').textContent = opponentName;
      } else {
        document.getElementById('name-x').textContent = opponentName;
        document.getElementById('name-o').textContent = playerName;
      }

      resetBoardState();
      currentPlayer = 'X';
      updateTurnHUD();

      var isMyTurn = (myMark === 'X');
      setStatus(isMyTurn ? 'Your turn - Click a cell!' : 'Waiting for ' + opponentName + '...');

      // Enable chat for players
      enablePlayerChat();

      // Start polling for opponent moves
      lastBoardStr = '---------';
      startGamePolling();
    }

    function hideModeSelect() {
      document.getElementById('mode-select').classList.add('hidden');
    }

    function showModeSelect() {
      document.getElementById('mode-select').classList.remove('hidden');
      document.getElementById('queue-status').style.display = 'none';
      document.getElementById('queue-cancel').style.display = 'none';
      fetchQueueCount();
    }

    /* ═══════════════════════════════════════════
       GAME POLLING (human mode)
       ═══════════════════════════════════════════ */
    var specFetchCounter = 0;

    function startGamePolling() {
      if (pollInterval) clearInterval(pollInterval);
      specFetchCounter = 0;
      pollInterval = setInterval(function() {
        if (!matchId || gameOver) { clearInterval(pollInterval); pollInterval = null; return; }

        // Every ~5 polls (6s), also fetch full spectator list for chat panel
        specFetchCounter++;
        if (specFetchCounter % 5 === 0 && gameMode === 'human') {
          apiGet('spectate_poll', { match_id: matchId }, function(err2, data2) {
            if (!err2 && data2 && data2.success) {
              renderSpectatorsBar(data2.spectators || [], data2.spectator_count || 0);
            }
          });
        }

        apiGet('poll', { player_id: playerId, match_id: matchId }, function(err, data) {
          if (err || !data || !data.success) return;
          // Sync board state
          if (data.board && data.board !== lastBoardStr) {
            syncBoard(data.board);
            lastBoardStr = data.board;
          }
          currentPlayer = data.current_turn;
          updateTurnHUD();

          // Update spectator count
          if (typeof data.spectator_count !== 'undefined') {
            var scBadge = document.getElementById('spectator-count');
            if (scBadge) scBadge.textContent = data.spectator_count;
          }

          // Show chat request toasts from spectators
          if (data.chat_requests && data.chat_requests.length > 0) {
            for (var cr = 0; cr < data.chat_requests.length; cr++) {
              var reqName = data.chat_requests[cr];
              if (!knownChatReqs[reqName]) {
                knownChatReqs[reqName] = true;
                showChatRequestToast(reqName);
              }
            }
          }

          if (data.status === 'done') {
            clearInterval(pollInterval);
            pollInterval = null;
            handleServerGameEnd(data);
          } else {
            var isMyTurn = (data.current_turn === myMark);
            setStatus(isMyTurn ? 'Your turn - Click a cell!' : 'Waiting for ' + opponentName + '...');
          }
        });
      }, 1200);
    }

    function syncBoard(serverBoard) {
      for (var i = 0; i < 9; i++) {
        var serverMark = serverBoard[i] === '-' ? null : serverBoard[i];
        if (serverMark !== null && board[i] === null) {
          board[i] = serverMark;
          placeMarker(i, serverMark);
        }
      }
    }

    function handleServerGameEnd(data) {
      gameOver = true;
      // Check for win line
      for (var i = 0; i < WIN_LINES.length; i++) {
        var line = WIN_LINES[i];
        if (board[line[0]] && board[line[0]] === board[line[1]] && board[line[0]] === board[line[2]]) {
          showWinLine(line);
          break;
        }
      }

      var result;
      if (data.winner === 'D' || data.winner === 'A') {
        result = 'draw';
      } else if (data.winner === myMark) {
        result = 'win';
      } else {
        result = 'loss';
      }
      endGame(result, data.winner);
    }

    /* ═══════════════════════════════════════════
       CELL CLICK
       ═══════════════════════════════════════════ */
    function setupCells() {
      document.querySelectorAll('.cell').forEach(function(cell) {
        cell.addEventListener('click', function() {
          var idx = parseInt(cell.getAttribute('data-cell'));
          handleMove(idx);
        });
        cell.addEventListener('mouseenter', function() {
          var idx = parseInt(cell.getAttribute('data-cell'));
          if (!gameOver && board[idx] === null && isMyTurnNow()) {
            cell.setAttribute('material', 'opacity', 0.8);
            cell.setAttribute('color', '#252550');
          }
        });
        cell.addEventListener('mouseleave', function() {
          var idx = parseInt(cell.getAttribute('data-cell'));
          if (board[idx] === null) {
            cell.setAttribute('material', 'opacity', 0.5);
            cell.setAttribute('color', '#1a1a3e');
          }
        });
      });
    }

    function isMyTurnNow() {
      if (isSpectator) return false;
      if (gameMode === 'ai') return currentPlayer === 'X';
      return currentPlayer === myMark;
    }

    function handleMove(idx) {
      if (isSpectator || gameOver || board[idx] !== null || !isMyTurnNow()) return;

      if (gameMode === 'human') {
        // Send move to server
        placeMarker(idx, myMark);
        board[idx] = myMark;
        currentPlayer = (myMark === 'X') ? 'O' : 'X';
        updateTurnHUD();
        setStatus('Waiting for ' + opponentName + '...');

        apiPost('move', { player_id: playerId, match_id: matchId, cell: idx }, function(err, data) {
          if (err || !data || !data.success) {
            setStatus('Move failed — retrying...');
            return;
          }
          lastBoardStr = data.board;
          if (data.status === 'done') {
            if (pollInterval) { clearInterval(pollInterval); pollInterval = null; }
            handleServerGameEnd(data);
          }
        });
      } else {
        // AI mode
        placeMarker(idx, 'X');
        board[idx] = 'X';

        if (checkWin('X')) { endGame('win', 'X'); return; }
        if (isBoardFull()) { endGame('draw'); return; }

        currentPlayer = 'O';
        updateTurnHUD();
        setStatus('AI is thinking...');

        setTimeout(function() {
          if (gameOver) return;
          var move = getAIMove();
          if (move !== -1) {
            placeMarker(move, 'O');
            board[move] = 'O';
            if (checkWin('O')) { endGame('loss', 'O'); return; }
            if (isBoardFull()) { endGame('draw'); return; }
          }
          currentPlayer = 'X';
          updateTurnHUD();
          setStatus('Your turn - Click a cell!');
        }, 600 + Math.random() * 800);
      }
    }

    /* ═══════════════════════════════════════════
       3D MARKER
       ═══════════════════════════════════════════ */
    function placeMarker(idx, mark) {
      var container = document.getElementById('marks-container');
      var pos = CELL_POS[idx];

      if (mark === 'X') {
        var xEntity = document.createElement('a-entity');
        xEntity.setAttribute('position', pos.x + ' ' + pos.y + ' 0.1');
        xEntity.innerHTML =
          '<a-box width="0.08" height="0.7" depth="0.08" color="#6366f1" rotation="0 0 45" opacity="0.95"' +
          '  animation="property: scale; from: 0 0 0; to: 1 1 1; dur: 300; easing: easeOutBack"></a-box>' +
          '<a-box width="0.08" height="0.7" depth="0.08" color="#6366f1" rotation="0 0 -45" opacity="0.95"' +
          '  animation="property: scale; from: 0 0 0; to: 1 1 1; dur: 300; easing: easeOutBack; delay: 100"></a-box>' +
          '<a-light type="point" color="#6366f1" intensity="0.3" distance="2"></a-light>';
        container.appendChild(xEntity);
      } else {
        var oEntity = document.createElement('a-entity');
        oEntity.setAttribute('position', pos.x + ' ' + pos.y + ' 0.1');
        oEntity.innerHTML =
          '<a-torus radius="0.28" radius-tubular="0.04" color="#ec4899" opacity="0.95" segments-radial="32" segments-tubular="16"' +
          '  animation="property: scale; from: 0 0 0; to: 1 1 1; dur: 300; easing: easeOutBack"></a-torus>' +
          '<a-light type="point" color="#ec4899" intensity="0.3" distance="2"></a-light>';
        container.appendChild(oEntity);
      }

      var cell = document.querySelector('.cell[data-cell="' + idx + '"]');
      if (cell) {
        cell.setAttribute('color', mark === 'X' ? '#1a1a4e' : '#2e1a2e');
        cell.setAttribute('material', 'opacity', 0.3);
      }
    }

    /* ═══════════════════════════════════════════
       AI ENGINE
       ═══════════════════════════════════════════ */
    function getAIMove() {
      for (var i = 0; i < 9; i++) { if (board[i] === null) { board[i] = 'O'; if (checkWinFor('O')) { board[i] = null; return i; } board[i] = null; } }
      for (var i = 0; i < 9; i++) { if (board[i] === null) { board[i] = 'X'; if (checkWinFor('X')) { board[i] = null; return i; } board[i] = null; } }
      if (board[4] === null) return 4;
      var corners = [0,2,6,8]; var avail = corners.filter(function(c){return board[c]===null;});
      if (avail.length > 0) return avail[Math.floor(Math.random() * avail.length)];
      var empty = []; for (var i = 0; i < 9; i++) { if (board[i] === null) empty.push(i); }
      return empty.length > 0 ? empty[Math.floor(Math.random() * empty.length)] : -1;
    }

    function checkWinFor(mark) {
      return WIN_LINES.some(function(line) {
        return board[line[0]] === mark && board[line[1]] === mark && board[line[2]] === mark;
      });
    }

    function checkWin(mark) {
      for (var i = 0; i < WIN_LINES.length; i++) {
        var line = WIN_LINES[i];
        if (board[line[0]] === mark && board[line[1]] === mark && board[line[2]] === mark) {
          showWinLine(line);
          return true;
        }
      }
      return false;
    }

    function isBoardFull() { return board.every(function(c) { return c !== null; }); }

    /* ═══════════════════════════════════════════
       WIN LINE
       ═══════════════════════════════════════════ */
    function showWinLine(line) {
      var p0 = CELL_POS[line[0]], p2 = CELL_POS[line[2]];
      var cx = (p0.x + p2.x) / 2, cy = (p0.y + p2.y) / 2;
      var dx = p2.x - p0.x, dy = p2.y - p0.y;
      var len = Math.sqrt(dx*dx + dy*dy) + 0.5;
      var angle = Math.atan2(dx, dy) * (180 / Math.PI);

      var winLine = document.getElementById('win-line');
      var box = document.getElementById('win-line-box');
      winLine.setAttribute('position', cx + ' ' + cy + ' 0.15');
      box.setAttribute('height', len);
      winLine.setAttribute('rotation', '0 0 ' + (-angle));
      winLine.setAttribute('visible', 'true');
    }

    /* ═══════════════════════════════════════════
       END GAME
       ═══════════════════════════════════════════ */
    function endGame(result, winner) {
      gameOver = true;
      var overlay = document.getElementById('win-overlay');
      var title   = document.getElementById('win-title');
      var sub     = document.getElementById('win-subtitle');

      if (result === 'win') {
        title.textContent = 'You Win!';
        title.style.color = '#22c55e';
        sub.textContent = (gameMode === 'human') ? 'You defeated ' + opponentName + '!' : 'X wins the round!';
        scoreX++;
        recordMatch('win');
      } else if (result === 'loss') {
        title.textContent = opponentName + ' Wins!';
        title.style.color = '#ef4444';
        sub.textContent = (gameMode === 'human') ? opponentName + ' outplayed you!' : 'O wins the round!';
        scoreO++;
        recordMatch('loss');
      } else {
        title.textContent = 'Draw!';
        title.style.color = '#f59e0b';
        sub.textContent = 'Nobody wins this round.';
        scoreDraw++;
        recordMatch('draw');
      }

      updateScorePanel();
      setStatus(result === 'win' ? 'Victory!' : result === 'loss' ? 'Defeat!' : 'Draw!');

      setTimeout(function() { overlay.classList.add('active'); }, 800);
    }

    function recordMatch(result) {
      try {
        var s = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
        s.wins   = (s.wins || 0)   + (result === 'win'  ? 1 : 0);
        s.losses = (s.losses || 0) + (result === 'loss' ? 1 : 0);
        s.draws  = (s.draws || 0)  + (result === 'draw' ? 1 : 0);
        if (!s.matches) s.matches = [];
        s.matches.push({ game: 'Tic-Tac-Toe', opponent: opponentName, result: result, time: Date.now() });
        localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
      } catch(e) {}
    }

    function updateScorePanel() {
      var sx = document.getElementById('score-x-label');
      var so = document.getElementById('score-o-label');
      var sd = document.getElementById('score-draw-label');
      var xName = (gameMode === 'human' && myMark === 'O') ? opponentName : playerName;
      var oName = (gameMode === 'human' && myMark === 'O') ? playerName : opponentName;
      if (sx) sx.setAttribute('value', 'X (' + xName + '): ' + scoreX);
      if (so) so.setAttribute('value', 'O (' + oName + '): ' + scoreO);
      if (sd) sd.setAttribute('value', 'Draws: ' + scoreDraw);
    }

    /* ═══════════════════════════════════════════
       RESET / QUIT
       ═══════════════════════════════════════════ */
    function resetBoardState() {
      board = [null,null,null,null,null,null,null,null,null];
      currentPlayer = 'X';
      gameOver = false;
      lastBoardStr = '---------';

      var container = document.getElementById('marks-container');
      container.innerHTML = '';

      document.querySelectorAll('.cell').forEach(function(cell) {
        cell.setAttribute('color', '#1a1a3e');
        cell.setAttribute('material', 'opacity', 0.5);
      });
      document.getElementById('win-line').setAttribute('visible', 'false');
      document.getElementById('win-overlay').classList.remove('active');
    }

    window.resetGame = function() {
      if (gameMode === 'human' && matchId) {
        // Request rematch
        apiPost('rematch', { player_id: playerId, match_id: matchId }, function(err, data) {
          if (err || !data || !data.success) {
            // Fallback to lobby
            showModeSelect();
            return;
          }
          if (data.rematch && data.new_match_id) {
            matchId = data.new_match_id;
            myMark  = data.mark;
            document.getElementById('win-overlay').classList.remove('active');
            startHumanGame();
          } else {
            // Waiting for opponent to accept rematch
            document.getElementById('win-overlay').classList.remove('active');
            setStatus('Waiting for ' + opponentName + ' to accept rematch...');
            // Poll for rematch acceptance
            var rematchPoll = setInterval(function() {
              apiGet('poll', { player_id: playerId, match_id: matchId }, function(err2, data2) {
                if (err2 || !data2) return;
                if (data2.rematch_them === 1) {
                  clearInterval(rematchPoll);
                  // Re-check for new match
                  apiPost('rematch', { player_id: playerId, match_id: matchId }, function(err3, data3) {
                    if (data3 && data3.rematch && data3.new_match_id) {
                      matchId = data3.new_match_id;
                      myMark  = data3.mark;
                      startHumanGame();
                    }
                  });
                }
              });
            }, 1500);
            // Timeout after 30s
            setTimeout(function() { clearInterval(rematchPoll); }, 30000);
          }
        });
      } else {
        // AI mode — simple reset
        resetBoardState();
        updateTurnHUD();
        setStatus('Your turn - Click a cell!');
      }
    };

    window.abandonMatch = function() {
      if (pollInterval) { clearInterval(pollInterval); pollInterval = null; }
      if (gameMode === 'human' && matchId) {
        apiPost('leave', { player_id: playerId, match_id: matchId }, function(){});
        matchId = null;
      }
      gameOver = true;
      gameMode = null;
      disableChat();
      showModeSelect();
      resetBoardState();
    };

    /* ═══════════════════════════════════════════
       HUD HELPERS
       ═══════════════════════════════════════════ */
    function updateTurnHUD() {
      var hudX = document.getElementById('hud-x');
      var hudO = document.getElementById('hud-o');
      if (currentPlayer === 'X') {
        hudX.classList.add('active');  hudO.classList.remove('active');
        hudX.style.boxShadow = '0 0 20px rgba(99,102,241,0.4)'; hudO.style.boxShadow = 'none';
      } else {
        hudO.classList.add('active');  hudX.classList.remove('active');
        hudO.style.boxShadow = '0 0 20px rgba(236,72,153,0.4)'; hudX.style.boxShadow = 'none';
      }
    }

    function setStatus(text) {
      document.getElementById('hud-status').textContent = text;
    }

    /* ═══════════════════════════════════════════
       SPECTATOR & CHAT STATE
       ═══════════════════════════════════════════ */
    var isSpectator    = false;
    var chatOpen       = false;
    var chatPollTimer  = null;
    var specPollTimer  = null;
    var lastChatId     = 0;
    var chatReqSent    = false;
    var chatApproved   = false;
    var chatUnread     = 0;
    var knownChatReqs  = {};  // track which spectator chat requests we've already shown a toast for

    /* ═══════════════════════════════════════════
       WATCH MODE — list & pick active games
       ═══════════════════════════════════════════ */
    window.startWatchMode = function() {
      apiGet('list_active', {}, function(err, data) {
        if (err || !data || !data.success) return;
        var listEl  = document.getElementById('active-games-list');
        var inner   = document.getElementById('games-list-inner');
        var noGames = document.getElementById('no-games-msg');
        inner.innerHTML = '';

        if (!data.games || data.games.length === 0) {
          noGames.style.display = 'block';
        } else {
          noGames.style.display = 'none';
          for (var i = 0; i < data.games.length; i++) {
            (function(g) {
              var card = document.createElement('div');
              card.className = 'game-card';
              card.innerHTML =
                '<div><div class="game-card-players">' + htmlEsc(g.player_x) + ' vs ' + htmlEsc(g.player_o) + '</div>' +
                '<div class="game-card-info">' + g.spectators + ' spectator(s) \u00B7 Turn: ' + g.current_turn + '</div></div>' +
                '<div class="game-card-watch">\u25B6 WATCH</div>';
              card.addEventListener('click', function() { joinAsSpectator(g.match_id); });
              inner.appendChild(card);
            })(data.games[i]);
          }
        }

        // Show list, hide mode buttons
        document.querySelector('.mode-btns').style.display = 'none';
        document.getElementById('online-count').style.display = 'none';
        listEl.style.display = 'block';
      });
    };

    window.cancelWatch = function() {
      document.getElementById('active-games-list').style.display = 'none';
      document.querySelector('.mode-btns').style.display = 'flex';
      document.getElementById('online-count').style.display = '';
    };

    function htmlEsc(str) {
      var d = document.createElement('div');
      d.textContent = str || '';
      return d.innerHTML;
    }

    /* ═══════════════════════════════════════════
       JOIN AS SPECTATOR
       ═══════════════════════════════════════════ */
    function joinAsSpectator(mid) {
      apiPost('spectate_join', { spectator_id: playerId, spectator_name: playerName, match_id: mid }, function(err, data) {
        if (err || !data || !data.success) {
          showToast('Error', data ? data.error : 'Could not join', 4000);
          return;
        }

        isSpectator = true;
        matchId     = mid;
        gameMode    = 'spectate';
        gameOver    = false;

        // Set HUD names
        document.getElementById('name-x').textContent = data.player_x || 'Player X';
        document.getElementById('name-o').textContent = data.player_o || 'Player O';
        opponentName = (data.player_x || '?') + ' vs ' + (data.player_o || '?');

        hideModeSelect();
        resetBoardState();

        // Sync initial board
        if (data.board) syncBoard(data.board);
        currentPlayer = data.current_turn;
        updateTurnHUD();
        setStatus('\uD83D\uDC41 Spectating \u2014 ' + opponentName);

        // Show spectator UI
        document.getElementById('spectator-badge').style.display = 'block';
        document.getElementById('chat-toggle-btn').style.display = 'flex';

        // Swap bottom buttons for spectator
        var btns = document.getElementById('game-btns');
        btns.innerHTML =
          '<button class="btn btn-secondary" onclick="toggleChat()">\uD83D\uDCAC Chat</button>' +
          '<button class="btn btn-danger" onclick="leaveSpectate()">Leave</button>' +
          '<a class="btn btn-secondary" href="/vr/game-arena/">Back to Arena</a>';

        // Show chat request instead of input
        document.getElementById('chat-input-area').style.display = 'none';
        document.getElementById('chat-request-area').style.display = 'block';

        // Start polling
        startSpectatorPolling();
        startChatPolling();
      });
    }

    /* ═══════════════════════════════════════════
       SPECTATOR POLLING
       ═══════════════════════════════════════════ */
    function startSpectatorPolling() {
      if (specPollTimer) clearInterval(specPollTimer);
      specPollTimer = setInterval(function() {
        if (!matchId) { clearInterval(specPollTimer); return; }

        apiGet('spectate_poll', { match_id: matchId }, function(err, data) {
          if (err || !data || !data.success) return;

          if (data.board && data.board !== lastBoardStr) {
            syncBoard(data.board);
            lastBoardStr = data.board;
          }
          currentPlayer = data.current_turn;
          updateTurnHUD();

          // Update spectator count badge
          var badge = document.getElementById('spectator-count');
          if (badge) badge.textContent = data.spectator_count || 0;

          // Check if my chat was approved
          if (isSpectator && data.spectators) {
            for (var s = 0; s < data.spectators.length; s++) {
              if (data.spectators[s].name === playerName && data.spectators[s].can_chat === 1) {
                if (!chatApproved) {
                  chatApproved = true;
                  document.getElementById('chat-request-area').style.display = 'none';
                  document.getElementById('chat-input-area').style.display = 'flex';
                  showToast('Chat Approved', 'You can now send messages!', 3000);
                }
                break;
              }
            }
          }

          // Update spectators bar in chat
          renderSpectatorsBar(data.spectators || [], data.spectator_count || 0);

          if (data.status === 'done') {
            clearInterval(specPollTimer);
            specPollTimer = null;
            var winner = data.winner;
            if (winner === 'D' || winner === 'A') {
              setStatus('Game over \u2014 Draw!');
            } else {
              var winName = (winner === 'X') ? (data.player_x || 'X') : (data.player_o || 'O');
              setStatus('Game over \u2014 ' + winName + ' wins!');
            }
            // Show game end in chat
            addLocalChatMsg('System', 'system', 'Game over!');
          }
        });
      }, 1200);
    }

    window.leaveSpectate = function() {
      if (specPollTimer)  { clearInterval(specPollTimer);  specPollTimer = null; }
      if (chatPollTimer) { clearInterval(chatPollTimer); chatPollTimer = null; }
      if (matchId) {
        apiPost('spectate_leave', { spectator_id: playerId, match_id: matchId }, function(){});
      }
      isSpectator  = false;
      matchId      = null;
      gameMode     = null;
      chatOpen     = false;
      lastChatId   = 0;
      chatReqSent  = false;
      chatApproved = false;
      chatUnread   = 0;
      knownChatReqs = {};

      document.getElementById('chat-panel').classList.remove('open');
      document.getElementById('chat-toggle-btn').style.display = 'none';
      document.getElementById('spectator-badge').style.display = 'none';
      document.getElementById('chat-messages').innerHTML = '';
      document.getElementById('chat-input-area').style.display = 'flex';
      document.getElementById('chat-request-area').style.display = 'none';

      // Restore buttons
      document.getElementById('game-btns').innerHTML =
        '<button class="btn btn-primary" onclick="resetGame()">New Game</button>' +
        '<button class="btn btn-danger" onclick="abandonMatch()">Abandon</button>' +
        '<a class="btn btn-secondary" href="/vr/game-arena/">Back to Arena</a>';

      showModeSelect();
      resetBoardState();
    };

    /* ═══════════════════════════════════════════
       CHAT — TOGGLE, SEND, POLL
       ═══════════════════════════════════════════ */
    window.toggleChat = function() {
      chatOpen = !chatOpen;
      var panel = document.getElementById('chat-panel');
      if (chatOpen) {
        panel.classList.add('open');
        chatUnread = 0;
        updateChatBadge();
        var msgs = document.getElementById('chat-messages');
        msgs.scrollTop = msgs.scrollHeight;
        // Focus input if allowed
        var inp = document.getElementById('chat-input');
        if (inp.offsetParent !== null) inp.focus();
      } else {
        panel.classList.remove('open');
      }
    };

    window.sendChatMessage = function() {
      var inp = document.getElementById('chat-input');
      var msg = inp.value.trim();
      if (!msg || !matchId) return;
      inp.value = '';

      var senderType = isSpectator ? 'spectator' : 'player';
      apiPost('chat_send', {
        match_id: matchId,
        sender_name: playerName,
        sender_type: senderType,
        message: msg
      }, function(err, data) {
        if (err || !data || !data.success) {
          if (data && data.error === 'chat_not_allowed') {
            showToast('Chat', 'Your chat request hasn\'t been approved yet.', 3000);
          }
        }
      });
    };

    // Enter key sends chat
    document.getElementById('chat-input').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.keyCode === 13) {
        e.preventDefault();
        sendChatMessage();
      }
    });

    function startChatPolling() {
      if (chatPollTimer) clearInterval(chatPollTimer);
      lastChatId = 0;
      chatPollTimer = setInterval(function() {
        if (!matchId) { clearInterval(chatPollTimer); return; }
        apiGet('chat_poll', { match_id: matchId, after_id: lastChatId }, function(err, data) {
          if (err || !data || !data.success) return;
          var msgs = data.messages || [];
          for (var i = 0; i < msgs.length; i++) {
            addLocalChatMsg(msgs[i].name, msgs[i].type, msgs[i].message);
            lastChatId = msgs[i].id;
          }
          if (msgs.length > 0 && !chatOpen) {
            chatUnread += msgs.length;
            updateChatBadge();
          }
        });
      }, 1500);
    }

    function addLocalChatMsg(name, type, message) {
      var container = document.getElementById('chat-messages');
      var div = document.createElement('div');
      if (type === 'system') {
        div.className = 'chat-msg system-msg';
        div.textContent = message;
      } else {
        div.className = 'chat-msg';
        var nameSpan = document.createElement('span');
        nameSpan.className = 'chat-name ' + type;
        nameSpan.textContent = name + ':';
        var textSpan = document.createElement('span');
        textSpan.className = 'chat-text';
        textSpan.textContent = ' ' + message;
        div.appendChild(nameSpan);
        div.appendChild(textSpan);
      }
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }

    function updateChatBadge() {
      var badge = document.getElementById('chat-unread');
      var btn   = document.getElementById('chat-toggle-btn');
      if (chatUnread > 0) {
        badge.textContent = chatUnread > 9 ? '9+' : chatUnread;
        badge.style.display = 'flex';
        btn.classList.add('has-new');
        setTimeout(function() { btn.classList.remove('has-new'); }, 600);
      } else {
        badge.style.display = 'none';
      }
    }

    /* ═══════════════════════════════════════════
       CHAT REQUEST / APPROVE (spectators)
       ═══════════════════════════════════════════ */
    window.requestChatPermission = function() {
      if (chatReqSent || !matchId) return;
      chatReqSent = true;
      document.getElementById('chat-request-btn').disabled = true;
      document.getElementById('chat-request-status').textContent = 'Request sent \u2014 waiting for approval...';

      apiPost('chat_request', { match_id: matchId, spectator_id: playerId }, function(err, data) {
        if (err || !data || !data.success) {
          document.getElementById('chat-request-status').textContent = 'Error sending request.';
          chatReqSent = false;
          document.getElementById('chat-request-btn').disabled = false;
        }
      });
    };

    window.approveChatRequest = function(specName) {
      if (!matchId) return;
      apiPost('chat_approve', { match_id: matchId, spectator_name: specName }, function(err, data) {
        if (err || !data || !data.success) return;
        showToast('Chat', specName + ' can now chat', 3000);
        // Remove the toast approval button
        var toastEl = document.getElementById('toast-approve-' + specName.replace(/\s/g,'_'));
        if (toastEl) toastEl.parentNode.removeChild(toastEl);
      });
    };

    /* ═══════════════════════════════════════════
       SPECTATORS BAR IN CHAT
       ═══════════════════════════════════════════ */
    function renderSpectatorsBar(spectators, count) {
      var bar   = document.getElementById('chat-spectators-bar');
      var label = document.getElementById('chat-spec-label');
      if (label) label.textContent = count > 0 ? count + ' watching' : '';

      if (!spectators || spectators.length === 0) {
        bar.style.display = 'none';
        return;
      }
      bar.style.display = 'block';
      var html = '<div style="font-weight:600;margin-bottom:3px;">Spectators:</div>';
      for (var i = 0; i < spectators.length; i++) {
        var sp = spectators[i];
        html += '<div class="spec-item"><span class="spec-name">' + htmlEsc(sp.name) + '</span>';
        if (sp.can_chat === 1) {
          html += '<span class="spec-badge approved">\u2714 Can chat</span>';
        } else if (sp.chat_requested === 1 && !isSpectator) {
          html += '<button class="spec-approve-btn" onclick="approveChatRequest(\'' + htmlEsc(sp.name).replace(/'/g, "\\'") + '\')">\u2714 Approve</button>';
        } else if (sp.chat_requested === 1) {
          html += '<span class="spec-badge">Pending...</span>';
        }
        html += '</div>';
      }
      bar.innerHTML = html;
    }

    /* ═══════════════════════════════════════════
       TOAST HELPER
       ═══════════════════════════════════════════ */
    function showToast(title, msg, duration) {
      var container = document.getElementById('toast-container');
      var toast = document.createElement('div');
      toast.className = 'toast';
      toast.innerHTML = '<div class="toast-title">' + htmlEsc(title) + '</div><div class="toast-msg">' + htmlEsc(msg) + '</div>';
      container.appendChild(toast);
      setTimeout(function() { if (toast.parentNode) toast.parentNode.removeChild(toast); }, duration || 5000);
    }

    function showChatRequestToast(specName) {
      var container = document.getElementById('toast-container');
      var safeId = 'toast-approve-' + specName.replace(/\s/g,'_');
      var toast = document.createElement('div');
      toast.className = 'toast';
      toast.id = safeId;
      toast.innerHTML =
        '<div class="toast-title">\uD83D\uDE4B Chat Request</div>' +
        '<div class="toast-msg">' + htmlEsc(specName) + ' wants to chat</div>' +
        '<div class="toast-actions">' +
        '<button class="toast-btn accept" onclick="approveChatRequest(\'' + htmlEsc(specName).replace(/'/g, "\\'") + '\')">Approve</button>' +
        '<button class="toast-btn decline" onclick="this.closest(\'.toast\').remove()">Ignore</button>' +
        '</div>';
      container.appendChild(toast);
      // Auto-dismiss after 15s
      setTimeout(function() { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 15000);
    }

    /* ═══════════════════════════════════════════
       INTEGRATE CHAT/SPECTATORS INTO HUMAN GAME
       ═══════════════════════════════════════════ */
    function enablePlayerChat() {
      document.getElementById('chat-toggle-btn').style.display = 'flex';
      document.getElementById('spectator-badge').style.display = 'block';
      document.getElementById('chat-input-area').style.display = 'flex';
      document.getElementById('chat-request-area').style.display = 'none';
      startChatPolling();
    }

    function disableChat() {
      if (chatPollTimer) { clearInterval(chatPollTimer); chatPollTimer = null; }
      if (specPollTimer) { clearInterval(specPollTimer); specPollTimer = null; }
      document.getElementById('chat-toggle-btn').style.display = 'none';
      document.getElementById('spectator-badge').style.display = 'none';
      document.getElementById('chat-panel').classList.remove('open');
      chatOpen     = false;
      lastChatId   = 0;
      chatUnread   = 0;
      chatReqSent  = false;
      chatApproved = false;
      knownChatReqs = {};
      document.getElementById('chat-messages').innerHTML = '';
    }

    /* ═══════════════════════════════════════════
       CLEANUP ON UNLOAD
       ═══════════════════════════════════════════ */
    window.addEventListener('beforeunload', function() {
      if (isSpectator && matchId) {
        navigator.sendBeacon(API_URL + '?action=spectate_leave', 'spectator_id=' + encodeURIComponent(playerId) + '&match_id=' + matchId);
      } else if (matchId && gameMode === 'human' && !gameOver) {
        navigator.sendBeacon(API_URL + '?action=leave', 'player_id=' + encodeURIComponent(playerId) + '&match_id=' + matchId);
      }
    });

    /* ═══════════════════════════════════════════
       INIT
       ═══════════════════════════════════════════ */
    updateScorePanel();
    setupCells();
    // Start in lobby mode — mode-select is shown by default
  })();
  </script>
</body>
</html>
